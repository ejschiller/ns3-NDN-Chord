Index: examples/chord-run/chord-run.cc
===================================================================
new file mode 100644
--- /dev/null
+++ b/examples/chord-run/chord-run.cc
@@ -0,0 +1,765 @@
+/* -*- Mode:C++; c-file-style:"gnu"; indent-tabs-mode:nil; -*- */
+/*
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation;
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+// Network topology
+//
+//       n0    n1   n2   n3                     nx
+//       |     |    |    |  . . . . . . . . . . |
+//       ========================================
+//                          LAN
+//
+
+#include <fstream>
+#include <stdlib.h>
+#include <stdint.h>
+#include <iostream>
+#include <string.h>
+#include <vector>
+#include <openssl/sha.h>
+#include "ns3/core-module.h"
+#include "ns3/common-module.h"
+#include "ns3/node-module.h"
+#include "ns3/simulator-module.h"
+#include "ns3/helper-module.h"
+#include "ns3/chord-ipv4.h"
+#include "ns3/object.h"
+#include "ns3/nstime.h"
+using namespace ns3;
+
+NS_LOG_COMPONENT_DEFINE("ChordRun");
+
+struct CommandHandlerArgument
+{
+  std::string scriptFile;
+  NodeContainer nodeContainer;
+  void *chordRun;
+};
+
+class ChordRun
+{
+
+ public:
+
+    void Start (std::string scriptFile, NodeContainer nodeContainer);
+    void Stop ();
+
+    //Chord
+    void InsertVNode(Ptr<ChordIpv4> chordApplication, std::string vNodeName);
+    void Lookup (Ptr<ChordIpv4> chordApplication, std::string resourceName);
+
+    //DHash
+    void Insert (Ptr<ChordIpv4> chordApplication, std::string resourceName, std::string resourceValue);
+    void Retrieve (Ptr<ChordIpv4> chordApplication, std::string resourceName);
+
+    //Crash Testing
+    void DetachNode(uint16_t nodeNumber);
+    void ReAttachNode(uint16_t nodeNumber);
+    void CrashChord(Ptr<ChordIpv4> chordApplication);
+    void RestartChord(Ptr<ChordIpv4> chordApplication);
+
+    // Call backs by Chord Layer
+    void JoinSuccess (std::string vNodeName, uint8_t* key, uint8_t numBytes);
+    void LookupSuccess (uint8_t* lookupKey, uint8_t lookupKeyBytes, Ipv4Address ipAddress, uint16_t port);
+    void LookupFailure (uint8_t* lookupKey, uint8_t lookupKeyBytes);
+    void InsertSuccess (uint8_t* key, uint8_t numBytes, uint8_t* object, uint32_t objectBytes);
+    void RetrieveSuccess (uint8_t* key, uint8_t numBytes, uint8_t* object, uint32_t objectBytes);
+    void InsertFailure (uint8_t* key, uint8_t numBytes, uint8_t* object, uint32_t objectBytes);
+    void RetrieveFailure (uint8_t* key, uint8_t numBytes);
+    void VNodeKeyOwnership (std::string vNodeName, uint8_t* key, uint8_t keyBytes, uint8_t* predecessorKey, uint8_t predecessorKeyBytes
+			   ,uint8_t* oldPredecessorKey, uint8_t oldPredecessorKeyBytes, Ipv4Address predecessorIp, uint16_t predecessorPort);
+
+
+    //Statistics
+    void TraceRing (std::string vNodeName, uint8_t* key, uint8_t numBytes);
+    void VNodeFailure (std::string vNodeName, uint8_t* key, uint8_t numBytes);
+    void DumpVNodeInfo ( Ptr<ChordIpv4> chordApplication, std::string vNodeName);
+    void DumpDHashInfo (Ptr<ChordIpv4> chordApplication);
+
+    //Keyboard Handlers
+    static void *CommandHandler (void *arg);
+    void Tokenize(const std::string& str, std::vector<std::string>& tokens, const std::string& delimiters);
+    void ProcessCommandTokens (std::vector<std::string> tokens, Time time);
+    void ReadCommandTokens (void);
+
+
+    pthread_t commandHandlerThreadId;
+    struct CommandHandlerArgument th_argument;
+
+  private:
+    ChordRun* m_chordRun;
+    std::string m_scriptFile;
+    NodeContainer m_nodeContainer;
+    std::vector<std::string> m_tokens;
+    bool m_readyToRead;
+    
+    //Print
+    void PrintCharArray (uint8_t*, uint32_t, std::ostream&);
+    void PrintHexArray (uint8_t*, uint32_t, std::ostream&);
+
+};
+
+ void
+ ChordRun::Start (std::string scriptFile, NodeContainer nodeContainer)
+ {
+
+  NS_LOG_FUNCTION_NOARGS();
+  th_argument.scriptFile = scriptFile;
+  th_argument.nodeContainer  = nodeContainer;
+  th_argument.chordRun = (void *)this;
+  this->m_chordRun = this;
+  this->m_nodeContainer = nodeContainer;
+
+  m_readyToRead = false;
+  //process script-file
+  if (scriptFile != "")                                 //Start reading the script file.....if not null
+  {
+    std::ifstream file;
+    file.open (scriptFile.c_str());
+    if (file.is_open())
+    {
+      NS_LOG_INFO ("Reading Script File: " << scriptFile);
+      Time time = MilliSeconds (0.0);
+      std::string commandLine;
+      while (!file.eof())
+      {
+        std::getline (file, commandLine, '\n');
+        std::cout << "Adding Command: " << commandLine << std::endl;
+        m_chordRun->Tokenize (commandLine, m_chordRun -> m_tokens, " ");
+        if (m_chordRun -> m_tokens.size() == 0)
+        {
+          NS_LOG_INFO ("Failed to Tokenize");
+          continue;
+        }
+        //check for time command
+        std::vector<std::string>::iterator iterator = m_chordRun -> m_tokens.begin();
+        if (*iterator == "Time")
+        {
+          if (m_chordRun -> m_tokens.size() < 2)
+          {
+            continue;
+          }
+          iterator++;
+          std::istringstream sin (*iterator);
+          uint64_t delta;
+          sin >> delta;
+          time = MilliSeconds( time.GetMilliSeconds() + delta);
+          std::cout << "Time Pointer: " << time.GetMilliSeconds() << std::endl;
+          m_chordRun -> m_tokens.clear();
+          continue;
+        }
+        NS_LOG_INFO ("Processing...");
+        m_chordRun->ProcessCommandTokens (m_chordRun -> m_tokens, MilliSeconds(time.GetMilliSeconds()));
+        m_chordRun -> m_tokens.clear();
+      }
+    }
+  }
+
+    Simulator::Schedule (MilliSeconds (200), &ChordRun::ReadCommandTokens, this);
+
+   if (pthread_create (&commandHandlerThreadId, NULL, ChordRun::CommandHandler, &th_argument) != 0)
+   {
+     perror ("New Thread Creation Failed, Exiting...");
+     exit (1);
+   }
+ }
+
+void
+ChordRun::Stop ()
+{
+
+  NS_LOG_FUNCTION_NOARGS();
+  //Cancel keyboard thread
+  pthread_cancel (commandHandlerThreadId);
+  //Join keyboard thread
+  pthread_join (commandHandlerThreadId, NULL);
+}
+
+
+void*
+ChordRun::CommandHandler (void *arg)
+{
+  struct CommandHandlerArgument th_argument = *((struct CommandHandlerArgument *) arg);
+  std::string scriptFile = th_argument.scriptFile;
+  NodeContainer nodeContainer = th_argument.nodeContainer;
+  ChordRun* chordRun = (ChordRun *)th_argument.chordRun;
+
+  chordRun -> m_chordRun = chordRun;
+  chordRun -> m_nodeContainer = nodeContainer;
+  chordRun -> m_scriptFile = scriptFile;
+
+  while (1)
+  {
+    std::string commandLine;
+    //read command from keyboard
+    std::cout << "\nCommand > ";
+    std::getline(std::cin, commandLine, '\n');
+    if (chordRun->m_readyToRead == true)
+    {
+      std::cout << "Simulator busy, please try again..\n";
+      continue;
+    }
+
+    chordRun->Tokenize (commandLine, chordRun -> m_tokens, " ");
+
+    std::vector<std::string>::iterator iterator = chordRun -> m_tokens.begin();
+
+    if (chordRun -> m_tokens.size() == 0)
+    {
+      continue;
+    }
+    //check for quit
+    else if (*iterator == "quit")
+    {
+      break;
+    }
+    chordRun -> m_readyToRead = true;
+
+    //SINGLE THREADED SIMULATOR WILL CRASH, so let simulator schedule processcommandtokens!
+    //chordRun->ProcessCommandTokens (tokens, MilliSeconds (0.));
+
+  }
+  Simulator::Stop ();
+  pthread_exit (NULL);
+}
+
+void
+ChordRun::ReadCommandTokens (void)
+{
+  if (m_readyToRead == true)
+  {
+
+    if (m_tokens.size() > 0)
+    {
+      m_chordRun->ProcessCommandTokens (m_tokens, MilliSeconds (0.0));
+    }
+    m_tokens.clear();
+    m_readyToRead = false;
+  }
+  Simulator::Schedule (MilliSeconds (200), &ChordRun::ReadCommandTokens, this);
+
+}
+
+void
+ChordRun::ProcessCommandTokens (std::vector<std::string> tokens, Time time)
+{
+  NS_LOG_INFO ("Processing Command Token...");
+  //Process tokens
+  std::vector<std::string>::iterator iterator = tokens.begin();
+
+  std::istringstream sin (*iterator);
+  uint16_t nodeNumber;
+  sin >> nodeNumber;
+  //this command can be in script file
+  if (*iterator == "quit")
+  {
+    NS_LOG_INFO ("Scheduling Command quit...");
+    Simulator::Stop (MilliSeconds(time.GetMilliSeconds()));
+    return;
+  }
+  else if (tokens.size() < 2)
+  {
+    return;
+  }
+  Ptr<ChordIpv4> chordApplication = m_nodeContainer.Get(nodeNumber)->GetApplication(0)->GetObject<ChordIpv4> ();
+
+  iterator++;
+  if (*iterator == "InsertVNode")
+  {
+    if (tokens.size() < 3)
+    { 
+      return;
+    }
+    //extract node name
+    iterator++;
+    std::string vNodeName = std::string(*iterator);
+    NS_LOG_INFO ("Scheduling Command InsertVNode...");
+    Simulator::Schedule (MilliSeconds(time.GetMilliSeconds()), &ChordRun::InsertVNode, this, chordApplication, vNodeName);
+    return;
+  }
+  else if (*iterator == "DumpVNodeInfo")
+  {
+    if (tokens.size() < 3)
+    { 
+      return;
+    }
+    //extract node name
+    iterator++;
+    std::string vNodeName = std::string(*iterator);
+    NS_LOG_INFO ("Scheduling Command DumpVNodeInfo...");
+    Simulator::Schedule (MilliSeconds(time.GetMilliSeconds()), &ChordRun::DumpVNodeInfo, this,chordApplication,vNodeName);
+  }
+
+  else if (*iterator == "DumpDHashInfo")
+  {
+    NS_LOG_INFO ("Scheduling Command DumpDHashInfo...");
+    Simulator::Schedule (MilliSeconds(time.GetMilliSeconds()), &ChordRun::DumpDHashInfo, this, chordApplication);
+  }
+
+  else if (*iterator == "TraceRing")
+  {
+    if (tokens.size() < 3)
+    { 
+      return;
+    }
+    //extract node name
+    iterator++;
+    std::string vNodeName = std::string(*iterator);
+    NS_LOG_INFO ("Scheduling Command TraceRing...");
+    Simulator::Schedule (MilliSeconds(time.GetMilliSeconds()), &ChordIpv4::FireTraceRing, chordApplication, vNodeName);
+  }
+  else if (*iterator == "Lookup")
+  {
+    if (tokens.size() < 3)
+    {
+      return;
+    }
+    //extract node resourceName
+    iterator++;
+    std::string resourceName = std::string(*iterator);
+    Simulator::Schedule (MilliSeconds(time.GetMilliSeconds()), &ChordRun::Lookup, this, chordApplication, resourceName);
+    return;
+  }
+  else if (*iterator == "Retrieve")
+  {
+    if (tokens.size() < 3)
+    {
+      return;
+    }
+    iterator++;
+    std::string resourceName = std::string(*iterator);
+    Simulator::Schedule (MilliSeconds(time.GetMilliSeconds()), &ChordRun::Retrieve, this, chordApplication, resourceName);
+  }
+  else if (*iterator == "RemoveVNode")
+  {
+    if (tokens.size() < 3)
+    {
+      return;
+    }
+    //extract node resourceName
+    iterator++;
+    std::string vNodeName = std::string(*iterator);
+    NS_LOG_INFO ("Scheduling Command RemoveVNode...");
+    Simulator::Schedule (MilliSeconds(time.GetMilliSeconds()), &ChordIpv4::RemoveVNode, chordApplication, vNodeName);
+  }
+  else if (*iterator == "Detach")
+  {
+    NS_LOG_INFO ("Scheduling Command Detach...");
+    Simulator::Schedule (MilliSeconds(time.GetMilliSeconds()), &ChordRun::DetachNode, this, nodeNumber);
+  }
+  else if (*iterator == "ReAttach")
+  {
+    NS_LOG_INFO ("Scheduling Command ReAttach...");	
+    Simulator::Schedule (MilliSeconds(time.GetMilliSeconds()), &ChordRun::ReAttachNode, this, nodeNumber);
+  }
+  else if (*iterator == "Crash")
+  {
+    NS_LOG_INFO ("Scheduling Command Crash");
+    Simulator::Schedule (MilliSeconds(time.GetMilliSeconds()), &ChordRun::CrashChord, this, chordApplication);
+  }
+  else if (*iterator == "Restart")
+  {
+    NS_LOG_INFO ("Scheduling Command Restart...");
+    Simulator::Schedule (MilliSeconds(time.GetMilliSeconds()), &ChordRun::RestartChord, this, chordApplication);
+  }
+  else if (*iterator == "FixFinger")
+  {
+    iterator++;
+    std::string vNodeName = std::string (*iterator);
+    NS_LOG_INFO ("Scheduling Command FixFinger...");
+    Simulator::Schedule (MilliSeconds(time.GetMilliSeconds()), &ChordIpv4::FixFingers, chordApplication, vNodeName);
+  }
+  else if (*iterator == "Insert")
+  {
+    if (tokens.size() < 4)
+    {
+      return;
+    }
+    iterator++;
+    std::string resourceName = std::string(*iterator);
+
+    iterator++;
+    std::string resourceValue = std::string (*iterator);
+    NS_LOG_INFO ("Scheduling Command Insert...");
+    Simulator::Schedule (MilliSeconds(time.GetMilliSeconds()), &ChordRun::Insert, this, chordApplication, resourceName, resourceValue);
+  }
+  else
+  {
+    std::cout << "Unrecognized command\n";
+  }
+}
+
+void
+ChordRun::InsertVNode(Ptr<ChordIpv4> chordApplication, std::string vNodeName)
+{
+  NS_LOG_FUNCTION_NOARGS();
+  std::cout << "\nCurrent Simulation Time: " << Simulator::Now ().GetMilliSeconds() << std::endl;
+  unsigned char* md = (unsigned char*) malloc (20);
+  const unsigned char* message = (const unsigned char*) vNodeName.c_str();
+  SHA1 (message , vNodeName.length() , md);
+
+  NS_LOG_INFO ("Scheduling Command InsertVNode...");
+  chordApplication->InsertVNode(vNodeName, md, 20);
+  free (md);
+}
+
+void
+ChordRun::Lookup (Ptr<ChordIpv4> chordApplication, std::string resourceName)
+{
+  NS_LOG_FUNCTION_NOARGS();
+  std::cout << "\nCurrent Simulation Time: " << Simulator::Now ().GetMilliSeconds() << std::endl;
+  unsigned char* md = (unsigned char*) malloc (20);
+  const unsigned char* message = (const unsigned char*) resourceName.c_str();
+  SHA1 (message , resourceName.length() , md);
+  NS_LOG_INFO ("Scheduling Command Lookup...");
+  chordApplication->LookupKey(md, 20);
+  free (md);
+}
+
+void
+ChordRun::Insert (Ptr<ChordIpv4> chordApplication, std::string resourceName, std::string resourceValue)
+{
+  NS_LOG_FUNCTION_NOARGS();
+  std::cout << "\nCurrent Simulation Time: " << Simulator::Now ().GetMilliSeconds() << std::endl;
+  NS_LOG_INFO ("Insert ResourceName : "<< resourceName );
+  NS_LOG_INFO ("Insert Resourcevalue : "<< resourceValue);
+  unsigned char* md = (unsigned char*) malloc (20);
+  const unsigned char* message = (const unsigned char*) resourceName.c_str();
+  SHA1 (message , resourceName.length() , md);
+  unsigned char* value = (unsigned char *)(resourceValue.c_str());
+  chordApplication->Insert(md, 20, value, resourceValue.length());
+  free (md);
+}
+
+void
+ChordRun::Retrieve (Ptr<ChordIpv4> chordApplication, std::string resourceName)
+{
+  NS_LOG_FUNCTION_NOARGS();
+  std::cout << "\nCurrent Simulation Time: " << Simulator::Now ().GetMilliSeconds() << std::endl;
+  unsigned char* md = (unsigned char*) malloc (20);
+  const unsigned char* message = (const unsigned char*) resourceName.c_str();
+  SHA1 (message , resourceName.length() , md);
+  chordApplication->Retrieve (md, 20);
+  free (md);
+}
+
+void
+ChordRun::DetachNode(uint16_t nodeNumber)
+{
+  NS_LOG_FUNCTION_NOARGS();
+  std::cout << "\nCurrent Simulation Time: " << Simulator::Now ().GetMilliSeconds() << std::endl;
+  Ptr<NetDevice> netDevice = m_nodeContainer.Get(nodeNumber)->GetDevice(1);
+  Ptr<CsmaChannel> channel = netDevice->GetChannel()->GetObject<CsmaChannel> ();
+  channel->Detach(nodeNumber);
+}
+
+void
+ChordRun::ReAttachNode(uint16_t nodeNumber)
+{
+  NS_LOG_FUNCTION_NOARGS();
+  std::cout << "\nCurrent Simulation Time: " << Simulator::Now ().GetMilliSeconds() << std::endl;
+  Ptr<NetDevice> netDevice = m_nodeContainer.Get(nodeNumber)->GetDevice(1);
+  Ptr<CsmaChannel> channel = netDevice->GetChannel()->GetObject<CsmaChannel> ();
+  if (channel->Reattach(nodeNumber) == false)
+    std::cout << "Reattach success" << std::endl;
+  else
+    std::cout << "Reattach failed" << std::endl;
+}
+
+void
+ChordRun::CrashChord(Ptr<ChordIpv4> chordApplication)
+{
+  NS_LOG_FUNCTION_NOARGS();
+  std::cout << "\nCurrent Simulation Time: " << Simulator::Now ().GetMilliSeconds() << std::endl;
+  /* This code used to work in ns-3.6 release */
+  //chordApplication -> Stop(Seconds(0.0));
+}
+
+void
+ChordRun::RestartChord(Ptr<ChordIpv4> chordApplication)
+{
+  NS_LOG_FUNCTION_NOARGS();
+  std::cout << "\nCurrent Simulation Time: " << Simulator::Now ().GetMilliSeconds() << std::endl;
+  /* This code used to work in ns-3.6 release */
+  //chordApplication -> Start(Seconds(0.0));
+}
+void
+ChordRun::DumpVNodeInfo(Ptr<ChordIpv4> chordApplication,std::string vNodeName)
+{
+  NS_LOG_FUNCTION_NOARGS();
+  std::cout << "\nCurrent Simulation Time: " << Simulator::Now ().GetMilliSeconds() << std::endl;
+  chordApplication->DumpVNodeInfo (vNodeName, std::cout);
+}
+
+void
+ChordRun::DumpDHashInfo (Ptr<ChordIpv4> chordApplication)
+{
+  NS_LOG_FUNCTION_NOARGS();
+  std::cout << "\nCurrent Simulation Time: " << Simulator::Now ().GetMilliSeconds() << std::endl;
+  chordApplication->DumpDHashInfo (std::cout);
+}
+
+void
+ChordRun::JoinSuccess (std::string vNodeName, uint8_t* key, uint8_t numBytes)
+{
+  NS_LOG_FUNCTION_NOARGS();
+  std::cout << "\nCurrent Simulation Time: " << Simulator::Now ().GetMilliSeconds() << std::endl;
+  std::cout << "VNode: " << vNodeName << " Joined successfully" << std::endl;
+  PrintHexArray (key, numBytes, std::cout);
+}
+
+void
+ChordRun::LookupSuccess (uint8_t* lookupKey, uint8_t lookupKeyBytes, Ipv4Address ipAddress, uint16_t port)
+{
+  NS_LOG_FUNCTION_NOARGS();
+  std::cout << "\nCurrent Simulation Time: " << Simulator::Now ().GetMilliSeconds() << std::endl;
+  std::cout << "Lookup Success Ip: " << ipAddress << " Port: " << port << std::endl;
+  PrintHexArray (lookupKey, lookupKeyBytes, std::cout);
+}
+
+void
+ChordRun::LookupFailure (uint8_t* lookupKey, uint8_t lookupKeyBytes)
+{ 
+  NS_LOG_FUNCTION_NOARGS();
+  std::cout << "\nCurrent Simulation Time: " << Simulator::Now ().GetMilliSeconds() << std::endl;
+  std::cout << "Key Lookup failed" << std::endl;
+  PrintHexArray (lookupKey, lookupKeyBytes, std::cout);
+}
+
+void
+ChordRun::VNodeKeyOwnership (std::string vNodeName, uint8_t* key, uint8_t keyBytes, uint8_t* predecessorKey, uint8_t predecessorKeyBytes, uint8_t* oldPredecessorKey, uint8_t oldPredecessorKeyBytes, Ipv4Address predecessorIp, uint16_t predecessorPort)
+{
+  NS_LOG_FUNCTION_NOARGS();
+  std::cout << "\nCurrent Simulation Time: " << Simulator::Now ().GetMilliSeconds() << std::endl;
+  std::cout << "VNode: " << vNodeName << " Key Space Ownership change reported" << std::endl;
+  std::cout << "New predecessor Ip: " << predecessorIp << " Port: " << predecessorPort << std::endl;
+}
+
+
+void
+ChordRun::VNodeFailure (std::string vNodeName, uint8_t* key, uint8_t numBytes)
+{
+  NS_LOG_FUNCTION_NOARGS();
+  std::cout << "\nCurrent Simulation Time: " << Simulator::Now ().GetMilliSeconds() << std::endl;
+  std::cout << "VNode: " << vNodeName << " Failed" << std::endl;
+}
+
+void
+ChordRun::InsertSuccess (uint8_t* key, uint8_t numBytes, uint8_t* object, uint32_t objectBytes)
+{ 
+  NS_LOG_FUNCTION_NOARGS();
+  std::cout << "\nCurrent Simulation Time: " << Simulator::Now ().GetMilliSeconds() << std::endl;
+  std::cout << "Insert Success!";
+  PrintHexArray (key, numBytes, std::cout);
+  PrintCharArray (object, objectBytes, std::cout);
+}
+
+void
+ChordRun::RetrieveSuccess (uint8_t* key, uint8_t numBytes, uint8_t* object, uint32_t objectBytes)
+{ 
+  NS_LOG_FUNCTION_NOARGS();
+  std::cout << "\nCurrent Simulation Time: " << Simulator::Now ().GetMilliSeconds() << std::endl;
+  std::cout << "Retrieve Success!";
+  PrintHexArray (key, numBytes, std::cout);
+  PrintCharArray (object, objectBytes, std::cout);
+}
+
+void
+ChordRun::InsertFailure (uint8_t* key, uint8_t numBytes, uint8_t* object, uint32_t objectBytes)
+{
+  NS_LOG_FUNCTION_NOARGS();
+  std::cout << "\nCurrent Simulation Time: " << Simulator::Now ().GetMilliSeconds() << std::endl;
+  std::cout << "Insert Failure Reported...";
+  PrintHexArray (key, numBytes, std::cout);
+  PrintCharArray (object, objectBytes, std::cout);
+}
+
+void
+ChordRun::RetrieveFailure (uint8_t* key, uint8_t keyBytes)
+{
+  NS_LOG_FUNCTION_NOARGS();
+  std::cout << "\nCurrent Simulation Time: " << Simulator::Now ().GetMilliSeconds() << std::endl;
+  std::cout << "Retrieve Failure Reported...";
+  PrintHexArray (key, keyBytes, std::cout);
+}
+
+
+void
+ChordRun::TraceRing (std::string vNodeName, uint8_t* key, uint8_t numBytes)
+{
+  std::cout << "<" << vNodeName << ">" << std::endl;
+}
+
+
+void 
+ChordRun::Tokenize(const std::string& str,
+    std::vector<std::string>& tokens,
+    const std::string& delimiters)
+{
+  // Skip delimiters at beginning.
+  std::string::size_type lastPos = str.find_first_not_of(delimiters, 0);
+  // Find first "non-delimiter".
+  std::string::size_type pos = str.find_first_of(delimiters, lastPos);
+
+  while (std::string::npos != pos || std::string::npos != lastPos)
+  {
+    // Found a token, add it to the vector.
+    tokens.push_back(str.substr(lastPos, pos - lastPos));
+    // Skip delimiters.  Note the "not_of"
+    lastPos = str.find_first_not_of(delimiters, pos);
+    // Find next "non-delimiter"
+    pos = str.find_first_of(delimiters, lastPos);
+  }
+}
+
+void
+ChordRun::PrintCharArray (uint8_t* array, uint32_t size, std::ostream &os)
+{
+  os << "Char Array: ";
+  for (uint32_t i = 0; i<size; i++)
+    os << array[i];
+  os << "\n";
+}
+
+void
+ChordRun::PrintHexArray (uint8_t* array, uint32_t size, std::ostream &os)
+{
+  os << "Bytes: " << (uint16_t) size << "\n";
+  os << "Array: \n";
+  os << "[ ";
+  for (uint8_t j=0;j<size;j++)
+  {
+    os << std::hex << "0x" <<(uint16_t) array[j] << " ";
+  }
+  os << std::dec << "]\n";
+}
+
+ int 
+ main (int argc, char *argv[])
+ {
+   uint16_t nodes;
+   uint16_t bootStrapNodeNum;
+   std::string scriptFile = "";
+   if (argc < 3)
+   {
+     std::cout << "Usage: chord-run <nodes> <bootstrapNodeNumber> <OPTIONAL: script-file>. Please input number of nodes to simulate and bootstrap node number\n";
+    exit (1);
+   }
+   else
+   {
+    nodes = atoi(argv[1]);
+    bootStrapNodeNum = atoi(argv[2]);
+    if (argc == 4)
+    {
+      scriptFile = argv[3];
+    }
+    std::cout << "Number of nodes to simulate: " << (uint16_t) nodes << "\n";
+   }
+
+   LogComponentEnable ("ChordRun", LOG_LEVEL_ALL);
+   LogComponentEnable("ChordIpv4Application", LOG_LEVEL_ERROR);
+   //LogComponentEnable("UdpSocketImpl", LOG_LEVEL_ALL);
+   //LogComponentEnable("Packet", LOG_LEVEL_ALL);
+   //LogComponentEnable("Socket", LOG_LEVEL_ALL);
+   //LogComponentEnable("ChordMessage", LOG_LEVEL_ALL);
+   LogComponentEnable("ChordIdentifier", LOG_LEVEL_ERROR);
+   LogComponentEnable("ChordTransaction", LOG_LEVEL_ERROR);
+   LogComponentEnable("ChordVNode", LOG_LEVEL_ERROR);
+   LogComponentEnable("ChordNodeTable", LOG_LEVEL_ERROR);
+   LogComponentEnable("DHashIpv4", LOG_LEVEL_ERROR);
+   LogComponentEnable("DHashConnection", LOG_LEVEL_ERROR);
+   //LogComponentEnable("TcpSocketImpl", LOG_LEVEL_ALL);
+   //LogComponentEnable("TcpL4Protocol", LOG_LEVEL_ALL);
+
+   //
+   // Allow the user to override any of the defaults and the above Bind() at
+   // run-time, via command-line arguments
+   //
+   CommandLine cmd;
+   cmd.Parse (argc, argv);
+   //
+   // Explicitly create the nodes required by the topology (shown above).
+   //
+
+   NS_LOG_INFO ("Creating nodes.");
+   NodeContainer nodeContainer;
+   nodeContainer.Create (nodes);
+
+   InternetStackHelper internet;
+   internet.Install (nodeContainer);
+
+   NS_LOG_INFO ("Create channels.");
+   //
+   // Explicitly create the channels required by the topology (shown above).
+   //
+   CsmaHelper csma;
+   csma.SetChannelAttribute ("DataRate", StringValue ("100Mbps"));
+   csma.SetChannelAttribute ("Delay", TimeValue (NanoSeconds (6560)));
+   csma.SetDeviceAttribute ("Mtu", UintegerValue (1400));
+   NetDeviceContainer d = csma.Install (nodeContainer);
+
+   Ipv4AddressHelper ipv4;
+   //
+   // We've got the "hardware" in place.  Now we need to add IP addresses.
+   //
+   NS_LOG_INFO ("Assign IP Addresses.");
+   ipv4.SetBase ("10.1.1.0", "255.255.255.0");
+   Ipv4InterfaceContainer i = ipv4.Assign (d);
+
+   NS_LOG_INFO ("Create Applications.");
+   //
+   //Create a command handler thread
+   //
+   ChordRun chordRun;
+   //
+   // Create a ChordIpv4 application on all nodes. Insertion of vnodes controlled by user via keyboard.
+   //
+
+   uint16_t port = 2000;
+   for (int j=0; j<nodes; j++)
+   {
+     ChordIpv4Helper server (i.GetAddress(bootStrapNodeNum), port, i.GetAddress(j), port, port+1, port+2);
+     ApplicationContainer apps = server.Install (nodeContainer.Get(j));
+     apps.Start(Seconds (0.0));
+     Ptr<ChordIpv4> chordApplication = nodeContainer.Get(j)->GetApplication(0)->GetObject<ChordIpv4> ();
+     chordApplication->SetJoinSuccessCallback (MakeCallback(&ChordRun::JoinSuccess, &chordRun));
+     chordApplication->SetLookupSuccessCallback (MakeCallback(&ChordRun::LookupSuccess, &chordRun));
+     chordApplication->SetLookupFailureCallback (MakeCallback(&ChordRun::LookupFailure, &chordRun));
+     chordApplication->SetTraceRingCallback (MakeCallback(&ChordRun::TraceRing, &chordRun));
+     chordApplication->SetVNodeFailureCallback(MakeCallback(&ChordRun::VNodeFailure, &chordRun));
+     chordApplication->SetVNodeKeyOwnershipCallback(MakeCallback(&ChordRun::VNodeKeyOwnership, &chordRun));
+     //DHash configuration:: Needs to be done once but can be overwritten...
+     chordApplication->SetInsertSuccessCallback (MakeCallback(&ChordRun::InsertSuccess, &chordRun));
+     chordApplication->SetRetrieveSuccessCallback (MakeCallback(&ChordRun::RetrieveSuccess, &chordRun));
+     chordApplication->SetInsertFailureCallback (MakeCallback(&ChordRun::InsertFailure, &chordRun));
+     chordApplication->SetRetrieveFailureCallback (MakeCallback(&ChordRun::RetrieveFailure, &chordRun));
+   }
+
+   //Start Chord-Run 
+   chordRun.Start(scriptFile,nodeContainer);
+   //
+   // Now, do the actual simulation.
+   //
+   NS_LOG_INFO ("Run Simulation.");
+   Simulator::Run ();
+   chordRun.Stop ();
+   Simulator::Destroy ();
+   NS_LOG_INFO ("Done.");
+   return 0;
+
+ }
+
+
+
Index: examples/chord-run/chord-test-script
===================================================================
new file mode 100644
--- /dev/null
+++ b/examples/chord-run/chord-test-script
@@ -0,0 +1,111 @@
+Time 60000
+1 InsertVNode N1V1
+2 InsertVNode N2V1
+Time 60000
+2 TraceRing N2V1
+Time 60000
+3 InsertVNode N3V1
+Time 60000
+5 InsertVNode N5V1
+Time 60000
+4 InsertVNode N4V1
+Time 60000
+6 InsertVNode N6V1
+Time 60000
+7 InsertVNode N7V1
+Time 60000
+8 InsertVNode N8V1
+Time 60000
+8 TraceRing N8V1
+Time 60000
+9 InsertVNode N9V1
+Time 60000
+10 InsertVNode N10V1
+Time 60000
+11 InsertVNode N11V1
+Time 60000
+11 TraceRing N11V1
+Time 60000
+12 InsertVNode N12V1
+Time 60000
+13 InsertVNode N13V1
+Time 60000
+14 InsertVNode N14V1
+Time 60000
+15 InsertVNode N15V1
+Time 60000
+16 InsertVNode N16V1
+Time 60000
+17 InsertVNode N17V1
+Time 60000
+18 InsertVNode N18V1
+Time 60000
+19 InsertVNode N19V1
+Time 60000
+19 TraceRing N19V1
+Time 60000
+
+echo-----------Inject_Data---------------
+1 Insert Boston Celtics
+5 Insert NewJersey Nets
+9 Insert NewYork Knicks
+13 Insert Philadelphia 76ers
+17 Insert Toronto Raptors
+2 Insert Chicago Bulls
+6 Insert Cleveland Cavaliers
+10 Insert Detroit Pistons
+14 Insert Indiana Pacers
+18 Insert Milwaukee Bucks
+3 Insert Atlanta Hawks
+7 Insert Charlotte Bobcats
+11 Insert Miami Heat
+15 Insert Orlando Magic
+19 Insert Washington Wizards
+4 Insert Dallas Mavericks
+8 Insert Houston Rockets
+12 Insert Memphis Grizzlies
+16 Insert NewOrleans Hornets
+19 Insert SanAntonio Spurs
+1 Insert GoldenState Warriors
+2 Insert LosAngeles Clippers
+3 Insert LosAngeles Lakers
+4 Insert Phoenix Suns
+5 Insert Sacramento Kings
+6 Insert Denver Nuggets
+7 Insert Minnesota Timberwolves
+8 Insert Portland TrailBlazers
+9 Insert OklahomaCity Thunder
+10 Insert Utah Jazz
+
+
+echo-----------Lookup------------
+Time 60000
+1 Lookup LosAngeles
+Time 30000
+5 Lookup LosAngeles
+Time 30000
+8 Lookup Philadelphia
+Time 30000
+
+echo--------------Retrieve_Data-------------
+1 Retrieve LosAngeles
+Time 10000
+5 Retrieve LosAngeles
+Time 10000
+9 Retrieve LosAngeles
+Time 10000
+13 Retrieve LosAngeles
+Time 10000
+17 Retrieve LosAngeles
+Time 10000
+8 Retrieve Philadelphia
+Time 10000
+9 Retrieve Boston
+Time 10000
+10 Retrieve Dallas
+Time 10000
+11 Retrieve Houston
+Time 10000
+12 Retrieve Portland
+Time 30000
+
Index: examples/chord-run/waf
===================================================================
new file mode 100755
--- /dev/null
+++ b/examples/chord-run/waf
@@ -0,0 +1,1 @@
+exec "`dirname "$0"`"/../../waf "$@"
Index: examples/chord-run/wscript
===================================================================
new file mode 100644
--- /dev/null
+++ b/examples/chord-run/wscript
@@ -0,0 +1,6 @@
+## -*- Mode: python; py-indent-offset: 4; indent-tabs-mode: nil; coding: utf-8; -*-
+
+def build(bld):
+    obj = bld.create_ns3_program('chord-run', ['chord-ipv4'])
+    obj.source = 'chord-run.cc'
+    obj.env.append_value('LINKFLAGS','-lcrypto')
Index: src/applications/chord-ipv4/AUTHORS
===================================================================
new file mode 100644
--- /dev/null
+++ b/src/applications/chord-ipv4/AUTHORS
@@ -0,0 +1,9 @@
+This project was undertaken as part of Networked Systems course at University Of Pennsylvania, Philadelphia.
+Course Website: http://www.cis.upenn.edu/~cis553
+
+Authors:
+Harjot Gill (gillh@seas.upenn.edu)
+Taher Saaed (taher@seas.upenn.edu)
+Karthik Kadambi Seshachari (karthikk@seas.upenn.edu)
+Oscar Nunez (oscf@seas.upenn.edu)
+Vishal Patil (patilv@seas.upenn.edu)
Index: src/applications/chord-ipv4/chord-identifier.cc
===================================================================
new file mode 100644
--- /dev/null
+++ b/src/applications/chord-ipv4/chord-identifier.cc
@@ -0,0 +1,351 @@
+/* -*-  Mode: C++; c-file-style: "gnu"; indent-tabs-mode:nil; -*- */
+/*
+ * Copyright (c) 2009 University of Pennsylvania
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation;
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#include "chord-identifier.h"
+#include "ns3/abort.h"
+#include "ns3/log.h"
+#include <stdlib.h>
+
+NS_LOG_COMPONENT_DEFINE ("ChordIdentifier");
+
+namespace ns3 {
+
+ChordIdentifier::ChordIdentifier ()
+{
+  m_key = 0;
+  m_numBytes = 0;
+}
+
+ChordIdentifier::ChordIdentifier (uint8_t* key, uint8_t numBytes)
+{
+  NS_LOG_FUNCTION_NOARGS();
+  //Allocate memory to store key
+  m_key = (uint8_t *) malloc(numBytes * sizeof (uint8_t));
+  NS_ABORT_MSG_IF (m_key == 0,"ChordIdentifier::ChordIdentifier() malloc failed");
+  //Copy entire key to this area
+  for (int i=0; i<numBytes; i++)
+  {
+    m_key[i] = key[i];
+  }
+  //Save numBytes
+  m_numBytes = numBytes;
+}
+
+ChordIdentifier::ChordIdentifier(Ptr<ChordIdentifier> identifier)
+{
+  NS_LOG_FUNCTION_NOARGS();
+  CopyIdentifier(identifier);
+}
+
+
+ChordIdentifier::ChordIdentifier(const ChordIdentifier& identifier)
+{
+  NS_LOG_FUNCTION_NOARGS();
+  Ptr<ChordIdentifier> chordIdentifier = const_cast<ChordIdentifier *>(&identifier);
+  CopyIdentifier (chordIdentifier);
+}
+
+ChordIdentifier::~ChordIdentifier ()
+{
+  NS_LOG_FUNCTION_NOARGS();
+  //Free memory
+  if (m_key != 0)
+  {
+    free (m_key);
+    m_numBytes= 0;
+    m_key = 0;
+  }
+}
+
+void
+ChordIdentifier::DoDispose (void)
+{
+  NS_LOG_FUNCTION_NOARGS();
+  //Free memory
+  if (m_key != 0)
+  {
+    free (m_key);
+    m_numBytes= 0;
+    m_key = 0;
+  }
+}
+
+void
+ChordIdentifier::CopyIdentifier(Ptr<ChordIdentifier> identifier)
+{
+  NS_LOG_FUNCTION_NOARGS();
+  uint8_t *key = identifier->GetKey();
+  m_numBytes = identifier->GetNumBytes();
+
+  //Allocate memory to store key
+  m_key = (uint8_t *) malloc(m_numBytes * sizeof (uint8_t));
+  NS_ABORT_MSG_IF (m_key == 0,"ChordIdentifier::ChordIdentifier() malloc failed");
+  //Copy entire key to this area
+  for (int i=0; i<m_numBytes; i++)
+  {
+    m_key[i] = key[i];
+  }
+}
+
+bool
+ChordIdentifier::IsEqual (Ptr<ChordIdentifier> identifier)
+{
+  NS_LOG_FUNCTION_NOARGS();
+  //Retrieve key
+  uint8_t* key= identifier->GetKey();
+  //Check for contents
+  for (int i= 0; i<m_numBytes; i++)
+  {
+    if (key[i] != m_key[i])
+      return false;
+  }
+  //Keys are equal, return true
+  return true;
+}
+
+bool
+ChordIdentifier::IsLess (Ptr<ChordIdentifier> identifier)
+{
+  NS_LOG_FUNCTION_NOARGS();
+  //Retrieve key
+  uint8_t* key= identifier->GetKey();
+  //Compare two keys byte by byte
+  for (int i= m_numBytes-1; i>=0; i--)
+  {
+    if (m_key[i] < key[i])
+      return true;
+    else if (m_key[i] > key[i])
+      return false;
+  }
+  //Keys are equal, return false
+  return false;
+}
+
+bool
+ChordIdentifier::IsGreater (Ptr<ChordIdentifier> identifier)
+{
+  NS_LOG_FUNCTION_NOARGS();
+  //Retrieve key
+  uint8_t* key= identifier->GetKey();
+  //Compare two keys byte by byte
+  for (int i= m_numBytes-1; i>=0; i--)
+  {
+    if (m_key[i] > key[i])
+      return true;
+    else if (m_key[i] < key[i])
+      return false;
+  }
+  //Keys are equal, return false
+  return false;
+}
+
+bool
+ChordIdentifier::IsInBetween (Ptr<ChordIdentifier> identifierLow, Ptr<ChordIdentifier> identifierHigh)
+{
+  NS_LOG_FUNCTION_NOARGS();
+  //Check for existence in between range (keyLow,keyHigh], taken on circular identifier space, in clockwise direction
+
+  //Check for wrap-around
+  if (identifierHigh->IsGreater(identifierLow))
+  {
+    //No wrap-around
+    if (!IsGreater(identifierLow))
+      return false;
+
+    if (IsLess(identifierHigh) || IsEqual(identifierHigh))
+      return true;
+    else 
+      return false;
+  }
+  else if (identifierHigh->IsLess(identifierLow))
+  {
+    //Wrap-around is there
+    //Either key lies on left of 0 or on right. So check for both scenarios
+    if (IsGreater(identifierHigh) || IsEqual(identifierHigh))
+    {
+      //Key lies on left of 0?
+      if (IsGreater(identifierLow))
+        return true;
+      else 
+        return false;
+    }
+    //Check if key lies on right of 0 and in between
+    if (IsLess(identifierHigh) || IsEqual(identifierHigh))
+    {
+      //Key lies on right of 0?
+      if (IsLess(identifierLow))
+        return true;
+      else 
+        return false;
+    }
+  }
+  else if (identifierHigh->IsEqual(identifierLow))
+  {
+    //Everything is in between! (except keyHigh)
+    if (!IsEqual(identifierHigh))
+      return true;
+    return false;
+  }
+  NS_LOG_ERROR ("Something is seriously is wrong..");
+  //Something is seriously wrong, cannot be here
+  return false;
+}
+
+void
+ChordIdentifier::AddPowerOfTwo (uint16_t powerOfTwo)
+{
+  uint8_t powZero = 0x01;
+  //Find byte position
+  uint8_t position = powerOfTwo / 8;
+  NS_ASSERT (position < m_numBytes);
+  uint8_t shift = powerOfTwo % 8;
+  //Add power
+  uint8_t prevVal = m_key[position];
+  m_key[position] = m_key[position] + (powZero << shift);
+  //if carry is there
+  while ((m_key[position] < prevVal) && (position <= (m_numBytes-1)))
+  {
+    position++;
+    prevVal = m_key[position]; 
+    m_key[position] = m_key[position] + 0x01;
+  }
+}
+
+uint8_t* 
+ChordIdentifier::GetKey (void)
+{
+  NS_LOG_FUNCTION_NOARGS();
+  return m_key;
+}
+
+uint8_t
+ChordIdentifier::GetNumBytes()
+{
+  NS_LOG_FUNCTION_NOARGS();
+  return m_numBytes;
+}
+
+void 
+ChordIdentifier::SetKey(uint8_t* key, uint8_t numBytes)
+{
+  NS_LOG_FUNCTION_NOARGS();
+
+  if (m_key != 0)
+  {
+    //Free previously stored key
+    free (m_key);
+    m_key = 0;
+  }
+  //Allocate memory to store key
+  m_key = (uint8_t *) malloc(numBytes * sizeof (uint8_t));
+  NS_ABORT_MSG_IF (m_key == 0,"ChordIdentifier::ChordIdentifier() malloc failed");
+  //Copy entire key to this area
+  for (int i=0; i<numBytes; i++)
+  {
+    m_key[i] = key[i];
+  }
+  //Save numBytes
+  m_numBytes = numBytes;
+}
+
+void
+ChordIdentifier::Serialize (Buffer::Iterator &start)
+{
+  NS_LOG_FUNCTION_NOARGS();
+  start.WriteU8 (m_numBytes);
+  uint8_t j;
+  for (j=0 ; j<m_numBytes; j++)
+  {
+    start.WriteU8 (m_key[j]);
+  }
+}
+
+uint32_t 
+ChordIdentifier::Deserialize (Buffer::Iterator &start)
+{
+  NS_LOG_FUNCTION_NOARGS();
+  uint8_t j;
+
+  m_numBytes = start.ReadU8 ();
+  //Allocate memory
+  if (m_key == 0)
+  {
+    m_key = (uint8_t *) malloc(m_numBytes * sizeof (uint8_t));
+    NS_ABORT_MSG_IF (m_key == 0,"ChordIdentifier::ChordIdentifier() malloc failed");
+  }
+  else
+  {
+    //return 0;
+  }
+  /* Retrieve key from buffer */
+  for (j=0; j<m_numBytes;j++)
+  {
+    m_key[j] = start.ReadU8 ();
+  }  
+
+  return GetSerializedSize ();
+}
+
+uint32_t
+ChordIdentifier::GetSerializedSize ()
+{
+  uint32_t size;
+  size = GetNumBytes() + sizeof (uint8_t);
+  return size;
+
+}
+
+void 
+ChordIdentifier::Print (std::ostream &os) 
+{
+  os << "Bytes: " << (uint16_t) m_numBytes << "\n";
+  os << "Key: \n";
+  os << "[ ";
+  for (uint8_t j=0;j<m_numBytes;j++)
+  {
+    os << std::hex << "0x" <<(uint16_t) m_key[j] << " ";
+  }
+  os << std::dec << "]\n";
+}
+
+std::ostream& operator<< (std::ostream& os, Ptr<ChordIdentifier> const &identifier)
+{
+  identifier->Print(os);
+  return os;
+}
+
+bool operator== (ChordIdentifier &chordIdentifierL, ChordIdentifier &chordIdentifierR)
+{
+  Ptr<ChordIdentifier> identifierL = const_cast<ChordIdentifier *> (&chordIdentifierL);
+  Ptr<ChordIdentifier> identifierR = const_cast<ChordIdentifier *> (&chordIdentifierR);
+  if (identifierL->IsEqual(identifierR))
+    return true;
+  else
+    return false;
+}
+bool operator < (const ChordIdentifier &chordIdentifierL, const ChordIdentifier &chordIdentifierR)
+{
+  Ptr<ChordIdentifier> identifierL = const_cast<ChordIdentifier *> (&chordIdentifierL);
+  Ptr<ChordIdentifier> identifierR = const_cast<ChordIdentifier *> (&chordIdentifierR);
+  if (identifierL->IsLess(identifierR))
+    return true;
+  else
+    return false;
+}
+
+} //namespace ns3
Index: src/applications/chord-ipv4/chord-identifier.h
===================================================================
new file mode 100644
--- /dev/null
+++ b/src/applications/chord-ipv4/chord-identifier.h
@@ -0,0 +1,163 @@
+/* -*-  Mode: C++; c-file-style: "gnu"; indent-tabs-mode:nil; -*- */
+/*
+ * Copyright (c) 2009 University of Pennsylvania
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation;
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+#ifndef CHORD_IDENTIFIER_H
+#define CHORD_IDENTIFIER_H
+
+#include <stdint.h>
+#include <ostream>
+#include "ns3/ptr.h"
+#include "ns3/object.h"
+#include "ns3/buffer.h"
+
+namespace ns3 {
+/**
+ *  \ingroup chordipv4
+ *  \class ChordIdentifier
+ *  \brief Class to store and operate on keys. 
+ *  We assume keys are in little-endian format 
+ */
+class ChordIdentifier : public Object
+{
+
+  public:
+  /**
+   *  \brief Constructor 
+   */
+  ChordIdentifier ();
+  /**
+   *  \brief Constructor to store key
+   *  \param Pointer to key array(identifier)
+   *  \param numBytes Number of bytes in key
+   */
+  ChordIdentifier (uint8_t* key, uint8_t numBytes);
+  /**
+   *  \brief Copy Constructor
+   *  \param identifier Ptr of ChordIdentifier to copy from
+   */
+  ChordIdentifier (Ptr<ChordIdentifier> identifier);
+  /**
+   *  \brief Copy Constructor
+   *  \param identifier ChordIdentifier to copy from
+   */
+  ChordIdentifier (const ChordIdentifier& identifier);
+  virtual ~ChordIdentifier ();
+  virtual void DoDispose (void);
+
+  /**
+   *  \brief Tests ChordIndentifier for equality 
+   *  \param identifier Ptr of ChordIdentifier to compare with
+   *  \returns true if identifiers are equal, otherwise returns false
+   */
+  bool IsEqual (Ptr<ChordIdentifier> identifier); 
+  /**
+   *  \brief Tests if the ChordIdentifier is less than given ChordIdentifier
+   *  \param identifier Ptr of ChordIdentifier to compare with
+   *  \returns true if identifier is less than given value, otherwise returns false
+   */
+  bool IsLess (Ptr<ChordIdentifier> identifier);
+  /**
+   *  \brief Tests if the ChordIdentifier is greater than given ChordIdentifier
+   *  \param identifier Ptr of ChordIdentifier to compare with
+   *  \returns true if identifier is greater than given value, otherwise returns false
+   */
+  bool IsGreater (Ptr<ChordIdentifier> identifier);
+  /**
+   *  \brief Tests if the ChordIdentifier lies in between interval (identifierLow,identifierHigh] taken on a circular space.
+   *  \param identifierLow Ptr of low ChordIdentifier 
+   *  \param identifierHigh Ptr of high ChordIdentifier
+   *  \returns true if identifier lies in given range, otherwise returns false 
+   */
+  bool IsInBetween (Ptr<ChordIdentifier> identifierLow, Ptr<ChordIdentifier> identifierHigh);
+  /**
+   *  \brief Adds power of two to identifier (identifier + 2^(powerOfTwo))
+   *  \param powerOfTwo Power of two to add
+   */
+  void AddPowerOfTwo (uint16_t powerOfTwo);
+  /**
+   *  \returns Pointer to stored key array
+   */
+  uint8_t* GetKey (void);  
+  /**
+   *  \returns number of bytes in key array
+   */
+  uint8_t GetNumBytes (void);
+  //Assignment
+
+  /**
+   *  \brief Stores key (identifier)
+   *  \param key Pointer to key array (identifier)
+   *  \param numBytes Number of bytes in key array
+   */
+  void SetKey (uint8_t* key, uint8_t numBytes);
+  //Serialization
+  /**
+   *  \brief Serializes ChordIdentifier
+   *  
+   *  Packed Structure:
+   *  \verbatim
+      0 1 2 3 4 5 6 7 8 
+      +-+-+-+-+-+-+-+-+
+      |    numBytes   |
+      +-+-+-+-+-+-+-+-+
+      |               |
+      :   key Array   :
+      |               |
+      +-+-+-+-+-+-+-+-+
+      \endverbatim
+   */
+  void Serialize (Buffer::Iterator &start);
+  /**
+   *  \brief Deserializes packed ChordIdentifier
+   *  \param start Buffer::Iterator of packed structure
+   */
+  uint32_t Deserialize (Buffer::Iterator &start);
+  /**
+   *  \returns Size of packed structure
+   */
+  uint32_t GetSerializedSize ();
+  /**
+   *  \brief Prints ChordIdentifier
+   *  \param os Output Stream
+   */
+  void Print (std::ostream &os); 
+
+  private:
+  /**
+   *  \cond
+   */
+  void CopyIdentifier(Ptr<ChordIdentifier> identifier);
+
+  uint8_t *m_key;
+  uint8_t m_numBytes;
+  /**
+   *  \endcond
+   */
+  //Operators
+  friend bool operator < (const ChordIdentifier &identifierL, const ChordIdentifier &identifierR);
+  friend bool operator == (const ChordIdentifier &identifierL, const ChordIdentifier identifierR);
+
+}; //class ChordIdentifier
+
+std::ostream& operator<< (std::ostream& os, Ptr<ChordIdentifier> const &identifier);
+bool operator < (const ChordIdentifier &identifierL, const ChordIdentifier &identifierR);
+bool operator == (const ChordIdentifier &identifierL, const ChordIdentifier identifierR);
+
+
+} //namespace ns3
+
+#endif //CHORD_IDENTIFIER_H
Index: src/applications/chord-ipv4/chord-ipv4.cc
===================================================================
new file mode 100644
--- /dev/null
+++ b/src/applications/chord-ipv4/chord-ipv4.cc
@@ -0,0 +1,1588 @@
+/* -*-  Mode: C++; c-file-style: "gnu"; indent-tabs-mode:nil; -*- */
+/*
+ * Copyright (c) 2009 University of Pennsylvania
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation;
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#include "stdint.h"
+#include "stdlib.h"
+#include "ns3/log.h"
+#include "ns3/ipv4-address.h"
+#include "ns3/nstime.h"
+#include "ns3/inet-socket-address.h"
+#include "ns3/address-utils.h"
+#include "ns3/socket.h"
+#include "ns3/simulator.h"
+#include "ns3/socket-factory.h"
+#include "ns3/packet.h"
+#include "ns3/uinteger.h"
+#include "ns3/boolean.h"
+#include "ns3/trace-source-accessor.h"
+#include "ns3/callback.h"
+#include "ns3/random-variable.h"
+#include "ns3/object-factory.h"
+#include "chord-ipv4.h"
+
+
+namespace ns3 {
+
+NS_LOG_COMPONENT_DEFINE ("ChordIpv4Application");
+NS_OBJECT_ENSURE_REGISTERED (ChordIpv4);
+
+TypeId
+ChordIpv4::GetTypeId (void)
+{
+  static TypeId tid = TypeId ("ns3::ChordIpv4")
+    .SetParent<Application> ()
+    .AddConstructor<ChordIpv4> ()
+    .AddAttribute ("BootStrapIp",
+                   "IP address of a \"well-known\" chord node (mandatory)",
+                   Ipv4AddressValue (),
+                   MakeIpv4AddressAccessor (&ChordIpv4::m_bootStrapIp),
+                   MakeIpv4AddressChecker ())
+    .AddAttribute ("BootStrapPort",
+                   "Chord protocol port of bootStrapNode (mandatory)",
+                   UintegerValue (0),
+                   MakeUintegerAccessor (&ChordIpv4::m_bootStrapPort),
+                   MakeUintegerChecker<uint16_t> ())
+    .AddAttribute ("LocalIpAddress",
+                   "Local IP address (mandatory)",
+                   Ipv4AddressValue (),
+                   MakeIpv4AddressAccessor (&ChordIpv4::m_localIpAddress),
+                   MakeIpv4AddressChecker ())
+    .AddAttribute ("ListeningPort",
+                   "Chord Protocol port (mandatory)",
+                   UintegerValue (0),
+                   MakeUintegerAccessor (&ChordIpv4::m_listeningPort),
+                   MakeUintegerChecker<uint16_t> ())
+    .AddAttribute ("ApplicationPort",
+                   "Port to be sent in response to Lookup requests (mandatory)",
+                   UintegerValue (0),
+                   MakeUintegerAccessor (&ChordIpv4::m_applicationPort),
+                   MakeUintegerChecker<uint16_t> ())
+    .AddAttribute ("DHashEnable",
+                   "DHash layer enable flag",
+                   BooleanValue (false),
+                   MakeBooleanAccessor (&ChordIpv4::m_dHashEnable),
+                   MakeBooleanChecker ())
+    .AddAttribute ("DHashPort",
+                   "Listening Port to be used with DHash layer (mandatory)",
+                   UintegerValue (0),
+                   MakeUintegerAccessor (&ChordIpv4::m_dHashPort),
+                   MakeUintegerChecker<uint16_t> ())
+    .AddAttribute ("MaxVNodeSuccessorListSize",
+                   "Max Size of successor list to maintain in a VNode",
+                   UintegerValue (DEFAULT_MAX_VNODE_SUCCESSOR_LIST_SIZE),
+                   MakeUintegerAccessor (&ChordIpv4::m_maxVNodeSuccessorListSize),
+                   MakeUintegerChecker<uint8_t> ())
+    .AddAttribute ("MaxVNodePredecessorListSize",
+                   "Max Size of predessor list to maintain in a VNode",
+                   UintegerValue (DEFAULT_MAX_VNODE_PREDECESSOR_LIST_SIZE),
+                   MakeUintegerAccessor (&ChordIpv4::m_maxVNodePredecessorListSize),
+                   MakeUintegerChecker<uint8_t> ())
+    .AddAttribute ("StabilizeInterval",
+                   "Stabilize Interval in milli seconds",
+                   TimeValue (MilliSeconds (DEFAULT_STABILIZE_INTERVAL)),
+                   MakeTimeAccessor (&ChordIpv4::m_stabilizeInterval),
+                   MakeTimeChecker ())
+    .AddAttribute ("HeartbeatInterval",
+                   "Heartbeat Interval in milli seconds",
+                   TimeValue (MilliSeconds (DEFAULT_HEARTBEAT_INTERVAL)),
+                   MakeTimeAccessor (&ChordIpv4::m_heartbeatInterval),
+                   MakeTimeChecker ())
+    .AddAttribute ("MaxMissedKeepAlives",
+                   "Number of missed Heartbeats and Stabilize requests before declaring node dead",
+                   UintegerValue (DEFAULT_MAX_MISSED_KEEP_ALIVES),
+                   MakeUintegerAccessor (&ChordIpv4::m_maxMissedKeepAlives),
+                   MakeUintegerChecker<uint16_t> ())
+    .AddAttribute ("MaxRequestRetries",
+                   "Number of request retries before giving up",
+                   UintegerValue (DEFAULT_MAX_REQUEST_RETRIES),
+                   MakeUintegerAccessor (&ChordIpv4::m_maxRequestRetries),
+                   MakeUintegerChecker<uint8_t> ())
+    .AddAttribute ("RequestTimeout",
+                   "Timeout value for request retransmission in milli seconds",
+                   TimeValue (MilliSeconds (DEFAULT_REQUEST_TIMEOUT)),
+                   MakeTimeAccessor (&ChordIpv4::m_requestTimeout),
+                   MakeTimeChecker ())
+    .AddAttribute ("DHashInactivityTimeout",
+                   "Timeout value for closing inactive TCP connection in milli seconds",
+                   TimeValue (MilliSeconds (DEFAULT_CONNECTION_INACTIVITY_TIMEOUT)),
+                   MakeTimeAccessor (&ChordIpv4::m_dHashInactivityTimeout),
+                   MakeTimeChecker ())
+    .AddAttribute ("DHashAuditObjectsTimeout",
+                   "Timeout value for auditing stored DHash Objects in milli seconds",
+                   TimeValue (MilliSeconds (DEFAULT_AUDIT_OBJECTS_TIMEOUT)),
+                   MakeTimeAccessor (&ChordIpv4::m_dHashAuditObjectsTimeout),
+                   MakeTimeChecker ())
+    .AddAttribute ("FixFingerInterval",
+                   "Fix Finger Interval in milli seconds",
+                   TimeValue (MilliSeconds (DEFAULT_FIX_FINGER_INTERVAL)),
+                   MakeTimeAccessor (&ChordIpv4::m_fixFingerInterval),
+                   MakeTimeChecker ())
+
+     ;
+  return tid;
+}
+
+//Constructor for ChordIpv4 application
+ChordIpv4::ChordIpv4 ()
+  :m_stabilizeTimer (Timer::CANCEL_ON_DESTROY),
+  m_heartbeatTimer (Timer::CANCEL_ON_DESTROY),
+  m_fixFingerTimer (Timer::CANCEL_ON_DESTROY)
+{
+  NS_LOG_FUNCTION_NOARGS ();
+  m_socket = 0;
+  isBootStrapNode = false;
+  //Timer configuration
+}
+
+ChordIpv4::~ChordIpv4 ()
+{
+  NS_LOG_FUNCTION_NOARGS ();
+  m_socket = 0;
+}
+
+void
+ChordIpv4::DoDispose (void)
+{
+  NS_LOG_FUNCTION_NOARGS ();
+  StopApplication();
+  Application::DoDispose ();
+}
+
+void
+ChordIpv4::StartApplication (void)
+{
+  NS_LOG_FUNCTION_NOARGS ();
+  NS_LOG_INFO("***ChordIpv4 starting on Node: " << GetNode()->GetId() 
+              <<"\n***Parameters: "
+              <<"\n***bootStrapIp: " << m_bootStrapIp
+              <<"\n***bootStrapPort: " << m_bootStrapPort
+              <<"\n***listeningPort: " << m_listeningPort
+              <<"\n***localIp: " << m_localIpAddress
+              );
+  if (m_bootStrapIp == m_localIpAddress  && m_bootStrapPort == m_listeningPort)
+  {
+    isBootStrapNode = true; 
+  }
+
+  if (m_socket == 0)
+  {
+    TypeId tid = TypeId::LookupByName ("ns3::UdpSocketFactory");
+    m_socket = Socket::CreateSocket (GetNode(), tid);
+    InetSocketAddress local = InetSocketAddress (m_localIpAddress, m_listeningPort);
+    m_socket->Bind (local);
+    m_socket->SetRecvCallback(MakeCallback(&ChordIpv4::ProcessUdpPacket, this));
+  }
+  else
+  {
+    m_socket->SetRecvCallback(MakeCallback(&ChordIpv4::ProcessUdpPacket, this));
+  }
+
+  //Start DHash layer
+  if (m_dHashEnable == true)
+  {
+    //Create layer
+    ObjectFactory factory;
+    factory.SetTypeId (DHashIpv4::GetTypeId());
+    factory.Set ("LocalIpAddress", Ipv4AddressValue(m_localIpAddress));
+    factory.Set ("ListeningPort", UintegerValue(m_dHashPort));
+    factory.Set ("ConnectionInactivityTimeout", TimeValue(m_dHashInactivityTimeout));
+    factory.Set ("AuditObjectsTimeout", TimeValue(m_dHashAuditObjectsTimeout));
+    m_dHashIpv4 = factory.Create<DHashIpv4> ();
+    m_dHashIpv4->SetInsertSuccessCallback (MakeCallback(&ChordIpv4::NotifyInsertSuccess, this));
+    m_dHashIpv4->SetRetrieveSuccessCallback (MakeCallback(&ChordIpv4::NotifyRetrieveSuccess, this));
+    m_dHashIpv4->SetInsertFailureCallback (MakeCallback(&ChordIpv4::NotifyInsertFailure, this));
+    m_dHashIpv4->SetRetrieveFailureCallback (MakeCallback(&ChordIpv4::NotifyRetrieveFailure, this));
+    //Start layer
+    m_dHashIpv4->Start (this);
+  }
+
+  //Configure timer
+  m_stabilizeTimer.SetFunction(&ChordIpv4::DoPeriodicStabilize, this);
+  m_heartbeatTimer.SetFunction(&ChordIpv4::DoPeriodicHeartbeat, this);
+  m_fixFingerTimer.SetFunction(&ChordIpv4::DoPeriodicFixFinger, this);
+
+  //Start timers
+  m_stabilizeTimer.Schedule(m_stabilizeInterval);
+  m_heartbeatTimer.Schedule(m_heartbeatInterval);
+  m_fixFingerTimer.Schedule(m_fixFingerInterval);
+}
+
+void
+ChordIpv4::StopApplication ()
+{
+  NS_LOG_FUNCTION_NOARGS ();
+  if (m_socket != 0)
+  {
+    //m_socket->Close ();
+    m_socket->SetRecvCallback(MakeNullCallback<void, Ptr<Socket> > ());
+    //m_socket = 0;
+  }
+  m_dHashIpv4 -> DoDispose();
+  //Cancel Timers
+  m_stabilizeTimer.Cancel();
+  m_heartbeatTimer.Cancel();
+  m_fixFingerTimer.Cancel();
+  //Delete vNodes
+  m_vNodeMap.Clear();
+}
+
+
+void
+ChordIpv4::SetJoinSuccessCallback (Callback<void, std::string, uint8_t*, uint8_t> joinSuccessFn)
+{
+  NS_LOG_FUNCTION_NOARGS ();
+  m_joinSuccessFn = joinSuccessFn;
+}
+
+void
+ChordIpv4::SetLookupSuccessCallback (Callback<void, uint8_t*, uint8_t, Ipv4Address, uint16_t> lookupSuccessFn)
+{
+  NS_LOG_FUNCTION_NOARGS ();
+  m_lookupSuccessFn = lookupSuccessFn;
+}
+
+void
+ChordIpv4::SetLookupFailureCallback (Callback<void, uint8_t*, uint8_t> lookupFailureFn)
+{
+  NS_LOG_FUNCTION_NOARGS ();
+  m_lookupFailureFn = lookupFailureFn;
+}
+
+void
+ChordIpv4::SetDHashLookupSuccessCallback (Callback<void, uint8_t*, uint8_t, Ipv4Address, uint16_t> dHashLookupSuccessFn)
+{
+  NS_LOG_FUNCTION_NOARGS ();
+  m_dHashLookupSuccessFn = dHashLookupSuccessFn;
+}
+
+void
+ChordIpv4::SetDHashLookupFailureCallback (Callback<void, uint8_t*, uint8_t> dHashLookupFailureFn)
+{
+  NS_LOG_FUNCTION_NOARGS ();
+  m_dHashLookupFailureFn = dHashLookupFailureFn;
+}
+
+void
+ChordIpv4::SetTraceRingCallback (Callback<void, std::string, uint8_t*, uint8_t> traceRingFn)
+{
+  NS_LOG_FUNCTION_NOARGS ();
+  m_traceRingFn = traceRingFn;
+}
+
+void
+ChordIpv4::SetVNodeFailureCallback (Callback<void, std::string, uint8_t*, uint8_t> vNodeFailureFn)
+{
+  NS_LOG_FUNCTION_NOARGS ();
+  m_vNodeFailureFn = vNodeFailureFn;
+}
+
+void
+ChordIpv4::SetVNodeKeyOwnershipCallback (Callback<void, std::string, uint8_t*, uint8_t, uint8_t*, uint8_t, uint8_t*, uint8_t, Ipv4Address, uint16_t> vNodeKeyOwnershipFn)
+{
+  NS_LOG_FUNCTION_NOARGS ();
+  m_vNodeKeyOwnershipFn = vNodeKeyOwnershipFn;
+}
+
+void 
+ChordIpv4::SetInsertSuccessCallback (Callback <void, uint8_t*, uint8_t, uint8_t*, uint32_t> insertSuccessFn)
+{
+  m_insertSuccessFn = insertSuccessFn;
+} 
+
+void 
+ChordIpv4::SetRetrieveSuccessCallback (Callback <void, uint8_t*, uint8_t, uint8_t*, uint32_t> retrieveSuccessFn)
+{
+  m_retrieveSuccessFn = retrieveSuccessFn;
+} 
+   
+void 
+ChordIpv4::SetInsertFailureCallback (Callback <void, uint8_t*, uint8_t, uint8_t*, uint32_t> insertFailureFn)
+{
+  m_insertFailureFn = insertFailureFn;
+} 
+
+void 
+ChordIpv4::SetRetrieveFailureCallback (Callback <void, uint8_t*, uint8_t> retrieveFailureFn)
+{
+  m_retrieveFailureFn = retrieveFailureFn;
+}
+
+void 
+ChordIpv4:: SetDHashVNodeKeyOwnershipCallback (Callback <void, uint8_t*, uint8_t, uint8_t*, uint8_t, uint8_t*, uint8_t, Ipv4Address, uint16_t> dHashVNodeKeyOwnershipFn)
+{
+  m_dHashVNodeKeyOwnershipFn = dHashVNodeKeyOwnershipFn;
+}
+
+void
+ChordIpv4::NotifyJoinSuccess (std::string vNodeName, Ptr<ChordIdentifier> chordIdentifier)
+{
+  NS_LOG_FUNCTION_NOARGS ();
+  if (!m_joinSuccessFn.IsNull ())
+  {
+    m_joinSuccessFn (vNodeName ,chordIdentifier->GetKey (), chordIdentifier->GetNumBytes());
+  }
+}
+
+void
+ChordIpv4::NotifyLookupSuccess (Ptr<ChordIdentifier> lookupIdentifier, Ptr<ChordNode> resolvedNode, ChordTransaction::Originator originator)
+{
+  NS_LOG_FUNCTION_NOARGS ();
+  if (!m_lookupSuccessFn.IsNull() && originator == ChordTransaction::APPLICATION)
+  {
+    m_lookupSuccessFn (lookupIdentifier->GetKey(), lookupIdentifier->GetNumBytes(), resolvedNode->GetIpAddress(), resolvedNode->GetApplicationPort());
+  }
+  else if (originator == ChordTransaction::DHASH)
+  {
+    NotifyDHashLookupSuccess (lookupIdentifier, resolvedNode->GetIpAddress(), resolvedNode->GetDHashPort());
+  }
+}
+
+void
+ChordIpv4::NotifyLookupFailure (Ptr<ChordIdentifier> chordIdentifier, ChordTransaction::Originator originator)
+{
+  NS_LOG_FUNCTION_NOARGS ();
+  if (!m_lookupFailureFn.IsNull() && originator == ChordTransaction::APPLICATION)
+  {
+    m_lookupFailureFn (chordIdentifier->GetKey (), chordIdentifier->GetNumBytes ());
+  }
+  else if (originator == ChordTransaction::DHASH)
+  {
+    NotifyDHashLookupFailure (chordIdentifier);
+  }
+}
+void
+ChordIpv4::NotifyDHashLookupSuccess (Ptr<ChordIdentifier> lookupIdentifier, Ipv4Address ipAddress, uint16_t port)
+{
+  NS_LOG_FUNCTION_NOARGS ();
+  if (!m_dHashLookupSuccessFn.IsNull())
+  {
+    m_dHashLookupSuccessFn (lookupIdentifier->GetKey(), lookupIdentifier->GetNumBytes(), ipAddress, port);
+  }
+}
+
+void
+ChordIpv4::NotifyDHashLookupFailure (Ptr<ChordIdentifier> chordIdentifier)
+{
+  NS_LOG_FUNCTION_NOARGS ();
+  if (!m_dHashLookupFailureFn.IsNull())
+  {
+    m_dHashLookupFailureFn (chordIdentifier->GetKey (), chordIdentifier->GetNumBytes ());
+  }
+}
+
+void
+ChordIpv4::NotifyVNodeKeyOwnership (std::string vNodeName, Ptr<ChordIdentifier> chordIdentifier, Ptr<ChordNode> predecessorNode, Ptr<ChordIdentifier> oldPredecessorIdentifier)
+{
+  NS_LOG_FUNCTION_NOARGS ();
+  if (!m_vNodeKeyOwnershipFn.IsNull ())
+  {
+    m_vNodeKeyOwnershipFn (vNodeName, chordIdentifier->GetKey (), chordIdentifier->GetNumBytes(), predecessorNode->GetChordIdentifier()->GetKey (), predecessorNode->GetChordIdentifier()->GetNumBytes (), oldPredecessorIdentifier->GetKey(), oldPredecessorIdentifier->GetNumBytes(), predecessorNode->GetIpAddress(), predecessorNode->GetApplicationPort());
+  }
+  if (m_dHashEnable)
+  {
+    m_dHashVNodeKeyOwnershipFn (chordIdentifier->GetKey(), chordIdentifier->GetNumBytes(),predecessorNode->GetChordIdentifier()->GetKey (), predecessorNode->GetChordIdentifier()->GetNumBytes (), oldPredecessorIdentifier->GetKey(), oldPredecessorIdentifier->GetNumBytes(), predecessorNode->GetIpAddress(), predecessorNode->GetDHashPort());
+  }
+}
+
+void
+ChordIpv4::NotifyTraceRing (std::string vNodeName, Ptr<ChordIdentifier> chordIdentifier)
+{
+  NS_LOG_FUNCTION_NOARGS ();
+  if (!m_traceRingFn.IsNull ())
+  {
+    m_traceRingFn (vNodeName ,chordIdentifier->GetKey (), chordIdentifier->GetNumBytes());
+  }
+}
+
+void
+ChordIpv4::NotifyVNodeFailure (std::string vNodeName, Ptr<ChordIdentifier> chordIdentifier)
+{
+  NS_LOG_FUNCTION_NOARGS ();
+  if (!m_vNodeFailureFn.IsNull())
+  {
+    m_vNodeFailureFn (vNodeName, chordIdentifier->GetKey (), chordIdentifier->GetNumBytes());
+  }
+}
+
+void
+ChordIpv4::NotifyInsertSuccess (uint8_t* key, uint8_t keyBytes, uint8_t* object, uint32_t objectBytes)
+{
+  m_insertSuccessFn (key, keyBytes, object, objectBytes);
+}
+
+void
+ChordIpv4::NotifyRetrieveSuccess (uint8_t* key, uint8_t keyBytes, uint8_t* object, uint32_t objectBytes)
+{
+  m_retrieveSuccessFn (key, keyBytes, object, objectBytes);
+}
+
+
+void
+ChordIpv4::NotifyInsertFailure (uint8_t* key, uint8_t keyBytes, uint8_t* object, uint32_t objectBytes)
+{
+  m_insertFailureFn (key, keyBytes, object, objectBytes);
+}
+
+void
+ChordIpv4::NotifyRetrieveFailure (uint8_t* key, uint8_t keyBytes)
+{
+  m_retrieveFailureFn (key, keyBytes); 
+}
+
+void
+ChordIpv4::Insert (uint8_t *key, uint8_t sizeOfKey ,uint8_t *object,uint32_t sizeOfObject)
+{
+  if (m_dHashEnable)
+  {
+    m_dHashIpv4->Insert(key, sizeOfKey, object, sizeOfObject);
+  }
+}
+
+void
+ChordIpv4::Retrieve (uint8_t *key, uint8_t sizeOfKey)
+{
+  if (m_dHashEnable)
+  {
+    m_dHashIpv4->Retrieve(key, sizeOfKey);
+  }
+}
+
+void
+ChordIpv4::InsertVNode (std::string vNodeName, uint8_t* key, uint8_t keyBytes)
+{
+  NS_LOG_FUNCTION_NOARGS ();
+  NS_LOG_INFO ("Creating Chord Virtual Node at NS3 physical node: " << GetNode ()->GetId());
+  Ptr<ChordIdentifier> chordIdentifier = Create<ChordIdentifier> (key, keyBytes);
+  //Create VNode object
+  Ptr<ChordNode> node = Create<ChordNode> (chordIdentifier, vNodeName, m_localIpAddress, m_listeningPort, m_applicationPort, m_dHashPort);
+  Ptr<ChordVNode> vNode = Create<ChordVNode> (node, m_maxVNodeSuccessorListSize, m_maxVNodePredecessorListSize);
+  //Own up entire key-space
+  vNode-> SetSuccessor (Create<ChordNode> (vNode));
+  vNode-> SetPredecessor (Create<ChordNode> (vNode));
+  //Set routable = false
+  vNode->SetRoutable(false);
+
+  /* bootStrapIp is same as local Ip and no v-nodes exist. In that case we need to create a new chord */
+  if (isBootStrapNode && m_vNodeMap.GetSize() == 0)
+  {
+    //Create a new chord network
+    //Insert VNode into list
+    Ptr<ChordNode> chordNode = DynamicCast<ChordNode>(vNode);
+    m_vNodeMap.UpdateNode (chordNode);
+    DoFixFinger (vNode);
+    NotifyJoinSuccess(vNode->GetVNodeName(), vNode->GetChordIdentifier());
+    return;
+  }
+
+  //Insert VNode into list
+  Ptr<ChordNode> chordNode = DynamicCast<ChordNode>(vNode); 
+  m_vNodeMap.UpdateNode (chordNode);
+  //Send this request to bootstrap IP
+  Ptr<Packet> packet = Create<Packet> ();
+  ChordMessage chordMessage = ChordMessage ();
+  vNode->PackJoinReq (chordMessage);
+  //Add transaction
+  Ptr<ChordTransaction> chordTransaction = Create<ChordTransaction> (chordMessage.GetTransactionId(), chordMessage, m_requestTimeout, m_maxRequestRetries);
+  //Add to vNode
+  vNode -> AddTransaction (chordMessage.GetTransactionId(), chordTransaction);
+
+  //Start transaction timer
+  EventId requestTimeoutId = Simulator::Schedule (chordTransaction->GetRequestTimeout(), &ChordIpv4::HandleRequestTimeout, this, vNode, chordMessage.GetTransactionId());
+  chordTransaction -> SetRequestTimeoutEventId (requestTimeoutId);
+  packet->AddHeader (chordMessage);
+  if (packet->GetSize())
+  {
+    NS_LOG_INFO ("Sending JoinReq\n" << chordMessage);
+    if (m_vNodeMap.GetSize() > 1)
+    {
+      if (RoutePacket (vNode->GetChordIdentifier(), packet) == true)
+      {
+        return;
+      }
+    }
+    //Default:: Send to bootstrap node
+    SendPacket (packet, m_bootStrapIp, m_bootStrapPort);
+  }
+}
+
+
+void
+ChordIpv4::RemoveVNode (std::string vNodeName)
+{
+  NS_LOG_INFO ("Removing Chord Virtual Node at NS3 physical node: " << GetNode ()->GetId());
+  NS_LOG_FUNCTION_NOARGS ();
+  //Iterate through the  m_vNodeMap and find the specified Vnode which has to leave.
+  //Iterate VNode list and check if v node exists
+  Ptr<ChordNode> chordNode; 
+  if (m_vNodeMap.FindNode(vNodeName, chordNode) != true)
+  {
+    return;
+  }
+  Ptr<ChordVNode> virtualNode = DynamicCast<ChordVNode>(chordNode);
+
+  //Send this request to bootstrap IP
+  Ptr<Packet> packet = Create<Packet> ();
+  ChordMessage chordMessage = ChordMessage ();
+  virtualNode ->PackLeaveReq (chordMessage);
+ 
+  packet->AddHeader (chordMessage);
+  if (packet->GetSize())
+  {
+    NS_LOG_INFO ("Sending LeaveReq\n" << chordMessage);
+    SendPacket (packet,virtualNode-> GetSuccessor() -> GetIpAddress() , virtualNode -> GetSuccessor() -> GetPort());
+    SendPacket (packet,virtualNode-> GetPredecessor() -> GetIpAddress() , virtualNode -> GetPredecessor() -> GetPort());
+  }
+
+  //delete VNode from m_vNodeMap  
+  DeleteVNode(vNodeName);
+  return;
+}
+
+void
+ChordIpv4::LookupKey (uint8_t* lookupKey, uint8_t lookupKeyBytes)
+{
+  NS_LOG_FUNCTION_NOARGS ();
+  Ptr<ChordIdentifier> requestedIdentifier = Create<ChordIdentifier> (lookupKey, lookupKeyBytes);
+  DoLookup (requestedIdentifier, ChordTransaction::APPLICATION);
+}
+void
+ChordIpv4::DHashLookupKey (uint8_t* lookupKey, uint8_t lookupKeyBytes)
+{
+  NS_LOG_FUNCTION_NOARGS ();
+  Ptr<ChordIdentifier> requestedIdentifier = Create<ChordIdentifier> (lookupKey, lookupKeyBytes);
+  DoLookup (requestedIdentifier, ChordTransaction::DHASH);
+}
+
+void
+ChordIpv4::DoLookup (Ptr<ChordIdentifier> requestedIdentifier, ChordTransaction::Originator originator)
+{
+  NS_LOG_FUNCTION_NOARGS ();
+  //Find local
+  Ptr<ChordVNode> virtualNode;
+  bool ret = LookupLocal (requestedIdentifier, virtualNode);
+  if (ret == true)
+  {
+    //We are owner, report success
+    NotifyLookupSuccess(requestedIdentifier, virtualNode, originator);
+    return;
+  } 
+  //Initiate lookup request
+  
+  if (FindNearestVNode (requestedIdentifier, virtualNode) == true)
+  {
+    Ptr<Packet> packet = Create<Packet> ();
+    ChordMessage chordMessage = ChordMessage ();
+    virtualNode->PackLookupReq (requestedIdentifier, chordMessage);
+    //Add transaction
+    Ptr<ChordTransaction> chordTransaction = Create<ChordTransaction> (chordMessage.GetTransactionId(), chordMessage, m_requestTimeout, m_maxRequestRetries);
+    chordTransaction->SetOriginator(originator);
+    chordTransaction->SetRequestedIdentifier (requestedIdentifier);
+    //Add to vNode
+    virtualNode -> AddTransaction (chordMessage.GetTransactionId(), chordTransaction);
+
+    //Start transaction timer
+    EventId requestTimeoutId = Simulator::Schedule (chordTransaction->GetRequestTimeout(), &ChordIpv4::HandleRequestTimeout, this, virtualNode, chordMessage.GetTransactionId());
+    chordTransaction -> SetRequestTimeoutEventId (requestTimeoutId);
+    packet->AddHeader (chordMessage);
+    if (packet->GetSize())
+    {
+      RouteViaFinger (requestedIdentifier, virtualNode, packet); 
+      //SendPacket (packet, virtualNode->GetSuccessor()->GetIpAddress(), virtualNode->GetSuccessor()->GetPort());
+    }
+  }  
+  else
+  {
+    NotifyLookupFailure (requestedIdentifier, originator);
+    return;
+  }
+}
+
+
+void
+ChordIpv4::ProcessUdpPacket (Ptr<Socket> socket)
+{
+  NS_LOG_FUNCTION_NOARGS ();
+  Ptr<Packet> packet;
+  Address from;
+  while (packet = socket->RecvFrom(from))
+  {
+    if (InetSocketAddress::IsMatchingType (from))
+    {
+      InetSocketAddress address = InetSocketAddress::ConvertFrom (from);
+      NS_LOG_INFO ("ChordIpv4: Received " << packet->GetSize() << " bytes packet from " <<  address.GetIpv4());
+      Ipv4Address fromIpAddress = address.GetIpv4();
+
+      ChordMessage chordMessage = ChordMessage ();
+      //Retrieve and Deserialize chord message
+      packet->RemoveHeader(chordMessage);
+      NS_LOG_INFO ("ChordMessage: " << chordMessage);
+      switch (chordMessage.GetMessageType ())
+      {
+       case ChordMessage::JOIN_REQ:
+         ProcessJoinReq (chordMessage);
+         break;
+       case ChordMessage::JOIN_RSP:
+         ProcessJoinRsp (chordMessage);
+         break;
+       case ChordMessage::LEAVE_REQ:
+         ProcessLeaveReq (chordMessage);
+         break;
+       case ChordMessage::LEAVE_RSP:
+         ProcessLeaveRsp (chordMessage);
+         break;
+       case ChordMessage::LOOKUP_REQ:
+         ProcessLookupReq (chordMessage);
+         break;
+       case ChordMessage::LOOKUP_RSP:
+         ProcessLookupRsp (chordMessage);
+         break;
+       case ChordMessage::STABILIZE_REQ:
+         ProcessStabilizeReq (chordMessage);
+         break;
+       case ChordMessage::STABILIZE_RSP:
+         ProcessStabilizeRsp (chordMessage);
+         break;
+       case ChordMessage::HEARTBEAT_REQ:
+         ProcessHeartbeatReq (chordMessage);
+         break;
+       case ChordMessage::HEARTBEAT_RSP:
+         ProcessHeartbeatRsp (chordMessage);
+         break;
+       case ChordMessage::FINGER_REQ:
+         ProcessFingerReq (chordMessage);
+         break;
+       case ChordMessage::FINGER_RSP:
+         ProcessFingerRsp (chordMessage);
+         break;
+       case ChordMessage::TRACE_RING:
+         ProcessTraceRing (chordMessage);
+         break;
+       default:
+         break;
+
+      }
+    }
+  }
+}
+
+void
+ChordIpv4::ProcessJoinReq (ChordMessage chordMessage)
+{
+  NS_LOG_FUNCTION_NOARGS ();
+  Ptr<ChordNode> requestorNode = chordMessage.GetRequestorNode();
+  uint32_t transactionId = chordMessage.GetTransactionId ();
+  if (m_vNodeMap.GetSize() == 0)
+  {
+    //No vNode exists as yet, drop this request.
+    return;
+  }
+  Ptr<Packet> packet = Create<Packet> ();
+  //Check if we can be this node's successor
+  Ptr<ChordVNode> virtualNode;
+  bool ret = LookupLocal (requestorNode->GetChordIdentifier(), virtualNode);
+  if (ret == true)
+  {
+    ChordMessage chordMessageRsp = ChordMessage ();
+    virtualNode->PackJoinRsp (requestorNode, transactionId, chordMessageRsp);
+    packet-> AddHeader (chordMessageRsp);
+    //Send packet
+    if (packet->GetSize())
+    {
+      NS_LOG_INFO("Sending JoinRsp: "<<chordMessageRsp);
+      SendPacket(packet, requestorNode->GetIpAddress(), requestorNode->GetPort());
+    }
+    return;
+  }
+  //Could not resolve join request, forward to nearest successor
+  packet->AddHeader(chordMessage);
+  if (packet->GetSize())
+  {
+    RoutePacket (requestorNode->GetChordIdentifier(), packet);
+  }
+}
+
+void
+ChordIpv4::ProcessJoinRsp (ChordMessage chordMessage)
+{
+  NS_LOG_FUNCTION_NOARGS ();
+  //Extract info from packet
+  Ptr<ChordNode> requestorNode = chordMessage.GetRequestorNode();
+  Ptr<ChordNode> successorNode = chordMessage.GetJoinRsp().successorNode;
+  //Find virtual node which sent this message
+  Ptr<ChordVNode> virtualNode;
+  bool ret = FindVNode(requestorNode->GetChordIdentifier(), virtualNode);
+  if (ret == true)
+  {  
+    //Find Transaction
+    Ptr<ChordTransaction> chordTransaction;
+    if (virtualNode->FindTransaction(chordMessage.GetTransactionId(), chordTransaction) == false)
+    {
+      //No transaction exists, return from here
+      return;
+    }
+    //VNode found, set its successor and stabilize
+    virtualNode->SetSuccessor(Create<ChordNode> (successorNode));
+    //Make this node routable
+    virtualNode->SetRoutable (true);
+    //cancel transaction
+    virtualNode->RemoveTransaction (chordTransaction->GetTransactionId());
+    DoStabilize(virtualNode);
+    DoFixFinger (virtualNode);
+    //notify application about join success
+    NotifyJoinSuccess(virtualNode->GetVNodeName(), requestorNode->GetChordIdentifier());
+  }
+}
+
+void
+ChordIpv4::ProcessLookupReq (ChordMessage chordMessage)
+{
+  NS_LOG_FUNCTION_NOARGS ();
+  Ptr<ChordNode> requestorNode = chordMessage.GetRequestorNode();
+  Ptr<ChordIdentifier> requestedIdentifier = chordMessage.GetLookupReq().requestedIdentifier;
+  uint32_t transactionId = chordMessage.GetTransactionId ();
+  if (m_vNodeMap.GetSize() == 0)
+  {
+    //No vNode exists as yet, drop this request.
+    return;
+  }
+  Ptr<Packet> packet = Create<Packet> ();
+  //Check if we are owner of requestedIdentifier
+  Ptr<ChordVNode> virtualNode;
+  bool ret = LookupLocal (requestedIdentifier, virtualNode);
+  if (ret == true)
+  {
+    ChordMessage chordMessageRsp = ChordMessage ();
+    virtualNode->PackLookupRsp (requestorNode,  transactionId, chordMessageRsp);
+    packet-> AddHeader (chordMessageRsp);
+    //Send packet
+    if (packet->GetSize())
+    {
+      NS_LOG_INFO("Sending LookupRsp: "<<chordMessageRsp);
+      SendPacket(packet, requestorNode->GetIpAddress(), requestorNode->GetPort());
+    }
+    return;
+  }
+  //Could not resolve lookup request, forward to nearest successor
+  packet->AddHeader(chordMessage);
+  RoutePacket (requestedIdentifier, packet);
+}
+
+void
+ChordIpv4::ProcessLeaveReq(ChordMessage chordMessage)
+{
+  NS_LOG_FUNCTION_NOARGS ();
+
+  Ptr<ChordNode> requestorNode = chordMessage.GetRequestorNode();
+  //Read payload and get vnode identifier
+  Ptr<ChordNode> successorNode = chordMessage.GetLeaveReq().successorNode;
+  Ptr<ChordNode> predecessorNode = chordMessage.GetLeaveReq().predecessorNode;
+
+  //Find VNode
+  Ptr<ChordVNode> virtualNode;
+
+  //Are we successor node?
+  bool ret;
+  ret = FindVNode(successorNode->GetChordIdentifier(), virtualNode);
+  if (ret == true && virtualNode->GetPredecessor()->GetChordIdentifier()->IsEqual(requestorNode->GetChordIdentifier()))
+  {
+    //Reset own predecessor
+    Ptr<ChordNode> oldPredecessorNode = virtualNode->GetPredecessor();
+    virtualNode->SetPredecessor(Create<ChordNode> (predecessorNode));
+    NotifyVNodeKeyOwnership (virtualNode->GetVNodeName(), virtualNode->GetChordIdentifier(), virtualNode->GetPredecessor(), oldPredecessorNode->GetChordIdentifier());
+    //Send Leave Rsp (only required in case of successor)
+    ChordMessage respMessage = ChordMessage ();
+    virtualNode->PackLeaveRsp (requestorNode, successorNode, predecessorNode, chordMessage);
+    Ptr<Packet> packet = Create<Packet> ();
+    packet->AddHeader (chordMessage);
+    SendPacket (packet, requestorNode->GetIpAddress(), requestorNode->GetPort());
+    NS_LOG_INFO("Predecessor changed for VNode");
+  }
+
+  //Are we predecessor node?
+  ret = FindVNode(predecessorNode->GetChordIdentifier(), virtualNode);
+  if (ret == true && virtualNode->GetSuccessor()->GetChordIdentifier()->IsEqual(requestorNode->GetChordIdentifier()))
+  {
+    //Reset own successor
+    virtualNode->SetSuccessor(Create<ChordNode> (successorNode));
+    DoFixFinger (virtualNode);
+    virtualNode->SetRoutable(true);
+    NS_LOG_INFO("Successor changed for VNode");
+  }
+}
+
+void
+ChordIpv4::ProcessLeaveRsp (ChordMessage chordMessage)
+{
+  NS_LOG_FUNCTION_NOARGS ();
+  Ptr<ChordNode> requestorNode = chordMessage.GetRequestorNode();
+  Ptr<ChordNode> successorNode = chordMessage.GetLeaveRsp().successorNode;
+  Ptr<ChordNode> predecessorNode = chordMessage.GetLeaveRsp().predecessorNode;
+  
+  Ptr<ChordIdentifier> requestorIdentifier = requestorNode->GetChordIdentifier();
+  Ptr<ChordIdentifier> successorIdentifier = successorNode->GetChordIdentifier();
+  Ptr<ChordIdentifier> predecessorIdentifier = predecessorNode->GetChordIdentifier();
+  
+  if (!m_dHashVNodeKeyOwnershipFn.IsNull() && m_dHashEnable)
+  {
+    //Send trigger to dHash
+    m_dHashVNodeKeyOwnershipFn (successorIdentifier->GetKey(), successorIdentifier->GetNumBytes(), requestorIdentifier->GetKey(), requestorIdentifier->GetNumBytes(), predecessorIdentifier->GetKey(), predecessorIdentifier->GetNumBytes(), successorNode->GetIpAddress(), successorNode->GetDHashPort());
+  }
+}
+
+void
+ChordIpv4::ProcessLookupRsp (ChordMessage chordMessage)
+{
+  NS_LOG_FUNCTION_NOARGS ();
+  NS_LOG_INFO ("Received Lookup Response");
+  //Extract info from packet
+  Ptr<ChordNode> requestorNode = chordMessage.GetRequestorNode();
+  Ptr<ChordNode> resolvedNode = chordMessage.GetLookupRsp().resolvedNode;
+  //Find virtual node which sent this message
+  Ptr<ChordVNode> virtualNode;
+  bool ret = FindVNode(requestorNode->GetChordIdentifier(), virtualNode);
+  if (ret == true)
+  {  
+    //Find Transaction
+    Ptr<ChordTransaction> chordTransaction;
+    if (virtualNode->FindTransaction(chordMessage.GetTransactionId(), chordTransaction) == false)
+    {
+      //No transaction exists, return from here
+      return;
+    }
+    Ptr<ChordIdentifier> requestedIdentifier = chordTransaction->GetRequestedIdentifier ();
+    ChordTransaction::Originator originator = chordTransaction->GetOriginator();
+    //cancel transaction
+    virtualNode->RemoveTransaction (chordTransaction->GetTransactionId());
+    //notify application about lookup success
+    NotifyLookupSuccess(requestedIdentifier, resolvedNode, originator);
+  }
+}
+
+
+void
+ChordIpv4::ProcessStabilizeReq(ChordMessage chordMessage)
+{
+  Ptr<ChordNode> requestorNode = chordMessage.GetRequestorNode();
+
+  //Read payload and get vnode identifier
+  Ptr<ChordIdentifier> vNodeIdentifier = chordMessage.GetStabilizeReq().successorIdentifier;
+
+  //Find VNode
+  Ptr<ChordVNode> virtualNode;
+  bool ret = FindVNode(vNodeIdentifier, virtualNode);
+  if (ret == false)
+  {
+    //VNode does not exist here, drop packet
+    return;
+  }
+
+  //Stabilize
+  
+  if (requestorNode->GetChordIdentifier()->IsInBetween(virtualNode->GetPredecessor()->GetChordIdentifier(), virtualNode->GetChordIdentifier()))
+  {
+    //Reset own predecessor
+    Ptr<ChordNode> predecessorNode = Create<ChordNode> (requestorNode);
+    Ptr<ChordNode> oldPredecessorNode = virtualNode->GetPredecessor();
+    virtualNode->SetPredecessor(predecessorNode);
+    //Check if requestor can be our successor as well (bootstrap case)
+    if (virtualNode->GetSuccessor()->GetChordIdentifier()->IsEqual(virtualNode->GetChordIdentifier()))
+    {
+      //Reset Successor as well
+      Ptr<ChordNode> successorNode = Create<ChordNode> (requestorNode);
+      virtualNode->SetSuccessor(successorNode);
+      virtualNode->SetRoutable(true);
+      //Stabilize
+      DoStabilize(virtualNode);
+      DoFixFinger (virtualNode);
+    }
+    NotifyVNodeKeyOwnership (virtualNode->GetVNodeName(), virtualNode->GetChordIdentifier(), virtualNode->GetPredecessor(), oldPredecessorNode->GetChordIdentifier());
+    NS_LOG_INFO("Predecessor changed for VNode");
+  }
+  Ptr<Packet> packet = Create<Packet> ();
+  //Send Response
+  ChordMessage chordMessageRsp = ChordMessage ();
+  virtualNode->PackStabilizeRsp(requestorNode, chordMessageRsp);
+  packet-> AddHeader (chordMessageRsp);
+  if (packet->GetSize())
+  {
+    NS_LOG_INFO ("Sending StabilizeRsp: "<<chordMessageRsp);
+    SendPacket(packet, requestorNode->GetIpAddress(), requestorNode->GetPort());
+  }
+  return;
+}
+
+void
+ChordIpv4::ProcessStabilizeRsp(ChordMessage chordMessage)
+{
+  //Extract info
+  Ptr<ChordNode> requestorNode = chordMessage.GetRequestorNode();
+  //Read payload
+  Ptr<ChordNode> predecessorNode = chordMessage.GetStabilizeRsp().predecessorNode;
+
+  //Find VNode
+  Ptr<ChordVNode> virtualNode;
+  bool ret = FindVNode(requestorNode->GetChordIdentifier(), virtualNode);
+  if (ret == false)
+  {
+    //VNode does not exist here, drop packet
+    return;
+  }
+
+  //Reset Successor if needed
+  if (!virtualNode->GetChordIdentifier()->IsEqual(predecessorNode->GetChordIdentifier()))
+  {
+    //We need to reset successor and restabilize new successor
+    Ptr<ChordNode> successorNode = Create<ChordNode> (predecessorNode);
+    virtualNode->SetSuccessor(successorNode);
+    virtualNode->SetRoutable(true);
+    NS_LOG_INFO("Successor changed for VNode");
+    //Trigger stabilization
+    DoStabilize(virtualNode);
+    DoFixFinger (virtualNode);
+    return;
+  }
+  //Reset timestamp
+  virtualNode->GetSuccessor()->SetTimestamp(Simulator::Now());
+  //Synch successor list
+  virtualNode->SynchSuccessorList (chordMessage.GetStabilizeRsp().successorList);
+}
+
+void
+ChordIpv4::ProcessHeartbeatReq(ChordMessage chordMessage)
+{
+  Ptr<ChordNode> requestorNode = chordMessage.GetRequestorNode();
+
+  //Read payload and get vnode identifier
+  Ptr<ChordIdentifier> vNodeIdentifier = chordMessage.GetHeartbeatReq().predecessorIdentifier;
+
+  //Find VNode
+  Ptr<ChordVNode> virtualNode;
+  bool ret = FindVNode(vNodeIdentifier, virtualNode);
+  if (ret == false)
+  {
+    //VNode does not exist here, drop packet
+    return;
+  }
+
+  //Reply to heartbeat
+  Ptr<Packet> packet = Create<Packet> ();
+  ChordMessage chordMessageRsp = ChordMessage ();
+  virtualNode->PackHeartbeatRsp(requestorNode, chordMessageRsp);
+  packet-> AddHeader (chordMessageRsp);
+  if (packet->GetSize())
+  {
+    NS_LOG_INFO ("Sending StabilizeRsp: "<<chordMessageRsp);
+    SendPacket(packet, requestorNode->GetIpAddress(), requestorNode->GetPort());
+  }
+  return;
+}
+
+void
+ChordIpv4::ProcessHeartbeatRsp(ChordMessage chordMessage)
+{
+  //Extract info
+  Ptr<ChordNode> requestorNode = chordMessage.GetRequestorNode();
+  //Read payload -- Not needed for Heartbeats
+  /*
+  */
+  //Find VNode
+  Ptr<ChordVNode> virtualNode;
+  bool ret = FindVNode(requestorNode->GetChordIdentifier(), virtualNode);
+  if (ret == false)
+  {
+    //VNode does not exist here, drop packet
+    return;
+  }
+  //Reset timestamp
+  virtualNode->GetPredecessor()->SetTimestamp(Simulator::Now());
+  //Synch predecessor list
+  virtualNode->SynchPredecessorList (chordMessage.GetHeartbeatRsp().predecessorList);
+}
+
+void
+ChordIpv4::ProcessFingerReq (ChordMessage chordMessage)
+{
+  Ptr<ChordNode> requestorNode = chordMessage.GetRequestorNode();
+  Ptr<ChordIdentifier> requestedIdentifier = chordMessage.GetFingerReq().requestedIdentifier;
+  if (m_vNodeMap.GetSize() == 0)
+  {
+    //No vNode exists as yet, drop this request.
+    return;
+  }
+  Ptr<Packet> packet = Create<Packet> ();
+  //Check if we are owner of requestedIdentifier
+  Ptr<ChordVNode> virtualNode;
+  bool ret = LookupLocal (requestedIdentifier, virtualNode);
+  if (ret == true)
+  {
+    ChordMessage chordMessageRsp = ChordMessage ();
+    virtualNode->PackFingerRsp (requestorNode, requestedIdentifier,chordMessageRsp);
+    packet-> AddHeader (chordMessageRsp);
+    //Send packet
+    if (packet->GetSize())
+    {
+      NS_LOG_INFO("Sending FingerRsp: "<<chordMessageRsp);
+      SendPacket(packet, requestorNode->GetIpAddress(), requestorNode->GetPort());
+    }
+    return;
+  }
+  //Could not resolve finger request, forward to successor
+  packet->AddHeader(chordMessage);
+  Ptr<ChordVNode> vNode;
+  if (FindNearestVNode (requestedIdentifier, vNode) == true)
+  {
+    SendPacket (packet, vNode->GetSuccessor()->GetIpAddress(), vNode->GetSuccessor()->GetPort());
+  }
+  else
+  {
+    SendViaAnyVNode (packet);
+  }
+}
+
+void
+ChordIpv4::ProcessFingerRsp (ChordMessage chordMessage)
+{
+  //Extract info from packet
+  Ptr<ChordNode> requestorNode = chordMessage.GetRequestorNode();
+  Ptr<ChordIdentifier> requestedIdentifier = chordMessage.GetFingerRsp().requestedIdentifier;
+  Ptr<ChordNode> fingerNode = chordMessage.GetFingerRsp().fingerNode;
+  //Find virtual node which sent this message
+  Ptr<ChordVNode> virtualNode;
+  bool ret = FindVNode(requestorNode->GetChordIdentifier(), virtualNode);
+  if (ret == true)
+  { 
+    //Save finger lookup in table
+    Ptr<ChordNode> finger = Create<ChordNode> (fingerNode);
+    virtualNode->GetFingerTable().UpdateNode(fingerNode); 
+  }
+}
+
+void
+ChordIpv4::HandleRequestTimeout (Ptr<ChordVNode> vNode, uint32_t transactionId)
+{
+  NS_LOG_FUNCTION_NOARGS ();
+  //Find transaction
+  Ptr<ChordTransaction> chordTransaction;
+  if (vNode -> FindTransaction (transactionId, chordTransaction) == false)
+  {
+    //Transaction does not exist
+    return;
+  }
+  //Retransmit and reschedule if needed
+  if (chordTransaction->GetRetries() > chordTransaction->GetMaxRetries())
+  {
+    //Report failure
+    if (chordTransaction->GetChordMessage().GetMessageType() == ChordMessage::JOIN_REQ)
+    {
+      NS_LOG_ERROR ("Join request failed!");
+      NotifyVNodeFailure (vNode->GetVNodeName(), vNode->GetChordIdentifier());
+      //Delete vNode
+      DeleteVNode(vNode->GetChordIdentifier());
+    }
+    else if (chordTransaction->GetChordMessage().GetMessageType() == ChordMessage::LOOKUP_REQ)
+    {
+      NS_LOG_ERROR ("Lookup Request failed!");
+      NotifyLookupFailure (chordTransaction->GetChordMessage().GetLookupReq().requestedIdentifier, chordTransaction->GetOriginator());
+      //cancel transaction
+      vNode->RemoveTransaction (chordTransaction->GetTransactionId());
+    }
+    return;
+  }
+  else
+  {
+    //Retransmit
+    uint8_t retries = chordTransaction->GetRetries();
+    chordTransaction->SetRetries (retries+1);
+    Ptr<Packet> packet = Create<Packet> ();
+    packet->AddHeader (chordTransaction->GetChordMessage());
+    if (packet->GetSize())
+    {
+      NS_LOG_INFO ("Retransmission Req\n" << chordTransaction->GetChordMessage());
+      SendPacket (packet, m_bootStrapIp, m_bootStrapPort);
+    }
+    //Reschedule
+    //Start transaction timer
+    EventId requestTimeoutId = Simulator::Schedule (chordTransaction->GetRequestTimeout(), &ChordIpv4::HandleRequestTimeout, this, vNode, transactionId);
+    chordTransaction -> SetRequestTimeoutEventId (requestTimeoutId);
+  }
+}
+
+
+
+
+
+bool
+ChordIpv4::FindVNode (Ptr<ChordIdentifier> chordIdentifier, Ptr<ChordVNode>& virtualNode)
+{
+  NS_LOG_FUNCTION_NOARGS ();
+  //Iterate VNode list and check if v node exists
+  Ptr<ChordNode> chordNode; 
+  if (m_vNodeMap.FindNode(chordIdentifier, chordNode) != true)
+  {
+    return false;
+  }
+  virtualNode = DynamicCast<ChordVNode>(chordNode);
+  return true;
+}
+
+void
+ChordIpv4::DeleteVNode (Ptr<ChordIdentifier> chordIdentifier)
+{
+  NS_LOG_FUNCTION_NOARGS ();
+
+  m_vNodeMap.RemoveNode(chordIdentifier);
+}
+
+void
+ChordIpv4::DeleteVNode (std::string vNodeName)
+{
+  m_vNodeMap.RemoveNode(vNodeName);
+}
+
+
+bool
+ChordIpv4::LookupLocal (Ptr<ChordIdentifier> chordIdentifier, Ptr<ChordVNode>& virtualNode)
+{
+  NS_LOG_FUNCTION_NOARGS ();
+  //Iterate VNode list and check if we are owner
+  for(ChordNodeMap::iterator vNodeIter = m_vNodeMap.GetMap().begin(); vNodeIter != m_vNodeMap.GetMap().end(); vNodeIter++)
+  {
+    Ptr<ChordVNode> vNode = DynamicCast<ChordVNode>((*vNodeIter).second);
+    if (vNode->GetPredecessor() == 0)
+      continue;
+    if (chordIdentifier->IsInBetween(vNode->GetPredecessor()->GetChordIdentifier (), vNode->GetChordIdentifier () ))
+    {
+      //Do not accept ownership if we have set ourselves as predecessor, but accept in bootstrap case. This means our predecessor recently died and we are waiting for someone to send us stabilize. 
+      if (vNode->GetPredecessor()->GetChordIdentifier()->IsEqual(vNode->GetChordIdentifier()) && !vNode->GetPredecessor()->GetChordIdentifier()->IsEqual(vNode->GetSuccessor()->GetChordIdentifier()))
+      {
+        return false;
+      }
+
+      //We are the owner. Set virtualNode pointer and return success
+      virtualNode = DynamicCast<ChordVNode>((*vNodeIter).second);
+      return true;
+    }
+  }
+  NS_LOG_INFO ("NOT OWNER, localIpAddress: "<<m_localIpAddress<<" listeningPort"<<m_listeningPort);
+  //We are not owner, return failure
+  return false;
+}
+
+bool
+ChordIpv4::CheckOwnership (uint8_t* lookupKey, uint8_t lookupKeyBytes)
+{
+  NS_LOG_FUNCTION_NOARGS ();
+  Ptr<ChordIdentifier> lookupIdentifier = Create<ChordIdentifier> (lookupKey, lookupKeyBytes);
+  Ptr<ChordVNode> chordVNode;
+  if (LookupLocal(lookupIdentifier , chordVNode) == true)
+  {
+    return true;
+  }
+  return false;
+}
+
+void
+ChordIpv4::SendPacket (Ptr<Packet> packet, Ipv4Address destinationIp, uint16_t destinationPort)
+{
+  NS_LOG_FUNCTION_NOARGS ();
+  m_socket->SendTo (packet, 0, InetSocketAddress (destinationIp, destinationPort));
+}
+
+/*  Logic: We need to send packet via virtual node whose key is nearest to the requested key. Our aim is to minimize lookup hops.
+ *
+ *  Step 1: Iterate for all virtual nodes and maximize identifier for v-nodes which satisfies: vnode lies inBetween (0,key] <closestVNodeOnRight>
+ *  Step 2: If none found in step 1, send to v-node with highest key number <closestVNodeOnLeft>
+ */
+bool
+ChordIpv4::FindNearestVNode (Ptr<ChordIdentifier> targetIdentifier, Ptr<ChordVNode> &virtualNode)
+{
+  NS_LOG_FUNCTION_NOARGS ();
+  Ptr<ChordNode> chordNode; 
+  if (m_vNodeMap.FindNearestNode(targetIdentifier, chordNode) != true)
+  {
+    return false;
+  }
+  virtualNode = DynamicCast<ChordVNode>(chordNode);
+  return true;
+}
+
+//TODO: Change logic to check health of vnode before sending
+bool 
+ChordIpv4::SendViaAnyVNode (Ptr<Packet> packet)
+{
+  NS_LOG_FUNCTION_NOARGS ();
+  //Find first v-node with valid successor
+  for(ChordNodeMap::iterator vNodeIter = m_vNodeMap.GetMap().begin(); vNodeIter != m_vNodeMap.GetMap().end(); vNodeIter++)
+  {
+    Ptr<ChordVNode> vNode = DynamicCast<ChordVNode>((*vNodeIter).second);
+    //Choose any node whose successor is not set as self
+    if (!vNode->GetSuccessor()->GetChordIdentifier()->IsEqual(vNode->GetChordIdentifier()))
+    {
+      SendPacket (packet, vNode->GetSuccessor()->GetIpAddress(), vNode->GetSuccessor()->GetPort());
+      return true;
+    }
+  }
+  return false;
+}
+
+bool
+ChordIpv4::RoutePacket (Ptr<ChordIdentifier> targetIdentifier, Ptr<Packet> packet)
+{
+  if (packet->GetSize())
+  {
+    Ptr<ChordVNode> vNode;
+    //Choose best vNode
+    if (FindNearestVNode (targetIdentifier, vNode) == true)
+    {
+      if (RouteViaFinger (targetIdentifier, vNode, packet) == true)
+        return true;
+    }
+    else
+    {
+      return SendViaAnyVNode (packet);
+    }
+  }
+  return false;
+}
+
+bool
+ChordIpv4::RouteViaFinger (Ptr<ChordIdentifier> targetIdentifier, Ptr<ChordVNode> vNode, Ptr<Packet> packet)
+{
+  if (packet->GetSize())
+  {
+    Ptr<ChordNode> remoteNode;
+    //Choose nearest finger
+    if (vNode->GetFingerTable().FindNearestNode(targetIdentifier, remoteNode) == true)
+    {
+      SendPacket (packet, remoteNode->GetIpAddress(), remoteNode->GetPort());
+      return true;
+    }
+    else
+    {
+      //Send to successor
+      SendPacket (packet, vNode->GetSuccessor()->GetIpAddress(), vNode->GetSuccessor()->GetPort());
+      return true;
+    }
+  }
+  return false;
+}
+
+
+
+void
+ChordIpv4::DoPeriodicStabilize()
+{
+  //Loop for all v-nodes
+  for(ChordNodeMap::iterator vNodeIter = m_vNodeMap.GetMap().begin(); vNodeIter != m_vNodeMap.GetMap().end(); vNodeIter++)
+  {
+    Ptr<ChordVNode> vNode = DynamicCast<ChordVNode>((*vNodeIter).second);
+    //Check if successor is alive. Shift successor if necessary. If all else fails, send CHORD_FAILURE to user and remove vNode
+    //Compare timestamp and check if current successor has died
+    if (vNode->GetSuccessor()->GetTimestamp().GetMilliSeconds() + m_stabilizeInterval.GetMilliSeconds() * m_maxMissedKeepAlives < Simulator::Now().GetMilliSeconds ())
+    {
+      //Successor has failed
+      //Shift vNode successor
+      if (vNode->ShiftSuccessor() == false)
+      {
+        //If this is last node and we are bootstrap node, do not report failure or remove this node. This can be only removed manually.
+        if (isBootStrapNode && m_vNodeMap.GetSize() == 1)
+        {
+          //Reset successor as self
+          vNode -> SetSuccessor (Create<ChordNode> (vNode));
+          vNode -> SetRoutable (false);
+
+          continue;
+        }
+ 
+        //No successor(s) in list, report failure and remove vNode
+        NotifyVNodeFailure (vNode->GetVNodeName(), vNode->GetChordIdentifier());
+        //Delete vNode
+        DeleteVNode(vNode->GetChordIdentifier());
+        if (m_vNodeMap.GetSize() == 0)
+          break;
+        else
+          continue;
+      }
+    }
+    //Fire stablize req
+    DoStabilize (vNode);
+  }
+  //RescheduleTimer
+  m_stabilizeTimer.Schedule (m_stabilizeInterval);
+
+}
+
+void
+ChordIpv4::DoPeriodicHeartbeat()
+{
+  //Loop for all v-nodes
+  for(ChordNodeMap::iterator vNodeIter = m_vNodeMap.GetMap().begin(); vNodeIter != m_vNodeMap.GetMap().end(); vNodeIter++)
+  {
+    Ptr<ChordVNode> vNode = DynamicCast<ChordVNode>((*vNodeIter).second);
+
+    if (vNode->GetPredecessor()->GetTimestamp().GetMilliSeconds() + m_heartbeatInterval.GetMilliSeconds() * m_maxMissedKeepAlives < Simulator::Now().GetMilliSeconds ())
+    {
+      Ptr<ChordNode> oldPredecessorNode = vNode->GetPredecessor();
+      //Predecessor has failed
+      //Shift vNode predecessor
+      if (vNode->ShiftPredecessor() == false)
+      {
+        //Reset predecessor as self node
+        vNode -> SetPredecessor(Create<ChordNode> (vNode));
+        continue;
+      }
+      else
+      {
+        //Predecessor shift success, trigger key space change
+        NotifyVNodeKeyOwnership (vNode->GetVNodeName(), vNode->GetChordIdentifier(), vNode->GetPredecessor(), oldPredecessorNode->GetChordIdentifier());
+      }
+    }
+    //Fire stablize req
+    DoHeartbeat (vNode);
+  }
+  //RescheduleTimer
+  m_heartbeatTimer.Schedule (m_heartbeatInterval);
+
+}
+
+
+void
+ChordIpv4::DoPeriodicFixFinger ()
+{
+  for(ChordNodeMap::iterator vNodeIter = m_vNodeMap.GetMap().begin(); vNodeIter != m_vNodeMap.GetMap().end(); vNodeIter++)
+  {
+    Ptr<ChordVNode> vNode = DynamicCast<ChordVNode>((*vNodeIter).second);
+    DoFixFinger (vNode);
+  }
+  //RescheduleTimer
+  //Use random variable and introduce variance of 100ms
+  NormalVariable interval = NormalVariable (m_fixFingerInterval.GetMilliSeconds(), 100);
+  m_fixFingerTimer.Schedule (MilliSeconds(interval.GetValue()));
+}
+
+void
+ChordIpv4::DoFixFinger (Ptr<ChordVNode> virtualNode)
+{
+  //Do not fix fingers for unstable v-nodes
+  if (virtualNode->GetSuccessor()->GetChordIdentifier()->IsEqual(virtualNode->GetChordIdentifier()))
+  {
+    return;
+  }
+  //Remove stale entries from finger table; Remove even if finger request failed in last try. TODO: Use transactions for finger requests??
+  virtualNode->GetFingerTable().Audit (m_fixFingerInterval);
+
+  virtualNode->GetStats().fingersLookedUp = 0;
+
+  for (std::vector<Ptr<ChordIdentifier> >::iterator fingerIter = virtualNode->GetFingerIdentifierList().begin(); fingerIter != virtualNode->GetFingerIdentifierList().end(); fingerIter++)
+  {
+    Ptr<ChordIdentifier> fingerIdentifier = *fingerIter;
+    //Do not lookup local identifiers
+    Ptr<ChordVNode> vNode;
+    if (LookupLocal (fingerIdentifier, vNode) == true)
+    {
+      continue;
+    }
+    //Do not lookup fingers between successor and this node
+    if (fingerIdentifier->IsInBetween(virtualNode->GetChordIdentifier(), virtualNode->GetSuccessor()->GetChordIdentifier()))
+    {
+      //Make routing entry
+      Ptr<ChordNode> fingerNode = Create<ChordNode> (fingerIdentifier, virtualNode->GetSuccessor()->GetIpAddress(), virtualNode->GetSuccessor()->GetPort(), virtualNode->GetSuccessor()->GetApplicationPort(), virtualNode->GetSuccessor()->GetDHashPort());
+      virtualNode->GetFingerTable().UpdateNode(fingerNode); 
+      continue;
+    }
+    Ptr<Packet> packet = Create<Packet> ();
+    ChordMessage chordMessage = ChordMessage ();
+    virtualNode->PackFingerReq(fingerIdentifier, chordMessage); 
+    packet->AddHeader (chordMessage);
+    if (packet->GetSize())
+    {
+      virtualNode->GetStats().fingersLookedUp++;
+      NS_LOG_INFO ("Sending FingerReq: " << chordMessage);
+      //Route using successor for finger fixing
+      SendPacket (packet, virtualNode->GetSuccessor()->GetIpAddress(), virtualNode->GetSuccessor()->GetPort());
+      //RoutePacket (fingerIdentifier, packet);
+    }
+  }
+}
+
+void
+ChordIpv4::DoStabilize(Ptr<ChordVNode> virtualNode)
+{
+  if (virtualNode->GetSuccessor()->GetChordIdentifier()->IsEqual(virtualNode->GetChordIdentifier()))
+  {
+    //Reset timestamp
+    virtualNode->GetSuccessor()->SetTimestamp (Simulator::Now());
+    return;
+  }
+  Ptr<Packet> packet = Create<Packet> ();
+  ChordMessage chordMessage = ChordMessage ();
+  virtualNode->PackStabilizeReq(chordMessage);
+  packet-> AddHeader (chordMessage);
+  if (packet->GetSize())
+  {
+    NS_LOG_INFO ("Sending StabilizeReq: " << chordMessage);
+    SendPacket(packet, virtualNode->GetSuccessor()->GetIpAddress(), virtualNode->GetSuccessor()->GetPort());
+  }
+}
+
+void
+ChordIpv4::DoHeartbeat(Ptr<ChordVNode> virtualNode)
+{
+  if (virtualNode -> GetPredecessor()->GetChordIdentifier()->IsEqual(virtualNode->GetChordIdentifier()))
+  {
+    //Reset timestamp
+    virtualNode->GetPredecessor()->SetTimestamp (Simulator::Now());
+    return;
+  }
+  Ptr<Packet> packet = Create<Packet> ();
+  ChordMessage chordMessage = ChordMessage ();
+  virtualNode->PackHeartbeatReq(chordMessage);
+  packet->AddHeader (chordMessage);
+  if (packet->GetSize())
+  {
+    NS_LOG_INFO ("Sending HeartbeatReq: " << chordMessage);
+    SendPacket(packet, virtualNode->GetPredecessor()->GetIpAddress(), virtualNode->GetPredecessor()->GetPort());
+  }
+  
+}
+
+
+bool
+ChordIpv4::FindVNode (std::string vNodeName, Ptr<ChordVNode>& virtualNode)
+{
+  Ptr<ChordNode> chordNode; 
+  if (m_vNodeMap.FindNode(vNodeName, chordNode) != true)
+  {
+    return false;
+  }
+  virtualNode = DynamicCast<ChordVNode>(chordNode);
+  return true;
+}
+
+
+/******* Diagnostics  *******/
+void
+ChordIpv4::DumpVNodeInfo(std::string vNodeName, std::ostream &os)
+{
+  Ptr<ChordVNode> virtualNode;
+  bool ret = FindVNode(vNodeName, virtualNode);
+  if (ret == true)
+  {
+    //Dump stats
+    os << "**** Info for VNode: " << virtualNode->GetVNodeName() << " ****\n";
+    os << "Local IP: " << m_localIpAddress << "\n";
+    os << "Local Port: " << m_listeningPort << "\n";
+    os << "VNode Identifier: " << virtualNode->GetChordIdentifier() << "\n";
+    os << "Successor Ip: " << virtualNode->GetSuccessor()->GetIpAddress() << "\n";
+    os << "Successor Port: " << virtualNode->GetSuccessor()->GetPort() << "\n";
+    os << "Successor Identifier: " << virtualNode->GetSuccessor()->GetChordIdentifier() << "\n";
+
+    os << "Predecessor Ip: " << virtualNode->GetPredecessor()->GetIpAddress() << "\n";
+    os << "Predecessor Port: " << virtualNode->GetPredecessor()->GetPort() << "\n";
+    os << "Predecessor Identifier: " << virtualNode->GetPredecessor()->GetChordIdentifier() << "\n";
+
+    virtualNode -> PrintSuccessorList (os);
+    virtualNode -> PrintPredecessorList (os);
+    virtualNode -> PrintFingerTable (os);
+    //virtualNode -> PrintFingerIdentifierList (os);
+    os << "Fingers actually looked up: " << virtualNode->GetStats().fingersLookedUp << "\n";
+  }
+  else
+  {
+    os << "No Such VNode Exists" << "\n";
+  }
+}
+
+void
+ChordIpv4::DumpDHashInfo (std::ostream &os)
+{
+  m_dHashIpv4->DumpDHashInfo(os);
+}
+
+void
+ChordIpv4::FixFingers (std::string vNodeName)
+{
+  Ptr<ChordVNode> virtualNode;
+  bool ret = FindVNode(vNodeName, virtualNode);
+  if (ret == true)
+  {
+    DoFixFinger(virtualNode);
+  }
+}
+
+void
+ChordIpv4::FireTraceRing (std::string vNodeName)
+{
+  Ptr<ChordVNode> virtualNode;
+  bool ret = FindVNode(vNodeName, virtualNode);
+  if (ret == true)
+  {
+    NotifyTraceRing(virtualNode->GetVNodeName(), virtualNode->GetChordIdentifier());
+    Ptr<Packet> packet = Create<Packet> ();
+    ChordMessage chordMessageFwd = ChordMessage ();
+    virtualNode->PackTraceRing(virtualNode, chordMessageFwd);
+    packet-> AddHeader (chordMessageFwd);
+    if (packet->GetSize())
+    {
+      NS_LOG_INFO ("Forwarding TraceRing: "<<chordMessageFwd);
+      SendPacket(packet, virtualNode->GetSuccessor()->GetIpAddress(), virtualNode->GetSuccessor()->GetPort());
+    }
+
+  }
+}
+
+void
+ChordIpv4::ProcessTraceRing(ChordMessage chordMessage)
+{
+  //Make Up-call
+  NS_LOG_FUNCTION_NOARGS ();
+  Ptr<ChordNode> requestorNode = chordMessage.GetRequestorNode();
+
+  //Read payload and get vnode identifier
+  Ptr<ChordIdentifier> vNodeIdentifier = chordMessage.GetTraceRing().successorIdentifier;
+
+  //Find VNode
+  Ptr<ChordVNode> virtualNode;
+  bool ret = FindVNode(vNodeIdentifier, virtualNode);
+  if (ret == false)
+  {
+    //VNode does not exist here, drop packet
+    return;
+  }
+  NotifyTraceRing(virtualNode->GetVNodeName(), virtualNode->GetChordIdentifier());
+  //Forward Trace Ring
+  //Originator has to remove the packet
+  if (requestorNode->GetChordIdentifier()->IsEqual(vNodeIdentifier))
+  {
+    return;
+  }
+  Ptr<Packet> packet = Create<Packet> ();
+  ChordMessage chordMessageFwd = ChordMessage ();
+  virtualNode->PackTraceRing(requestorNode, chordMessageFwd);
+  packet-> AddHeader (chordMessageFwd);
+  if (packet->GetSize())
+  {
+    NS_LOG_INFO ("Forwarding TraceRing: "<<chordMessageFwd);
+    SendPacket(packet, virtualNode->GetSuccessor()->GetIpAddress(), virtualNode->GetSuccessor()->GetPort());
+  }
+
+}
+
+
+
+} //namespace ns3
Index: src/applications/chord-ipv4/chord-ipv4.h
===================================================================
new file mode 100644
--- /dev/null
+++ b/src/applications/chord-ipv4/chord-ipv4.h
@@ -0,0 +1,405 @@
+/* -*-  Mode: C++; c-file-style: "gnu"; indent-tabs-mode:nil; -*- */
+/*
+ * Copyright (c) 2009 University of Pennsylvania
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation;
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#ifndef CHORD_IPV4_H
+#define CHORD_IPV4_H
+
+#include "ns3/application.h"
+#include "ns3/event-id.h"
+#include "ns3/ptr.h"
+#include "ns3/ipv4-address.h"
+#include "ns3/traced-callback.h"
+#include "ns3/timer.h"
+#include "chord-identifier.h"
+#include "chord-node.h"
+#include "chord-vnode.h"
+#include "chord-message.h"
+#include "chord-node-table.h"
+#include "dhash-ipv4.h"
+
+/* Static defines */
+// m = 160 bits i.e. 20 bytes
+#define DEFAULT_CHORD_IDENTIFIER_BYTES 20
+//Stabilize interval
+#define DEFAULT_STABILIZE_INTERVAL 500
+//Heartbeat interval
+#define DEFAULT_HEARTBEAT_INTERVAL 500
+//Fix Finger interval
+#define DEFAULT_FIX_FINGER_INTERVAL 10000
+// Max missed keep alives (Stabilize and Heartbeat)
+#define DEFAULT_MAX_MISSED_KEEP_ALIVES 4
+//Request timeout
+#define DEFAULT_REQUEST_TIMEOUT 1000
+//Max request retries
+#define DEFAULT_MAX_REQUEST_RETRIES 3
+//Max Successor List Size
+#define DEFAULT_MAX_VNODE_SUCCESSOR_LIST_SIZE 8
+//Max Predecessor List Size
+#define DEFAULT_MAX_VNODE_PREDECESSOR_LIST_SIZE 8
+
+
+namespace ns3 {
+
+class Socket;
+class Packet;
+
+/**  
+ *  \ingroup applications
+ *  \defgroup chordipv4 ChordIpv4
+ */
+
+/**
+ *  \ingroup chordipv4
+ *  \brief Implementation of Chord/DHash DHT (http://pdos.csail.mit.edu/chord/)
+ *
+ *  Provides API for Configuring and Operating Chord/DHash DHT
+ *
+ */
+
+class ChordIpv4 : public Application
+{
+  public:
+    static TypeId GetTypeId (void);
+  
+    ChordIpv4 ();
+
+    virtual ~ChordIpv4 ();
+
+
+
+    /* Application interface (ChordIpv4 Service User) */
+    
+    /**
+     *  \brief Create and Insert VirtualNode(ChordVNode) in Chord overlay network
+     *  \param vNodeName Name of VirtualNode(ChordVNode). ChordIpv4 layer makes upcalls based on both VirtualNode(ChordVNode) name as well as key
+     * \param key Pointer to key array (VirtualNode(ChordVNode) identifier)
+     * \param keyBytes Number of bytes in key (max 255)
+     *
+     * On invocation, Join request is sent to Boot Strap node (default). If VirtualNode(ChordVNode)(s) already exist on local physical node, then Join Request is sent via node closest (in terms of identifier distance) to the VirtualNode(ChordVNode) identifier. 
+     * A Chord VirtualNode(ChordVNode) (which is already part of the network), on receiving Join Request responds if the identifier of requesting node lies under its purview <lies in range (n.predecessor, n]> . If the identifier of requestor is out of purview then the request is forwarded to nearest remote node.
+     *
+     * On reception of Join Response, ChordIpv4 makes upcall to application if callback is function is set via SetJoinSuccessCallback. Please Note that this notification upcall is made even before initial stabilization (actual insertion into network) procedure. This upcall merely states that lookup involved with Join procedure was a success and possible successor was resolved.
+     *
+     * This request is retransmitted later in case response is not received on time (configurable). ChordIpv4 gives up retransmission after configurable number of retries.
+     *
+     * On failure to resolve successor (e.g. boot strap node is down) after a few retries, ChordIpv4 makes notification upcall to function registered via SetInsertFailureCallback by user. On Join failure, VirtualNode(ChordVNode) object is deleted from ChordIpv4 layer.
+     */
+
+    void InsertVNode (std::string vNodeName, uint8_t * key, uint8_t keyBytes);
+    /**
+     *  \brief Lookup owner node of an identifier in Chord Network
+     *  \param key Pointer to key array (identifier)
+     *  \param lookupKeyBytes Number of bytes in key (max 255)
+     *
+     *  On invocation, ChordIpv4 layer sends Lookup Request via VirtualNode(ChordVNode) closest to requested identifer (if it is not owner). 
+     *  A VirtualNode(ChordVNode) which is owner of reqested identifier responds with its IP address and Application Port. On reception of Response, a notification upcall is made to the function registered via SetLookupSuccessCallback. 
+     * This request is retransmitted later in case response is not received on time (configurable). ChordIpv4 gives up retransmission after configurable number of retries.
+     * On failure to resolve identifier, ChordIpv4 makes a notification upcall to function registered via SetLookupFailureCallback by user.
+     */
+
+    void LookupKey (uint8_t * lookupKey, uint8_t lookupKeyBytes);
+    /**
+    *  \brief Check whether the any VirtualNode(ChordVNode) running on local physical node owns particular identifier.
+    *  \param key Pointer to key array (identifier)
+    *  \param lookupKeyBytes Number of bytes in key (max 255)
+    *
+    *  \returns true if local ChordIpv4 is owner of identifier, false if local ChordIpv4 is not owner.
+    *
+    *  On invocation, ChordIpv4 layer checks and returns ownership status of given identifier.
+    */
+
+    bool CheckOwnership (uint8_t * lookupKey, uint8_t lookupKeyBytes);
+    /**
+     *  \brief Remove VirtualNode(ChordVNode) from Chord Network
+     *  \param vNodeName Name of VirtualNode(ChordVNode)
+     *
+     *  On invocation, ChordIpv4 layer removes given VirtualNode(ChordVNode) from the Chord Network. Leave Requests are sent to successor and predecessor of the given VirtualNode(ChordVNode), notifying them of removal. 
+     *  On receiving a Leave Request, successor node sends back Leave Response. When Leave Response is received back, ChordIpv4 layer triggers DHash (DHashIpv4) layer to transfer stored DHashObjects belonging to given VirtualNode(ChordVNode) to its successor. 
+     *
+     */    
+    void RemoveVNode (std::string vNodeName);
+    /**
+     *  \brief Registers Callback function for Join Success Notifications.
+     *  \param joinSuccessFn Callback function
+     */
+    void SetJoinSuccessCallback (Callback <void, std::string , uint8_t*, uint8_t> joinSuccessFn);
+    /**
+     *  \brief Registers Callback function for Lookup Success Notifications.
+     *  \param lookupSuccessFn This Callback is passed vNodeName, key and numBytes of key as parameters.
+     */
+    void SetLookupSuccessCallback (Callback <void, uint8_t*, uint8_t, Ipv4Address, uint16_t> lookupSuccessFn);
+    /**
+     *  \brief Registers Callback function for Lookup Failure Notifications.
+     *  \param lookupFailureFn This Callback is passed lookup key, numBytes of lookup key, resolved IP and resolved port as parameters.
+     */
+    void SetLookupFailureCallback (Callback <void, uint8_t*, uint8_t> lookupFailureFn);
+    /**
+     *  \brief Registers Callback function for VirtualNode(ChordVNode) key space ownership change notifications.
+     *  \param vNodeKeyOwnershipFn This Callback is passed vNodeName, vNode key, numBytes in vNode key, predecessor key, numBytes in predecessor key, oldPredecessor key, numBytes in oldPredecessor key, IP address of predecessor and application port of predecessor.
+     *
+     *  This upcall is made when predecessor of a VirtualNode(ChordVNode) changes (key space partitions).
+     *  A similar upcall is made to DHash (DHashIpv4) layer, prompting it to shift stored objects to new owner.
+     */
+    void SetVNodeKeyOwnershipCallback (Callback <void, std::string, uint8_t*, uint8_t, uint8_t*, uint8_t, uint8_t*, uint8_t, Ipv4Address, uint16_t> vNodeKeyOwnershipFn);
+    /**
+     *  \brief Registers Callback function for Trace Ring packet notification (Diagnostics packet)
+     *  \param traceRingFn This Callback is passed vNodeName, vNode key and numBytes in vNode key as parameters
+     */
+    void SetTraceRingCallback (Callback <void, std::string, uint8_t*, uint8_t> traceRingCallback);
+    /**
+     *  \brief Registers Callback function for VirtualNode(ChordVNode) failure notification
+     *  \param vNodeFailureCallback This Callback is passed vNodeName, vNode key and numBytes in vNode key as parameters
+     *  This upcall is made when all successors of a VirtualNode(ChordVNode) fail (stabilization failure) and it cannot stay in Chord Network anymore.
+     *  Please note that a bootstrap node (a VirtualNode(ChordVNode) which bootstrapped itself and created a new chord network) will never make this upcall or leave Chord Network.
+     */
+    void SetVNodeFailureCallback (Callback <void, std::string, uint8_t*, uint8_t> vNodeFailureCallbackFn);
+    //DHash (DHashIpv4) Callbacks
+    /**
+     *  \brief Registers Callback function for DHashObject Insert Success notification 
+     *  \param insertSuccessFn This Callback is passed object key, numBytes in object key, object array and numBytes in object array as parameters.
+     *
+     *  This upcall is made when DHash (DHashIpv4) layer has succesfully stored the requested object in the Chord Network
+     */
+    void SetInsertSuccessCallback (Callback <void, uint8_t*, uint8_t, uint8_t*, uint32_t> insertSuccessFn);
+    /**
+     *  \brief Registers Callback function for DHashObject Retrieve Success notifications.
+     *  \param retrieveSuccessFn This Callback is passed object key, numBytes in object key, object array and numBytes in object array as parameters.
+     *
+     *  This upcall is made when DHash (DHashIpv4) layer has successfully retrieved object represented by requested key (identifier).
+     */
+    void SetRetrieveSuccessCallback (Callback <void, uint8_t*, uint8_t, uint8_t*, uint32_t> retrieveSuccessFn);
+    /**
+     *  \brief Registers Callback function for DHashObject Insert Failure notifications.
+     *  \param insertFailureFn This Callback is passed object key, numBytes in object key, object array and numBytes in object array as parameters.
+     *
+     *  This upcall is made when DHash (DHashIpv4) layer fails to store the requested object.
+     */
+    void SetInsertFailureCallback (Callback <void, uint8_t*, uint8_t, uint8_t*, uint32_t> insertFailureFn); 
+    /**
+     *  \brief Registers Callback function for DHashObject Retrieve Failure notifications.
+     *  \param retrieveFailureFn This Callback is passed object key and numBytes in object key as parameters.
+     *
+     *  This upcall is made when DHash (DHashIpv4) layer fails to retrieve the object represented by requested key (identifier).
+     */
+    void SetRetrieveFailureCallback (Callback <void, uint8_t*, uint8_t> retrieveFailureFn);
+
+    //DHash (DHashIpv4) application interface
+    /**
+     *  \cond
+     */
+    void DHashLookupKey (uint8_t * lookupKey, uint8_t lookupKeyBytes);
+    void SetDHashLookupSuccessCallback (Callback <void, uint8_t*, uint8_t, Ipv4Address, uint16_t>);
+    void SetDHashLookupFailureCallback (Callback <void, uint8_t*, uint8_t>);
+    void SetDHashVNodeKeyOwnershipCallback (Callback <void, uint8_t*, uint8_t, uint8_t*, uint8_t, uint8_t*, uint8_t, Ipv4Address, uint16_t>);
+
+    /**
+     *  \endcond
+     */
+    //DHash (DHashIpv4) User interface
+    /**
+     *  \brief Inserts an object into the Chord/DHash (DHashIpv4) network.
+     *  \param key Pointer to key array (identifier)
+     *  \param sizeOfKey Number of bytes in key (max 255)
+     *  \param object Pointer to object byte array
+     *  \param sizeOfObject Number of bytes of object (max 2^32 - 1)
+     *
+     *  On invocation, DHash (DHashIpv4) layer triggers lookup request in Chord Network to locate owner of given object identifier. 
+     *  On successful lookup, DHash (DHashIpv4) layer establishes TCP connection with owner node and transfers the given object. Application is then notified of success.
+     *  Application is also notified if storage fails (due to failed lookup etc.)
+     *  
+     *  DHash (DHashIpv4) layer also runs periodic auditing of objects after configurable interval. During audit, the layer checks ownership of each stored object and transfers any misplaced objects.
+     *
+     *  For transfer of objects, TCP connection is reused if it already exists with remote node. TCP connection(s) are torn down after configurable inactivity interval. 
+     *
+     */
+    void Insert (uint8_t *key, uint8_t sizeOfKey ,uint8_t *object,uint32_t sizeOfObject);
+    /**
+     *  \brief Retrieves object from Chord/DHash (DHashIpv4) network represented by given key (identifier)
+     *  \param key Pointer to key array (identifier)
+     *  \param sizeOfKey Number of bytes in key (max 255)
+     *
+     *  On invocation, DHash (DHashIpv4) layer triggers lookup request in Chord Network to locate owner of a given object identifier.
+     *  On successful lookup, DHash (DHashIpv4) layer establishes TCP connection with owner and requests transfer of object. On successful retrieval, application is notified of success and given the object pointer.
+     *  On failure to retrieve object (due to failed lookup, non-existent object etc.), application is notified of failure.
+     *
+     *  TCP connections are bounded by inactivity timer and failure is reported to application if object transfer stalls.
+     */
+    void Retrieve (uint8_t* key, uint8_t sizeOfKey);
+
+    //Diagnostics Interface
+    /**
+     *  \brief Dumps VirtualNode(ChordVNode) information
+     *  \param vNodeName VirtualNode(ChordVNode) name
+     *  \param os Output stream
+     */
+    void DumpVNodeInfo (std::string vNodeName, std::ostream &os);
+    /**
+     *  \brief Fires Trace Ring packet
+     *  \param vNodeName VirtualNode(ChordVNode) name
+     *
+     *  On invocation, a VirtualNode(ChordVNode) sends Trace Ring packet towards its successor. On reception of such a packet, application on that physical node is notified of reception and the packet is forwarded further. The originator of this packet removes it from the network once it has travelled around the ring. This packet can be used to trace the ring structure in simulator.
+     */
+    void FireTraceRing (std::string vNodeName);
+    /**
+     *  \brief Manually fix fingers
+     *  \param vNodeName VirtualNode(ChordVNode) name
+     */
+    void FixFingers (std::string vNodeName);
+    //DHash (DHashIpv4) Diagnostics 
+    /**
+     *  \brief Dumps DHash (DHashIpv4) layer information
+     *  \param os Output Stream
+     *
+     *  Dumps information regarding stored DHashObject (s), active transactions and number of active TCP connections
+     */
+    void DumpDHashInfo (std::ostream &os);
+
+  protected:
+    virtual void DoDispose (void);
+  private:
+    virtual void StartApplication (void);
+    virtual void StopApplication (void);
+
+    /**
+     *  \cond
+     */
+    bool m_dHashEnable;
+
+    Ptr<Socket> m_socket;
+    Ipv4Address m_bootStrapIp;
+    uint16_t m_bootStrapPort;
+    Ipv4Address m_localIpAddress;
+    uint16_t m_listeningPort;
+    uint16_t m_applicationPort;
+    uint16_t m_dHashPort;
+    Ptr<DHashIpv4> m_dHashIpv4;
+
+    uint8_t m_maxVNodeSuccessorListSize;
+    uint8_t m_maxVNodePredecessorListSize;
+
+    bool isBootStrapNode;
+
+    ChordNodeTable m_vNodeMap;
+
+    //Timers
+    Timer m_stabilizeTimer;
+    Time m_stabilizeInterval;
+    Timer m_heartbeatTimer;
+    Time m_heartbeatInterval;
+    Timer m_fixFingerTimer;
+    Time m_fixFingerInterval;
+  
+
+    Time m_requestTimeout;
+    Time m_dHashAuditObjectsTimeout;
+    Time m_dHashInactivityTimeout;
+    uint8_t m_maxMissedKeepAlives;
+
+    uint8_t m_maxRequestRetries;
+
+    void StabilizeTimerExpire();
+    void HeartBeatTimerExpire();
+
+    //Periodic task methods
+    void DoPeriodicStabilize();
+    void DoPeriodicHeartbeat();
+    void DoPeriodicFixFinger();
+
+    //Callbacks
+    Callback<void, std::string, uint8_t*, uint8_t> m_joinSuccessFn;
+    Callback<void, uint8_t*, uint8_t, Ipv4Address, uint16_t> m_lookupSuccessFn;
+    Callback<void, uint8_t*, uint8_t> m_lookupFailureFn;
+    Callback<void, std::string, uint8_t*, uint8_t, uint8_t*, uint8_t, uint8_t*, uint8_t, Ipv4Address, uint16_t> m_vNodeKeyOwnershipFn;
+    Callback<void, std::string, uint8_t*, uint8_t> m_traceRingFn;
+    Callback<void, std::string, uint8_t*, uint8_t> m_vNodeFailureFn;
+    //DHash (DHashIpv4) callbacks
+    Callback<void, uint8_t*, uint8_t, Ipv4Address, uint16_t> m_dHashLookupSuccessFn;
+    Callback<void, uint8_t*, uint8_t> m_dHashLookupFailureFn;
+
+    //dHash-user Interface callbacks
+    Callback<void, uint8_t*, uint8_t, uint8_t*, uint32_t> m_insertSuccessFn;
+    Callback<void, uint8_t*, uint8_t, uint8_t*, uint32_t> m_retrieveSuccessFn;
+    Callback<void, uint8_t*, uint8_t, uint8_t*, uint32_t> m_insertFailureFn;
+    Callback<void, uint8_t*, uint8_t> m_retrieveFailureFn;
+    Callback <void, uint8_t*, uint8_t, uint8_t*, uint8_t, uint8_t*, uint8_t, Ipv4Address, uint16_t> m_dHashVNodeKeyOwnershipFn;
+
+    //Upcall (notify) methods
+    void NotifyJoinSuccess (std::string vNodeName, Ptr<ChordIdentifier> chordIdentifier);
+    void NotifyLookupSuccess (Ptr<ChordIdentifier> lookupIdentifier, Ptr<ChordNode> resolvedNode, ChordTransaction::Originator originator);
+    void NotifyLookupFailure (Ptr<ChordIdentifier> chordIdentifier, ChordTransaction::Originator originator);
+    void NotifyVNodeKeyOwnership (std::string vNodeName, Ptr<ChordIdentifier> chordIdentifier, Ptr<ChordNode> predecessorNode, Ptr<ChordIdentifier> oldPredecessorIdentifier);
+    void NotifyTraceRing (std::string vNodeName, Ptr<ChordIdentifier> chordIdentifier);
+    void NotifyVNodeFailure (std::string vNodeName, Ptr<ChordIdentifier> chordIdentifier);
+    //DHash (DHashIpv4) Notifications
+    void NotifyDHashLookupSuccess (Ptr<ChordIdentifier> lookupIdentifier, Ipv4Address ipAddress, uint16_t port);
+    void NotifyDHashLookupFailure (Ptr<ChordIdentifier> chordIdentifier);
+    //DHash (DHashIpv4) User Notifications
+    void NotifyInsertSuccess (uint8_t* key, uint8_t keyBytes, uint8_t* object, uint32_t objectBytes);
+    void NotifyRetrieveSuccess (uint8_t* key, uint8_t keyBytes, uint8_t* object, uint32_t objectBytes);
+    void NotifyInsertFailure (uint8_t* key, uint8_t keyBytes, uint8_t* object, uint32_t objectBytes);
+    void NotifyRetrieveFailure (uint8_t* key, uint8_t keyBytes);
+
+    //Message processing methods
+    void ProcessUdpPacket (Ptr<Socket> socket);
+    void ProcessJoinReq (ChordMessage chordMessage);
+    void ProcessJoinRsp (ChordMessage chordMessage);
+    void ProcessLeaveReq (ChordMessage chordMessage);
+    void ProcessLeaveRsp (ChordMessage chordMessage);
+    void ProcessLookupReq (ChordMessage chordMessage);
+    void ProcessLookupRsp (ChordMessage chordMessage);
+    void ProcessStabilizeReq (ChordMessage chordMessage);
+    void ProcessStabilizeRsp (ChordMessage chordMessage);
+    void ProcessHeartbeatReq (ChordMessage chordMessage);
+    void ProcessHeartbeatRsp (ChordMessage chordMessage);
+    void ProcessFingerReq (ChordMessage chordMessage);
+    void ProcessFingerRsp (ChordMessage chordMessage);
+    void ProcessTraceRing (ChordMessage chordMessage);
+
+
+    void DoLookup (Ptr<ChordIdentifier> requestedIdentifier, ChordTransaction::Originator orginator);
+    void DoStabilize (Ptr<ChordVNode> virtualNode);
+    void DoHeartbeat (Ptr<ChordVNode> virtualNode);
+    void DoFixFinger (Ptr<ChordVNode> virtualNode);
+
+    bool FindVNode (Ptr<ChordIdentifier> chordIdentifier, Ptr<ChordVNode>& virtualNode);
+    bool FindVNode (std::string vNodeName, Ptr<ChordVNode>& virtualNode);
+    void DeleteVNode (Ptr<ChordIdentifier> chordIdentifier);
+    void DeleteVNode (std::string vNodeName);
+    bool LookupLocal (Ptr<ChordIdentifier> chordIdentifier, Ptr<ChordVNode>& virtualNode);
+    
+    //Send/Routing Methods
+    void SendPacket (Ptr<Packet> packet, Ipv4Address destinationIp, uint16_t destinationPort);
+    bool FindNearestVNode (Ptr<ChordIdentifier> targetIdentifier, Ptr<ChordVNode> &virtualNode);
+    bool SendViaAnyVNode (Ptr<Packet> packet);
+    bool RoutePacket (Ptr<ChordIdentifier> targetIdentifier, Ptr<Packet> packet);
+    bool RouteViaFinger (Ptr<ChordIdentifier> targetIdentifier, Ptr<ChordVNode> vNode, Ptr<Packet> packet);
+
+    //Timeouts
+    void HandleRequestTimeout (Ptr<ChordVNode> chordVNode, uint32_t transactionId);
+
+    //TODO: Trace call back(s)
+    /**
+     *  \endcond
+     */
+
+}; //class ChordIpv4
+
+} //namespace ns3
+
+#endif //CHORD_IPV4_H
+
Index: src/applications/chord-ipv4/chord-message.cc
===================================================================
new file mode 100644
--- /dev/null
+++ b/src/applications/chord-ipv4/chord-message.cc
@@ -0,0 +1,737 @@
+/* -*-  Mode: C++; c-file-style: "gnu"; indent-tabs-mode:nil; -*- */
+/*
+ * Copyright (c) 2009 University of Pennsylvania
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation;
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#include "chord-message.h"
+#include "ns3/log.h"
+
+
+namespace ns3 {
+
+NS_LOG_COMPONENT_DEFINE("ChordMessage");
+
+NS_OBJECT_ENSURE_REGISTERED (ChordMessage);
+
+ChordMessage::ChordMessage ()
+{
+  m_transactionId = 0;
+}
+
+ChordMessage::~ChordMessage ()
+{}
+
+TypeId
+ChordMessage::GetTypeId (void)
+{
+  static TypeId tid = TypeId ("ns3::ChordMessage")
+    .SetParent<Header> ()
+    .AddConstructor<ChordMessage> ()
+    ;
+  return tid;
+
+}
+
+TypeId
+ChordMessage::GetInstanceTypeId (void) const
+{
+  return GetTypeId ();
+}
+
+uint32_t
+ChordMessage::GetSerializedSize (void) const
+{
+  uint32_t size = sizeof (uint8_t) + sizeof (uint32_t) + sizeof(uint8_t) + m_chordNode->GetSerializedSize();
+  switch (m_messageType)
+  {
+    case JOIN_REQ:
+      size += m_message.joinReq.GetSerializedSize ();
+      break;
+    case JOIN_RSP:
+      size += m_message.joinRsp.GetSerializedSize ();
+      break;
+    case LEAVE_REQ:
+      size += m_message.leaveReq.GetSerializedSize();
+      break;
+    case LEAVE_RSP:
+      size += m_message.leaveRsp.GetSerializedSize();
+      break;
+    case STABILIZE_REQ:
+      size += m_message.stabilizeReq.GetSerializedSize ();
+      break;
+    case STABILIZE_RSP:
+      size += m_message.stabilizeRsp.GetSerializedSize ();
+      break;
+    case FINGER_REQ:
+      size += m_message.fingerReq.GetSerializedSize ();
+      break;
+    case FINGER_RSP:
+      size += m_message.fingerRsp.GetSerializedSize ();
+      break;
+    case HEARTBEAT_REQ:
+      size += m_message.heartbeatReq.GetSerializedSize ();
+      break;
+    case HEARTBEAT_RSP:
+      size += m_message.heartbeatRsp.GetSerializedSize ();
+      break;
+    case LOOKUP_REQ:
+      size += m_message.lookupReq.GetSerializedSize ();
+      break;
+    case LOOKUP_RSP:
+      size += m_message.lookupRsp.GetSerializedSize ();
+      break;
+     case TRACE_RING:
+      size += m_message.traceRing.GetSerializedSize ();
+      break;
+    default:
+      NS_ASSERT (false);
+  }
+  return size;
+}
+
+void
+ChordMessage::Print (std::ostream &os) const
+{
+  os << "\n***ChordMessage Dump***\n";
+  os << "Header:: \n";
+  os << "MessageType: " << m_messageType<<"\n";
+  os << "TransactionId: " << m_transactionId<<"\n";
+  os << "Requestor Node: " << "\n";
+  m_chordNode->Print (os);
+  os << "TTL : " << m_ttl << "\n";
+  os << "Payload:: \n";
+  switch (m_messageType)
+  {
+    case JOIN_REQ:
+      m_message.joinReq.Print (os);
+      break;
+    case JOIN_RSP:
+      m_message.joinRsp.Print (os);
+      break;
+    case LEAVE_REQ:
+      m_message.leaveReq.Print (os);
+      break;
+    case LEAVE_RSP:
+      m_message.leaveRsp.Print (os);
+      break;
+    case STABILIZE_REQ:
+      m_message.stabilizeReq.Print (os);
+      break;
+    case STABILIZE_RSP:
+      m_message.stabilizeRsp.Print (os);
+      break;
+    case FINGER_REQ:
+      m_message.fingerReq.Print (os);
+      break;
+    case FINGER_RSP:
+      m_message.fingerRsp.Print (os);
+      break;
+    case HEARTBEAT_REQ:
+      m_message.heartbeatReq.Print (os);
+      break;
+    case HEARTBEAT_RSP:
+      m_message.heartbeatRsp.Print (os);
+      break;
+    case LOOKUP_REQ:
+      m_message.lookupReq.Print (os);
+      break;
+    case LOOKUP_RSP:
+      m_message.lookupRsp.Print (os);
+      break;
+    case TRACE_RING:
+      m_message.traceRing.Print (os);
+      break;
+    default:
+      break;
+  }
+  os << "\n***End Of Message***\n";
+}
+
+void
+ChordMessage::Serialize (Buffer::Iterator start) const
+{
+  Buffer::Iterator i = start;  
+  i.WriteU8 (m_messageType);
+  i.WriteU8  (m_ttl);
+  i.WriteHtonU32 (m_transactionId);
+  m_chordNode->Serialize(i);
+  switch (m_messageType)
+  {
+    case JOIN_REQ:
+      m_message.joinReq.Serialize (i);
+      break;
+    case JOIN_RSP:
+      m_message.joinRsp.Serialize (i);
+      break;
+    case LEAVE_REQ:
+      m_message.leaveReq.Serialize (i);
+      break;
+    case LEAVE_RSP:
+      m_message.leaveRsp.Serialize (i);
+      break;
+    case STABILIZE_REQ:
+      m_message.stabilizeReq.Serialize (i);
+      break;
+    case STABILIZE_RSP:
+      m_message.stabilizeRsp.Serialize (i);
+      break;
+    case FINGER_REQ:
+      m_message.fingerReq.Serialize (i);
+      break;
+    case FINGER_RSP:
+      m_message.fingerRsp.Serialize (i);
+      break;
+    case HEARTBEAT_REQ:
+      m_message.heartbeatReq.Serialize (i);
+      break;
+    case HEARTBEAT_RSP:
+      m_message.heartbeatRsp.Serialize (i);
+      break;
+    case LOOKUP_REQ:
+      m_message.lookupReq.Serialize (i);
+      break;
+    case LOOKUP_RSP:
+      m_message.lookupRsp.Serialize (i);
+      break;
+    case TRACE_RING:
+      m_message.traceRing.Serialize (i);
+      break;
+    default:
+      NS_ASSERT (false);
+  }
+}
+
+uint32_t
+ChordMessage::Deserialize (Buffer::Iterator start)
+{
+  uint32_t size;
+  Buffer::Iterator i = start;
+  m_messageType = (MessageType) i.ReadU8 ();
+  m_ttl = i.ReadU8 ();
+  m_transactionId = i.ReadNtohU32 ();
+  m_chordNode = Create<ChordNode> ();
+  m_chordNode->Deserialize (i);
+  size = sizeof (uint8_t) + sizeof (uint32_t) + sizeof(uint8_t) + m_chordNode->GetSerializedSize();
+
+  switch (m_messageType)
+  {
+    case JOIN_REQ:
+      size += m_message.joinReq.Deserialize (i);
+      break;
+    case JOIN_RSP:
+      size += m_message.joinRsp.Deserialize (i);
+      break;
+    case LEAVE_REQ:
+      size += m_message.leaveReq.Deserialize (i);
+      break;
+    case LEAVE_RSP:
+      size += m_message.leaveRsp.Deserialize (i);
+      break;
+    case STABILIZE_REQ:
+      size += m_message.stabilizeReq.Deserialize (i);
+      break;
+    case STABILIZE_RSP:
+      size += m_message.stabilizeRsp.Deserialize (i);
+      break;
+    case FINGER_REQ:
+      size += m_message.fingerReq.Deserialize (i);
+      break;
+    case FINGER_RSP:
+      size += m_message.fingerRsp.Deserialize (i);
+      break;
+    case HEARTBEAT_REQ:
+      size += m_message.heartbeatReq.Deserialize (i);
+      break;
+    case HEARTBEAT_RSP:
+      size += m_message.heartbeatRsp.Deserialize (i);
+      break;
+    case LOOKUP_REQ:
+      size += m_message.lookupReq.Deserialize (i);
+      break;
+    case LOOKUP_RSP:
+      size += m_message.lookupRsp.Deserialize (i);
+      break;
+    case TRACE_RING:
+      size += m_message.traceRing.Deserialize (i);
+      break;
+    default:
+      NS_ASSERT (false);
+  }
+  return size;
+}
+
+/* Message Payloads */
+
+/* JOIN_REQ */
+uint32_t
+ChordMessage::JoinReq::GetSerializedSize (void) const
+{
+  uint32_t size;
+  size = 0;
+  return size; 
+}
+
+void
+ChordMessage::JoinReq::Print (std::ostream &os) const
+{
+  os << "JoinReq: \nNONE\n";
+}
+
+void
+ChordMessage::JoinReq::Serialize (Buffer::Iterator &start) const
+{
+}
+
+uint32_t
+ChordMessage::JoinReq::Deserialize (Buffer::Iterator &start)
+{
+  return GetSerializedSize ();
+}
+/* JOIN_RSP */
+uint32_t
+ChordMessage::JoinRsp::GetSerializedSize (void) const
+{
+  uint32_t size;
+  size = successorNode->GetSerializedSize();
+  return size; 
+}
+
+void
+ChordMessage::JoinRsp::Print (std::ostream &os) const
+{
+  os << "JoinRsp: \n";
+  os << "Successor Node: " << "\n";
+  successorNode->Print (os);
+}
+
+void
+ChordMessage::JoinRsp::Serialize (Buffer::Iterator &start) const
+{
+  successorNode->Serialize (start);
+}
+
+uint32_t
+ChordMessage::JoinRsp::Deserialize (Buffer::Iterator &start)
+{
+  successorNode = Create<ChordNode> ();
+  successorNode -> Deserialize (start);
+  return GetSerializedSize();
+}
+
+/* LEAVE_REQ */
+uint32_t
+ChordMessage::LeaveReq::GetSerializedSize (void) const
+{
+  uint32_t size;
+  size = successorNode->GetSerializedSize() + predecessorNode->GetSerializedSize();
+  return size; 
+}
+
+void
+ChordMessage::LeaveReq::Print (std::ostream &os) const
+{
+  os << "LeaveReq: \n";
+  os << "Successor Node: " << "\n";
+  successorNode->Print (os);
+  os << "Predecessor Node: " << "\n";
+  predecessorNode->Print (os);
+}
+
+void
+ChordMessage::LeaveReq::Serialize (Buffer::Iterator &start) const
+{
+  successorNode->Serialize (start);
+  predecessorNode->Serialize (start);
+}
+
+uint32_t
+ChordMessage::LeaveReq::Deserialize (Buffer::Iterator &start)
+{
+  successorNode = Create<ChordNode> ();
+  successorNode->Deserialize (start);
+  predecessorNode = Create<ChordNode> ();
+  predecessorNode->Deserialize (start);
+  return GetSerializedSize();
+}
+/* LEAVE_RSP */
+uint32_t
+ChordMessage::LeaveRsp::GetSerializedSize (void) const
+{
+  uint32_t size;
+  size = successorNode->GetSerializedSize() + predecessorNode->GetSerializedSize();
+  return size; 
+}
+
+void
+ChordMessage::LeaveRsp::Print (std::ostream &os) const
+{
+  os << "LeaveRsp: \n";
+  os << "Successor Node: " << "\n";
+  successorNode->Print (os);
+  os << "Predecessor Node: " << "\n";
+  predecessorNode->Print (os);
+}
+
+void
+ChordMessage::LeaveRsp::Serialize (Buffer::Iterator &start) const
+{
+  successorNode->Serialize (start);
+  predecessorNode->Serialize (start);
+}
+
+uint32_t
+ChordMessage::LeaveRsp::Deserialize (Buffer::Iterator &start)
+{
+  successorNode = Create<ChordNode> ();
+  successorNode->Deserialize (start);
+  predecessorNode = Create<ChordNode> ();
+  predecessorNode->Deserialize (start);
+  return GetSerializedSize();
+}
+
+
+/* STABILIZE_REQ */
+uint32_t
+ChordMessage::StabilizeReq::GetSerializedSize (void) const
+{
+  uint32_t size;
+  size = successorIdentifier->GetSerializedSize();
+  return size; 
+}
+
+void
+ChordMessage::StabilizeReq::Print (std::ostream &os) const
+{
+  os << "StabilizeReq: \n";
+  os << "successorIdentifier: " << successorIdentifier << "\n";
+}
+
+void
+ChordMessage::StabilizeReq::Serialize (Buffer::Iterator &start) const
+{
+  successorIdentifier->Serialize(start);
+}
+
+uint32_t
+ChordMessage::StabilizeReq::Deserialize (Buffer::Iterator &start)
+{
+  successorIdentifier = Create<ChordIdentifier> ();
+  successorIdentifier->Deserialize(start);
+  return GetSerializedSize ();
+}
+/* STABILIZE_RSP */
+uint32_t
+ChordMessage::StabilizeRsp::GetSerializedSize (void) const
+{
+  uint32_t size;
+  size = predecessorNode->GetSerializedSize() + sizeof (uint8_t);
+  for (std::vector<Ptr<ChordNode> >::const_iterator nodeIter = successorList.begin(); nodeIter != successorList.end(); nodeIter++)
+  {
+    Ptr<ChordNode> node = *nodeIter;
+    size = size + node->GetSerializedSize();
+  }
+  return size; 
+}
+
+void
+ChordMessage::StabilizeRsp::Print (std::ostream &os) const
+{
+  os << "StabilizeRsp: \n";
+  os << "Predecessor Node: " << "\n";
+  predecessorNode->Print (os);
+  os << "successorListSize: " << successorListSize << "\n";
+  for (std::vector<Ptr<ChordNode> >::const_iterator nodeIter = successorList.begin(); nodeIter != successorList.end(); nodeIter++)
+  {
+    Ptr<ChordNode> node = *nodeIter;
+    os << "***\n";
+    os << "Successor Node: " << "\n";
+    node->Print (os);
+  }
+}
+
+void
+ChordMessage::StabilizeRsp::Serialize (Buffer::Iterator &start) const
+{
+  predecessorNode->Serialize (start);
+  //Write successor list size
+  start.WriteU8(successorListSize);
+  //Write entire list
+  for (std::vector<Ptr<ChordNode> >::const_iterator nodeIter = successorList.begin(); nodeIter != successorList.end(); nodeIter++)
+  {
+    Ptr<ChordNode> node = *nodeIter;
+    node->Serialize (start);
+  }
+}
+
+uint32_t
+ChordMessage::StabilizeRsp::Deserialize (Buffer::Iterator &start)
+{
+  predecessorNode = Create<ChordNode> ();
+  predecessorNode->Deserialize (start);
+  //Deserialize successor list
+  successorListSize = start.ReadU8 ();
+  for (int i=0; i<successorListSize; i++)
+  {
+    //Store in list
+    Ptr<ChordNode> chordNode = Create<ChordNode> ();
+    chordNode->Deserialize (start);
+    successorList.push_back (chordNode);
+  }
+  return GetSerializedSize ();
+}
+/* FINGER_REQ */
+uint32_t
+ChordMessage::FingerReq::GetSerializedSize (void) const
+{
+  uint32_t size;
+  size = requestedIdentifier->GetSerializedSize();
+  return size; 
+}
+
+void
+ChordMessage::FingerReq::Print (std::ostream &os) const
+{
+  os << "FingerReq: \n";
+  os << "requestedIdentifier: " << requestedIdentifier << "\n";
+}
+
+void
+ChordMessage::FingerReq::Serialize (Buffer::Iterator &start) const
+{
+  requestedIdentifier->Serialize(start);
+}
+
+uint32_t
+ChordMessage::FingerReq::Deserialize (Buffer::Iterator &start)
+{
+  requestedIdentifier = Create<ChordIdentifier> ();
+  requestedIdentifier->Deserialize(start);
+  return GetSerializedSize ();
+}
+/* FINGER_RSP */
+uint32_t
+ChordMessage::FingerRsp::GetSerializedSize (void) const
+{
+  uint32_t size;
+  size = requestedIdentifier->GetSerializedSize() + fingerNode->GetSerializedSize();
+  return size; 
+}
+
+void
+ChordMessage::FingerRsp::Print (std::ostream &os) const
+{
+  os << "FingerRsp: \n";
+  os << "requestedIdentifier: " << requestedIdentifier << "\n";
+  os << "Finger Node: " << "\n";
+  fingerNode->Print (os);
+}
+
+void
+ChordMessage::FingerRsp::Serialize (Buffer::Iterator &start) const
+{
+  requestedIdentifier->Serialize(start);
+  fingerNode->Serialize (start);
+}
+
+uint32_t
+ChordMessage::FingerRsp::Deserialize (Buffer::Iterator &start)
+{
+  requestedIdentifier = Create<ChordIdentifier> ();
+  requestedIdentifier->Deserialize(start);
+  fingerNode = Create<ChordNode> ();
+  fingerNode->Deserialize (start);
+  return GetSerializedSize ();
+}
+/* HEARTBEAT_REQ */
+uint32_t
+ChordMessage::HeartbeatReq::GetSerializedSize (void) const
+{
+  uint32_t size;
+  size = predecessorIdentifier->GetSerializedSize();
+  return size; 
+}
+
+void
+ChordMessage::HeartbeatReq::Print (std::ostream &os) const
+{
+  os << "HeartbeatReq: \n";
+  os << "predecessorIdentifier: " << predecessorIdentifier << "\n";
+}
+
+void
+ChordMessage::HeartbeatReq::Serialize (Buffer::Iterator &start) const
+{
+  predecessorIdentifier->Serialize(start);
+}
+
+uint32_t
+ChordMessage::HeartbeatReq::Deserialize (Buffer::Iterator &start)
+{
+  predecessorIdentifier = Create<ChordIdentifier> ();
+  predecessorIdentifier->Deserialize(start);
+  return GetSerializedSize ();
+}
+
+/* HEARTBEAT_RSP */
+uint32_t
+ChordMessage::HeartbeatRsp::GetSerializedSize (void) const
+{
+  uint32_t size;
+  size = successorNode->GetSerializedSize() + sizeof(uint8_t);
+  for (std::vector<Ptr<ChordNode> >::const_iterator nodeIter = predecessorList.begin(); nodeIter != predecessorList.end(); nodeIter++)
+  {
+    Ptr<ChordNode> node = *nodeIter;
+    size = size + node->GetSerializedSize();
+  }
+  return size; 
+}
+
+void
+ChordMessage::HeartbeatRsp::Print (std::ostream &os) const
+{
+  os << "HeartbeatRsp: \n";
+  os << "Successor Node: " << "\n";
+  successorNode->Print (os);
+  for (std::vector<Ptr<ChordNode> >::const_iterator nodeIter = predecessorList.begin(); nodeIter != predecessorList.end(); nodeIter++)
+  {
+    Ptr<ChordNode> node = *nodeIter;
+    os << "***\n";
+    os << "Predecessor Node: " << "\n";
+    node->Print (os);
+  }
+}
+
+void
+ChordMessage::HeartbeatRsp::Serialize (Buffer::Iterator &start) const
+{
+  successorNode->Serialize(start);
+  //Write successor list size
+  start.WriteU8(predecessorListSize);
+  //Write entire list
+  for (std::vector<Ptr<ChordNode> >::const_iterator nodeIter = predecessorList.begin(); nodeIter != predecessorList.end(); nodeIter++)
+  {
+    Ptr<ChordNode> node = *nodeIter;
+    node->Serialize(start);
+  }
+}
+
+uint32_t
+ChordMessage::HeartbeatRsp::Deserialize (Buffer::Iterator &start)
+{
+  successorNode = Create<ChordNode> ();
+  successorNode->Deserialize(start);
+  //Deserialize successor list
+  predecessorListSize = start.ReadU8 ();
+  for (int i=0; i<predecessorListSize; i++)
+  {
+    //Store in list
+    Ptr<ChordNode> chordNode = Create<ChordNode> ();
+    chordNode->Deserialize(start);
+    predecessorList.push_back (chordNode);
+  }
+  return GetSerializedSize ();
+}
+
+/* LOOKUP_REQ */
+uint32_t
+ChordMessage::LookupReq::GetSerializedSize (void) const
+{
+  uint32_t size;
+  size = requestedIdentifier->GetSerializedSize();
+  return size; 
+}
+
+void
+ChordMessage::LookupReq::Print (std::ostream &os) const
+{
+  os << "LookupReq: \n";
+  os << "requestedIdentifier: " << requestedIdentifier << "\n";
+}
+
+void
+ChordMessage::LookupReq::Serialize (Buffer::Iterator &start) const
+{
+  requestedIdentifier->Serialize(start);
+}
+
+uint32_t
+ChordMessage::LookupReq::Deserialize (Buffer::Iterator &start)
+{
+  requestedIdentifier = Create<ChordIdentifier> ();
+  requestedIdentifier->Deserialize(start);
+  return GetSerializedSize ();
+}
+/* LOOKUP_RSP */
+uint32_t
+ChordMessage::LookupRsp::GetSerializedSize (void) const
+{
+  uint32_t size;
+  size = resolvedNode->GetSerializedSize();
+  return size; 
+}
+
+void
+ChordMessage::LookupRsp::Print (std::ostream &os) const
+{
+  os << "LookupRsp: \n";
+  os << "Resolved Node: " << "\n";
+  resolvedNode->Print (os);
+}
+
+void
+ChordMessage::LookupRsp::Serialize (Buffer::Iterator &start) const
+{
+  resolvedNode->Serialize (start);
+}
+
+uint32_t
+ChordMessage::LookupRsp::Deserialize (Buffer::Iterator &start)
+{
+  resolvedNode = Create<ChordNode> ();
+  resolvedNode->Deserialize (start);
+  return GetSerializedSize ();
+}
+
+/* TRACE_RING */
+uint32_t
+ChordMessage::TraceRing::GetSerializedSize (void) const
+{
+  uint32_t size;
+  size = successorIdentifier->GetSerializedSize();
+  return size; 
+}
+
+void
+ChordMessage::TraceRing::Print (std::ostream &os) const
+{
+  os << "TraceRing: \n";
+  os << "successorIdentifier: " << successorIdentifier << "\n";
+}
+
+void
+ChordMessage::TraceRing::Serialize (Buffer::Iterator &start) const
+{
+  successorIdentifier->Serialize(start);
+}
+
+uint32_t
+ChordMessage::TraceRing::Deserialize (Buffer::Iterator &start)
+{
+  successorIdentifier = Create<ChordIdentifier> ();
+  successorIdentifier->Deserialize(start);
+  return GetSerializedSize ();
+}
+} //namespace ns3
Index: src/applications/chord-ipv4/chord-message.h
===================================================================
new file mode 100644
--- /dev/null
+++ b/src/applications/chord-ipv4/chord-message.h
@@ -0,0 +1,674 @@
+/* -*-  Mode: C++; c-file-style: "gnu"; indent-tabs-mode:nil; -*- */
+/*
+ * Copyright (c) 2009 University of Pennsylvania
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation;
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#ifndef CHORD_MESSAGE_H
+#define CHORD_MESSAGE_H
+
+#include <vector>
+#include "ns3/header.h"
+#include "ns3/ipv4-address.h"
+#include "ns3/nstime.h"
+#include "ns3/assert.h"
+#include "chord-identifier.h"
+#include "chord-node.h"
+
+namespace ns3 {
+
+ /**  
+ * \ingroup chordipv4
+ * \class ChordMessage
+ * \brief Chord Protocol Messages
+ */
+class ChordMessage : public Header
+{
+  public:
+    enum MessageType {
+      JOIN_REQ = 1,
+      JOIN_RSP = 2,
+      STABILIZE_REQ = 3,
+      STABILIZE_RSP = 4,
+      FINGER_REQ = 5,
+      FINGER_RSP = 6,
+      HEARTBEAT_REQ = 7,
+      HEARTBEAT_RSP = 8,
+      LOOKUP_REQ = 9,
+      LOOKUP_RSP = 10,
+      LEAVE_REQ = 11,
+      LEAVE_RSP = 12,
+      TRACE_RING = 20,
+    };
+
+    ChordMessage ();
+    virtual ~ChordMessage ();
+
+    /**
+     *  \brief Sets message type
+     *  \param messageType message type
+     */
+    void SetMessageType (MessageType messageType)
+    {
+      m_messageType = messageType;
+    }
+    /**
+     *  \brief Sets transaction Id
+     *  \param transactionId transaction Id of request
+     */
+
+    void SetTransactionId (uint32_t transactionId)
+    {
+      m_transactionId = transactionId;
+    }
+    /**
+     *  \brief Sets TTL
+     *  \param ttl time to live before request is dropped
+     *  Coming Soon!
+     */
+    void SetTTL(uint8_t ttl)
+    {
+      m_ttl = ttl;
+    } 
+    /**
+     *  \returns message type
+     */
+
+    MessageType GetMessageType () const
+    {
+      return m_messageType;
+    }
+
+    /**
+     *  \returns transaction Id
+     */
+    uint32_t GetTransactionId (void)
+    {
+      return m_transactionId;
+    }
+    
+    /**
+     *  \brief Sets requestor node in message
+     *  \param chordNode Ptr of requesting ChordNode
+     */
+    void SetRequestorNode (Ptr<ChordNode> chordNode)
+    {
+      m_chordNode = chordNode;
+    }
+    /**
+     *  \returns Ptr to requestor ChordNode
+     */
+    Ptr<ChordNode> GetRequestorNode ()
+    {
+      return m_chordNode;
+    }
+    /**
+     *  \returns ttl of request
+     */
+    uint8_t GetTTL()
+    {
+      return m_ttl;
+    } 
+
+  private:
+    /**
+     *  \cond
+     */
+    MessageType m_messageType;
+    uint32_t m_transactionId;
+    Ptr<ChordNode> m_chordNode;
+    uint8_t m_ttl ;
+    /**
+     *  \endcond
+     */
+
+  public:
+    static TypeId GetTypeId (void);
+    TypeId GetInstanceTypeId (void) const;
+    /**
+     *  \brief Prints ChordMessage
+     *  \param os Output Stream
+     */
+    void Print (std::ostream &os) const;
+    /**
+     *  \returns Size in bytes of packed ChordMessage
+     */
+    uint32_t GetSerializedSize (void) const;
+    /**
+     *  \brief Packs ChordMessage
+     *  \param start Buffer::Iterator
+     *
+     *  \verbatim
+        Packed Structure:
+     
+        ChordMessage Header:
+     
+        0 1 2 3 4 5 6 7 8 
+        +-+-+-+-+-+-+-+-+
+        |  messageType  |
+        +-+-+-+-+-+-+-+-+
+        |     ttl       |
+        +-+-+-+-+-+-+-+-+
+        |               |
+        |               |
+        | transactionId |
+        |               |
+        +-+-+-+-+-+-+-+-+
+        |               |
+        : requestorNode :
+        |               |
+        +-+-+-+-+-+-+-+-+
+        |               | 
+        :   Payload     :
+        |               |
+        +-+-+-+-+-+-+-+-+
+     
+        JOIN_REQ Payload:
+        None
+      
+        JOIN_RSP Payload:
+        0 1 2 3 4 5 6 7 8 
+        +-+-+-+-+-+-+-+-+
+        |               |
+        : successorNode :
+        |               |
+        +-+-+-+-+-+-+-+-+
+      
+        LEAVE_REQ Payload:
+        0 1 2 3 4 5 6 7 8 
+        +-+-+-+-+-+-+-+-+
+        |               |
+        : successorNode :
+        |               |
+        +-+-+-+-+-+-+-+-+
+        |               |
+        :predecessorNode:
+        |               |
+        +-+-+-+-+-+-+-+-+
+     
+        LEAVE_RSP Payload:
+        0 1 2 3 4 5 6 7 8 
+        +-+-+-+-+-+-+-+-+
+        |               |
+        : successorNode :
+        |               |
+        +-+-+-+-+-+-+-+-+
+        |               |
+        :predecessorNode:
+        |               |
+        +-+-+-+-+-+-+-+-+
+      
+        STABILIZE_REQ Payload:
+        0 1 2 3 4 5 6 7 8 
+        +-+-+-+-+-+-+-+-+
+        |               |
+        : successor-    :
+        | Identifier    |
+        +-+-+-+-+-+-+-+-+
+      
+        STABILIZE_RSP Payload:
+        0 1 2 3 4 5 6 7 8 
+        +-+-+-+-+-+-+-+-+
+        |               |
+        :predecessorNode:
+        |               |
+        +-+-+-+-+-+-+-+-+
+        |               |
+        : successorNode :
+        |     List      |
+        +-+-+-+-+-+-+-+-+
+       
+        FINGER_REQ Payload:
+        0 1 2 3 4 5 6 7 8 
+        +-+-+-+-+-+-+-+-+
+        |               |
+        : requested-    :
+        | Identifier    |
+        +-+-+-+-+-+-+-+-+
+      
+        FINGER_RSP Payload:
+        0 1 2 3 4 5 6 7 8 
+        +-+-+-+-+-+-+-+-+
+        |               |
+        : requested-    :
+        | Identifier    |
+        +-+-+-+-+-+-+-+-+
+        |               |
+        :  fingerNode   :
+        |               |
+        +-+-+-+-+-+-+-+-+
+      
+        HEARTBEAT_REQ Payload:
+        0 1 2 3 4 5 6 7 8 
+        +-+-+-+-+-+-+-+-+
+        |               |
+        : predecessor-  :
+        | Identifier    |
+        +-+-+-+-+-+-+-+-+
+      
+        HEARTBEAT_RSP Payload:
+        0 1 2 3 4 5 6 7 8 
+        +-+-+-+-+-+-+-+-+
+        |               |
+        : successorNode :
+        |               |
+        +-+-+-+-+-+-+-+-+
+        |               |
+        :predecessorNode:
+        |     List      |
+        +-+-+-+-+-+-+-+-+
+     
+        LOOKUP_REQ Payload:
+        0 1 2 3 4 5 6 7 8 
+        +-+-+-+-+-+-+-+-+
+        |               |
+        : requestor-    :
+        | Identifier    |
+        +-+-+-+-+-+-+-+-+
+     
+        LOOKUP_RSP Payload:
+        0 1 2 3 4 5 6 7 8 
+        +-+-+-+-+-+-+-+-+
+        |               |
+        : resolvedNode  :
+        |               |
+        +-+-+-+-+-+-+-+-+
+     
+        TRACE_RING Payload:
+        0 1 2 3 4 5 6 7 8 
+        +-+-+-+-+-+-+-+-+
+        |               |
+        : successor-    :
+        | Identifier    |
+        +-+-+-+-+-+-+-+-+
+      
+        \endverbatim
+     */
+    void Serialize (Buffer::Iterator start) const;
+    /**
+     *  \brief Unpacks ChordMessage
+     *  \param start Buffer::Iterator 
+     */
+    uint32_t Deserialize (Buffer::Iterator start);
+
+   struct JoinReq
+    {
+      void Print (std::ostream &os) const; 
+      uint32_t GetSerializedSize (void) const;
+      void Serialize (Buffer::Iterator &start) const;
+      uint32_t Deserialize (Buffer::Iterator &start);
+    };
+
+    struct JoinRsp
+    {
+      Ptr<ChordNode> successorNode;
+      void Print (std::ostream &os) const; 
+      uint32_t GetSerializedSize (void) const;
+      void Serialize (Buffer::Iterator &start) const;
+      uint32_t Deserialize (Buffer::Iterator &start);
+    };
+
+    struct StabilizeReq
+    {
+      Ptr<ChordIdentifier> successorIdentifier;
+      void Print (std::ostream &os) const; 
+      uint32_t GetSerializedSize (void) const;
+      void Serialize (Buffer::Iterator &start) const;
+      uint32_t Deserialize (Buffer::Iterator &start);
+    };
+
+    struct StabilizeRsp
+    {
+      Ptr<ChordNode> predecessorNode;
+      uint8_t successorListSize;
+      std::vector<Ptr<ChordNode> > successorList;
+      void Print (std::ostream &os) const; 
+      uint32_t GetSerializedSize (void) const;
+      void Serialize (Buffer::Iterator &start) const;
+      uint32_t Deserialize (Buffer::Iterator &start);
+    };
+
+    struct FingerReq
+    {
+      Ptr<ChordIdentifier> requestedIdentifier;
+      void Print (std::ostream &os) const; 
+      uint32_t GetSerializedSize (void) const;
+      void Serialize (Buffer::Iterator &start) const;
+      uint32_t Deserialize (Buffer::Iterator &start);
+    };
+
+    struct FingerRsp
+    {
+      Ptr<ChordIdentifier> requestedIdentifier;
+      Ptr<ChordNode> fingerNode;
+      void Print (std::ostream &os) const; 
+      uint32_t GetSerializedSize (void) const;
+      void Serialize (Buffer::Iterator &start) const;
+      uint32_t Deserialize (Buffer::Iterator &start);
+    };
+
+    struct HeartbeatReq
+    {
+      Ptr<ChordIdentifier> predecessorIdentifier;
+      void Print (std::ostream &os) const; 
+      uint32_t GetSerializedSize (void) const;
+      void Serialize (Buffer::Iterator &start) const;
+      uint32_t Deserialize (Buffer::Iterator &start);
+    };
+
+    struct HeartbeatRsp
+    {
+      Ptr<ChordNode> successorNode;
+      uint8_t predecessorListSize;
+      std::vector<Ptr<ChordNode> > predecessorList;
+      void Print (std::ostream &os) const; 
+      uint32_t GetSerializedSize (void) const;
+      void Serialize (Buffer::Iterator &start) const;
+      uint32_t Deserialize (Buffer::Iterator &start);
+    };
+
+    struct LookupReq
+    {
+      Ptr<ChordIdentifier> requestedIdentifier;
+      void Print (std::ostream &os) const; 
+      uint32_t GetSerializedSize (void) const;
+      void Serialize (Buffer::Iterator &start) const;
+      uint32_t Deserialize (Buffer::Iterator &start);
+    };
+
+    struct LookupRsp
+    {
+      Ptr<ChordNode> resolvedNode;
+      void Print (std::ostream &os) const; 
+      uint32_t GetSerializedSize (void) const;
+      void Serialize (Buffer::Iterator &start) const;
+      uint32_t Deserialize (Buffer::Iterator &start);
+    };
+ 
+    struct LeaveReq
+    {
+      Ptr<ChordNode> successorNode;
+      Ptr<ChordNode> predecessorNode;
+      void Print (std::ostream &os) const; 
+      uint32_t GetSerializedSize (void) const;
+      void Serialize (Buffer::Iterator &start) const;
+      uint32_t Deserialize (Buffer::Iterator &start);
+    };
+
+    struct LeaveRsp
+    {
+      Ptr<ChordNode> successorNode;
+      Ptr<ChordNode> predecessorNode;
+      void Print (std::ostream &os) const;
+      uint32_t GetSerializedSize (void) const;
+      void Serialize (Buffer::Iterator &start) const;
+      uint32_t Deserialize (Buffer::Iterator &start);
+    };
+   
+    struct TraceRing
+    {
+      Ptr<ChordIdentifier> successorIdentifier;
+      void Print (std::ostream &os) const; 
+      uint32_t GetSerializedSize (void) const;
+      void Serialize (Buffer::Iterator &start) const;
+      uint32_t Deserialize (Buffer::Iterator &start);
+    };
+
+  private:
+    /**
+     *  \cond
+     */
+    struct
+    {
+      JoinReq joinReq;
+      JoinRsp joinRsp;
+      LeaveReq leaveReq;
+      LeaveRsp leaveRsp;
+      StabilizeReq stabilizeReq;
+      StabilizeRsp stabilizeRsp;
+      FingerReq fingerReq;
+      FingerRsp fingerRsp;
+      HeartbeatReq heartbeatReq;
+      HeartbeatRsp heartbeatRsp;
+      LookupReq lookupReq;
+      LookupRsp lookupRsp;
+      TraceRing traceRing;
+    } m_message;
+    /**
+     *  \endcond
+     */
+  public:
+
+    /**
+     *  \returns JoinReq structure
+     */    
+    JoinReq& GetJoinReq ()
+    {
+      if (m_messageType == 0)
+      {
+        m_messageType = JOIN_REQ;
+      }
+      else
+      {
+        NS_ASSERT (m_messageType == JOIN_REQ);
+      }
+      return m_message.joinReq;
+    }    
+
+    /**
+     *  \returns JoinRsp structure
+     */    
+    JoinRsp& GetJoinRsp ()
+    {
+      if (m_messageType == 0)
+      {
+        m_messageType = JOIN_RSP;
+      }
+      else
+      {
+        NS_ASSERT (m_messageType == JOIN_RSP);
+      }
+      return m_message.joinRsp;
+    }    
+
+    /**
+     *  \returns LeaveReq structure
+     */    
+    LeaveReq& GetLeaveReq ()
+    {
+      if (m_messageType == 0)
+      {
+        m_messageType = LEAVE_REQ;
+      }
+      else
+      {
+        NS_ASSERT (m_messageType == LEAVE_REQ);
+      }
+      return m_message.leaveReq;
+    }    
+
+    /**
+     *  \returns LeaveRsp structure
+     */    
+    LeaveRsp& GetLeaveRsp ()
+    {
+      if (m_messageType == 0)
+      {
+        m_messageType = LEAVE_RSP;
+      }
+      else
+      {
+        NS_ASSERT (m_messageType == LEAVE_RSP);
+      }
+      return m_message.leaveRsp;
+    }    
+   
+
+    /**
+     *  \returns StabilizeReq structure
+     */    
+    StabilizeReq& GetStabilizeReq ()
+    {
+      if (m_messageType == 0)
+      {
+        m_messageType = STABILIZE_REQ;
+      }
+      else
+      {
+        NS_ASSERT (m_messageType == STABILIZE_REQ);
+      }
+      return m_message.stabilizeReq;
+    }
+
+    /**
+     *  \returns StabilizeRsp structure
+     */    
+    StabilizeRsp& GetStabilizeRsp ()
+    {
+      if (m_messageType == 0)
+      {
+        m_messageType = STABILIZE_RSP;
+      }
+      else
+      {
+        NS_ASSERT (m_messageType == STABILIZE_RSP);
+      }
+      return m_message.stabilizeRsp;
+    }
+
+    /**
+     *  \returns FingerReq structure
+     */    
+    FingerReq& GetFingerReq ()
+    {
+      if (m_messageType == 0)
+      {
+        m_messageType = FINGER_REQ;
+      }
+      else
+      {
+        NS_ASSERT (m_messageType == FINGER_REQ);
+      }
+      return m_message.fingerReq;
+    }    
+
+    /**
+     *  \returns FingerRsp structure
+     */    
+    FingerRsp& GetFingerRsp ()
+    {
+      if (m_messageType == 0)
+      {
+        m_messageType = FINGER_RSP;
+      }
+      else
+      {
+        NS_ASSERT (m_messageType == FINGER_RSP);
+      }
+      return m_message.fingerRsp;
+    }
+
+    /**
+     *  \returns HeartbeatReq structure
+     */    
+    HeartbeatReq& GetHeartbeatReq ()
+    {
+      if (m_messageType == 0)
+      {
+        m_messageType = HEARTBEAT_REQ;
+      }
+      else
+      {
+        NS_ASSERT (m_messageType == HEARTBEAT_REQ);
+      }
+      return m_message.heartbeatReq;
+    }
+
+    /**
+     *  \returns HeartbeatRsp structure
+     */    
+    HeartbeatRsp& GetHeartbeatRsp ()
+    {
+      if (m_messageType == 0)
+      {
+        m_messageType = HEARTBEAT_RSP;
+      }
+      else
+      {
+        NS_ASSERT (m_messageType == HEARTBEAT_RSP);
+      }
+      return m_message.heartbeatRsp;
+    }
+
+    /**
+     *  \returns LookupReq structure
+     */    
+    LookupReq& GetLookupReq ()
+    {
+      if (m_messageType == 0)
+      {
+        m_messageType = LOOKUP_REQ;
+      }
+      else
+      {
+        NS_ASSERT (m_messageType == LOOKUP_REQ);
+      }
+      return m_message.lookupReq;
+    }
+
+    /**
+     *  \returns LookupRsp structure
+     */    
+    LookupRsp& GetLookupRsp ()
+    {
+      if (m_messageType == 0)
+      {
+        m_messageType = LOOKUP_RSP;
+      }
+      else
+      {
+        NS_ASSERT (m_messageType == LOOKUP_RSP);
+      }
+      return m_message.lookupRsp;
+    } 
+
+    /**
+     *  \returns TraceRing structure
+     */    
+    TraceRing& GetTraceRing ()
+    {
+      if (m_messageType == 0)
+      {
+        m_messageType = TRACE_RING;
+      }
+      else
+      {
+        NS_ASSERT (m_messageType == TRACE_RING);
+      }
+      return m_message.traceRing;
+    }    
+  
+}; //class ChordMessage
+
+static inline std::ostream& operator<< (std::ostream& os, const ChordMessage & message)
+{
+  message.Print (os);
+  return os;
+}
+
+
+} //namespace ns3
+
+#endif //CHORD_MESSAGE_H
Index: src/applications/chord-ipv4/chord-node-table.cc
===================================================================
new file mode 100644
--- /dev/null
+++ b/src/applications/chord-ipv4/chord-node-table.cc
@@ -0,0 +1,265 @@
+/* -*-  Mode: C++; c-file-style: "gnu"; indent-tabs-mode:nil; -*- */
+/*
+ * Copyright (c) 2009 University of Pennsylvania
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation;
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#include "stdlib.h"
+#include "chord-node-table.h"
+#include "ns3/log.h"
+#include "ns3/simulator.h"
+
+namespace ns3 {
+
+NS_LOG_COMPONENT_DEFINE ("ChordNodeTable");
+
+ChordNodeTable::ChordNodeTable ()
+{
+}
+
+ChordNodeTable::~ChordNodeTable()
+{
+}
+
+void
+ChordNodeTable::DoDispose()
+{
+  NS_LOG_FUNCTION_NOARGS ();
+  m_nodeMap.clear();
+  m_nodeNameMap.clear();
+}
+
+void
+ChordNodeTable::UpdateNode(Ptr<ChordNode> &chordNode)
+{
+  NS_LOG_FUNCTION_NOARGS ();
+  ChordIdentifier chordIdentifier = *(PeekPointer(chordNode->GetChordIdentifier()));
+  ChordNodeMap::iterator iterator = m_nodeMap.find (chordIdentifier);
+  if (iterator == m_nodeMap.end())
+  {
+    //add it
+    m_nodeMap.insert(std::make_pair(chordIdentifier, chordNode));
+    //Timestamp
+    chordNode->SetTimestamp(Simulator::Now());
+  }
+  else
+  {
+    //Update Time stamp
+    iterator->second->SetTimestamp(Simulator::Now());  
+  }
+  
+  //Name map
+  if (chordNode->GetName() == "")
+    return;
+
+  ChordNodeNameMap::iterator iter = m_nodeNameMap.find (chordNode->GetName());
+  if (iter == m_nodeNameMap.end())
+  {
+    //add it
+    m_nodeNameMap.insert(std::make_pair(chordNode->GetName(), chordNode));
+    //Timestamp
+    chordNode->SetTimestamp(Simulator::Now());
+  }
+  else
+  {
+    //Update Time stamp
+    iter->second->SetTimestamp(Simulator::Now());  
+  }
+
+  return;
+}
+
+bool
+ChordNodeTable::FindNode (Ptr<ChordIdentifier> &chordId, Ptr<ChordNode> &chordNode)
+{
+  NS_LOG_FUNCTION_NOARGS ();
+  ChordIdentifier chordIdentifier = *(PeekPointer(chordId));
+  ChordNodeMap::iterator iterator = m_nodeMap.find (chordIdentifier);
+  if (iterator == m_nodeMap.end())
+  {
+    return false;
+  }
+  chordNode = (*iterator).second;
+  return true;
+}
+
+bool
+ChordNodeTable::FindNode (std::string &name, Ptr<ChordNode> &chordNode)
+{
+  NS_LOG_FUNCTION_NOARGS ();
+  ChordNodeNameMap::iterator iterator = m_nodeNameMap.find (name);
+  if (iterator == m_nodeNameMap.end())
+  {
+    return false;
+  }
+  chordNode = (*iterator).second;
+  return true;
+}
+
+void
+ChordNodeTable::RemoveNode (Ptr<ChordIdentifier> &chordId)
+{
+  NS_LOG_FUNCTION_NOARGS ();
+  ChordIdentifier chordIdentifier = *(PeekPointer(chordId));
+  ChordNodeMap::iterator iterator = m_nodeMap.find (chordIdentifier);
+  if (iterator == m_nodeMap.end())
+  {
+    return;
+  }
+
+  //remove from name map
+  if (iterator->second->GetName() != "")
+  {
+    ChordNodeNameMap::iterator iter = m_nodeNameMap.find (iterator->second->GetName());
+    if (iter != m_nodeNameMap.end())
+    {
+      m_nodeNameMap.erase (iter);
+    }
+  }
+
+  m_nodeMap.erase (iterator);
+}
+
+void
+ChordNodeTable::RemoveNode (std::string &name)
+{
+  NS_LOG_FUNCTION_NOARGS ();
+  ChordNodeNameMap::iterator iterator = m_nodeNameMap.find (name);
+  if (iterator == m_nodeNameMap.end())
+  { 
+    return;
+  }
+
+  //remove from node table
+  ChordNodeMap::iterator iter = m_nodeMap.find (iterator->second->GetChordIdentifier());
+  if (iter != m_nodeMap.end())
+  {
+    m_nodeMap.erase (iter);
+  }
+
+  m_nodeNameMap.erase (iterator);
+}
+
+/*  Logic: We need to find node whose key is nearest to the requested key. Our aim is to minimize lookup hops.
+ *
+ *  Step 1: Iterate for all nodes and maximize identifier for nodes which satisfy: node lies inBetween (0,key] <closestNodeOnRight>
+ *  Step 2: If none found in step 1, send to node with highest key number <closestNodeOnLeft>
+ */
+
+bool
+ChordNodeTable::FindNearestNode (Ptr<ChordIdentifier> &targetIdentifier, Ptr<ChordNode> &chordNode)
+{
+  NS_LOG_FUNCTION_NOARGS ();
+  Ptr<ChordNode> closestNodeOnRight = 0;
+  Ptr<ChordNode> closestNodeOnLeft = 0;
+  Ptr<ChordNode> nearestNode = 0;
+  Ptr<ChordIdentifier> zeroIdentifier = Create<ChordIdentifier> ();
+  uint8_t* key;
+  key = (uint8_t *) malloc(sizeof(uint8_t) * targetIdentifier->GetNumBytes());
+  memset (key, 0 , targetIdentifier->GetNumBytes());
+  zeroIdentifier->SetKey (key, targetIdentifier->GetNumBytes());
+  free (key);
+
+  //Step: 1
+  for(ChordNodeMap::iterator nodeIter = m_nodeMap.begin(); nodeIter != m_nodeMap.end(); nodeIter++)
+  {
+    Ptr<ChordNode> node = (*nodeIter).second;
+    if (node->GetRoutable() == false)
+      continue;
+    if (node->GetChordIdentifier()->IsInBetween(zeroIdentifier, targetIdentifier))
+    {
+      if (closestNodeOnRight == 0)
+      {
+        //Initialize
+        closestNodeOnRight = node;
+      }
+      else if (node->GetChordIdentifier()->IsGreater(closestNodeOnRight->GetChordIdentifier()))
+      {
+        //Maximize
+        closestNodeOnRight = node;
+      }
+    }
+    //Store greatest key node as well
+    if (closestNodeOnLeft == 0)
+    {
+      //Initialize
+      closestNodeOnLeft = node;
+    }
+    else if (node->GetChordIdentifier()->IsGreater(closestNodeOnLeft->GetChordIdentifier()))
+    {
+      //Maximize
+      closestNodeOnLeft = node;
+    }
+  }
+  //Step 2:
+  if (closestNodeOnRight == 0)
+  {
+    if (closestNodeOnLeft != 0)
+    {
+      nearestNode = closestNodeOnLeft;
+    }
+    else
+    {
+      return false;
+    }
+  }
+  else if (closestNodeOnRight != 0)
+  {
+    nearestNode = closestNodeOnRight;
+  }
+  chordNode = nearestNode;
+  return true;
+}
+
+uint32_t
+ChordNodeTable::GetSize ()
+{
+  NS_LOG_FUNCTION_NOARGS ();
+  return m_nodeMap.size();
+}
+
+ChordNodeMap& 
+ChordNodeTable::GetMap()
+{
+  NS_LOG_FUNCTION_NOARGS ();
+  return m_nodeMap;
+}
+
+void
+ChordNodeTable::Clear()
+{
+  NS_LOG_FUNCTION_NOARGS ();
+  m_nodeMap.clear();
+  m_nodeNameMap.clear();
+}
+
+void
+ChordNodeTable::Audit (Time auditInterval)
+{
+  for (ChordNodeMap::iterator nodeIter = m_nodeMap.begin(); nodeIter != m_nodeMap.end(); )
+  {
+    Ptr<ChordNode> node = (*nodeIter).second;
+    if (node->GetTimestamp().GetMilliSeconds() + auditInterval.GetMilliSeconds() < Simulator::Now().GetMilliSeconds())
+    {
+      //Remove stale entry
+      m_nodeMap.erase (nodeIter++);
+    }
+    else
+      ++nodeIter;
+  }
+}
+
+} //namespace ns3
+
Index: src/applications/chord-ipv4/chord-node-table.h
===================================================================
new file mode 100644
--- /dev/null
+++ b/src/applications/chord-ipv4/chord-node-table.h
@@ -0,0 +1,126 @@
+/* -*-  Mode: C++; c-file-style: "gnu"; indent-tabs-mode:nil; -*- */
+/*
+ * Copyright (c) 2009 University of Pennsylvania
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation;
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#ifndef CHORD_NODE_TABLE_H
+#define CHORD_NODE_TABLE_H
+
+#include "chord-identifier.h"
+#include "chord-node.h"
+#include "ns3/object.h"
+#include <map>
+
+namespace ns3 {
+
+typedef std::map<ChordIdentifier, Ptr<ChordNode> > ChordNodeMap;
+typedef std::map<std::string, Ptr<ChordNode> > ChordNodeNameMap;
+
+/**
+ *  \ingroup chordipv4
+ *  \class ChordNodeTable
+ *  \brief Class to store and operate on ChordNode map
+ */
+
+class ChordNodeTable : public Object
+{
+  public:
+    /**
+     *  \brief Constructor
+     */
+    ChordNodeTable ();
+    virtual ~ChordNodeTable ();
+    virtual void DoDispose ();
+    /**
+     *  \brief Updates ChordNode in map
+     *  \param Ptr to ChordNode
+     *
+     *  Updates timestamp of already existing ChordNode with same identifier or adds new ChordNode to map
+     */
+    void UpdateNode (Ptr<ChordNode> &ChordNode);
+    /**
+     *  \brief Finds ChordNode based on ChordIdentifier
+     *  \param chordIdentifier ChordIdentifier of ChordNode to find
+     *  \param chordNode Ptr to ChordNode (return result)
+     *  \returns true if ChordNode was found in map, otherwise false
+     */
+    bool FindNode (Ptr<ChordIdentifier> &chordIdentifier, Ptr<ChordNode> &ChordNode);
+    /**
+     *  \brief Finds ChordNode based on ChordIdentifier
+     *  \param name Name of ChordNode to find
+     *  \param chordNode Ptr to ChordNode (return result)
+     *  \returns true if ChordNode was found in map, otherwise false
+     */
+    bool FindNode (std::string &name, Ptr<ChordNode> &chordNode);
+    /**
+     *  \brief Removes ChordNode
+     *  \param chordIdentifier Ptr to ChordIdentifier
+     */
+    void RemoveNode (Ptr<ChordIdentifier> &chordIdentifier);
+    /**
+     *  \brief Removes ChordNode
+     *  \param name Name of ChordNode
+     */
+    void RemoveNode (std::string &name);
+    /**
+     *  \brief Finds nearest ChordNode to the given identifier, taken on a circular space
+     *  \param targetIdentifier Ptr to target ChordIdentifier
+     *  \param chordNode Ptr to ChordNode (return result)
+     *  \returns true on success, otherwise false (if no ChordNode in map is routable)
+     */
+    bool FindNearestNode (Ptr<ChordIdentifier> &targetIdentifier, Ptr<ChordNode> &chordNode);
+    /**
+     *  \brief Removes all ChordNode's which have not been updated since auditInterval
+     *  \param auditInterval audit interval
+     */
+    void Audit (Time auditInterval);
+    /**
+     *  \brief Clears ChordNode map
+     */
+    void Clear();
+    /**
+     *  \returns Size of map
+     */
+    uint32_t GetSize ();
+    /**
+     *  \returns Map of ChordNode(s)
+     */
+    ChordNodeMap& GetMap();
+
+
+
+  private:
+    /**
+     *  \cond
+     */
+    ChordNodeMap m_nodeMap;
+    ChordNodeNameMap m_nodeNameMap;
+    /**
+     *  \endcond
+     */
+  
+
+}; //class ChordNodeTable  
+
+
+
+} //namespace ns3
+
+
+
+#endif
+
+
Index: src/applications/chord-ipv4/chord-node.cc
===================================================================
new file mode 100644
--- /dev/null
+++ b/src/applications/chord-ipv4/chord-node.cc
@@ -0,0 +1,188 @@
+/* -*-  Mode: C++; c-file-style: "gnu"; indent-tabs-mode:nil; -*- */
+/*
+ * Copyright (c) 2009 University of Pennsylvania
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation;
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#include "chord-node.h"
+#include "ns3/log.h"
+
+namespace ns3 {
+
+NS_LOG_COMPONENT_DEFINE ("ChordNode");  
+
+ChordNode::ChordNode (Ptr<ChordIdentifier> identifier, Ipv4Address address, uint16_t port, uint16_t applicationPort, uint16_t dHashPort)
+{
+  NS_LOG_FUNCTION_NOARGS();
+  m_identifier = Create<ChordIdentifier> (identifier);
+  m_address = address;
+  m_port = port;
+  m_applicationPort = applicationPort;
+  m_dHashPort = dHashPort;
+  m_name = "";
+  m_routable = true;
+}
+ChordNode::ChordNode (Ptr<ChordIdentifier> identifier, std::string name, Ipv4Address address, uint16_t port, uint16_t applicationPort, uint16_t dHashPort)
+{
+  NS_LOG_FUNCTION_NOARGS();
+  m_identifier = Create<ChordIdentifier>(identifier);
+  m_name = name;
+  m_address = address;
+  m_port = port;
+  m_applicationPort = applicationPort;
+  m_dHashPort = dHashPort;
+  m_routable = true;
+}
+
+ChordNode::ChordNode (const Ptr<ChordNode> chordNode)
+{
+  NS_LOG_FUNCTION_NOARGS();
+  m_identifier = Create<ChordIdentifier>(chordNode->GetChordIdentifier());
+  m_name = chordNode->GetName();
+  m_address = chordNode->GetIpAddress();
+  m_port = chordNode->GetPort();
+  m_applicationPort = chordNode->GetApplicationPort();
+  m_dHashPort = chordNode->GetDHashPort();
+  m_routable = true;
+}
+
+ChordNode::ChordNode ()
+{
+  NS_LOG_FUNCTION_NOARGS();
+  m_name = "";
+}
+
+ChordNode::~ChordNode ()
+{
+  NS_LOG_FUNCTION_NOARGS();
+}
+
+void
+ChordNode::DoDispose (void)
+{
+  NS_LOG_FUNCTION_NOARGS();
+  m_identifier->DoDispose();
+}
+
+void
+ChordNode::SetTimestamp (Time timestamp)
+{
+  NS_LOG_FUNCTION_NOARGS();
+  m_timestamp = timestamp;
+}
+
+void
+ChordNode::SetRoutable (bool routable)
+{
+  m_routable = routable;
+} 
+
+bool
+ChordNode::GetRoutable ()
+{
+  return m_routable;
+}
+
+Ipv4Address
+ChordNode::GetIpAddress (void)
+{
+  NS_LOG_FUNCTION_NOARGS();
+  return m_address;
+}
+
+uint16_t
+ChordNode::GetPort (void)
+{
+  NS_LOG_FUNCTION_NOARGS();
+  return m_port;
+}
+
+uint16_t
+ChordNode::GetApplicationPort ()
+{
+  NS_LOG_FUNCTION_NOARGS();
+  return m_applicationPort;
+}
+
+uint16_t
+ChordNode::GetDHashPort ()
+{
+  NS_LOG_FUNCTION_NOARGS();
+  return m_dHashPort;
+}
+
+Ptr<ChordIdentifier>
+ChordNode::GetChordIdentifier (void)
+{
+  NS_LOG_FUNCTION_NOARGS();
+  return m_identifier;
+}
+
+std::string
+ChordNode::GetName ()
+{
+  return m_name;
+}
+
+Time
+ChordNode::GetTimestamp (void)
+{
+  NS_LOG_FUNCTION_NOARGS();
+  return m_timestamp;
+}
+
+//Serialization
+uint32_t
+ChordNode::GetSerializedSize ()
+{
+  uint32_t size;
+  size = m_identifier->GetSerializedSize() + IPV4_ADDRESS_SIZE + sizeof(uint16_t) + sizeof (uint16_t) + sizeof (uint16_t);
+  return size;
+}
+
+void
+ChordNode::Serialize (Buffer::Iterator &start)
+{
+  m_identifier->Serialize (start);
+  start.WriteHtonU32 (m_address.Get());
+  start.WriteHtonU16 (m_port);
+  start.WriteHtonU16 (m_applicationPort);
+  start.WriteHtonU16 (m_dHashPort);
+}
+
+void
+ChordNode::Deserialize (Buffer::Iterator &start)
+{
+  m_identifier = Create<ChordIdentifier> ();
+  m_identifier->Deserialize (start);
+  m_address = Ipv4Address (start.ReadNtohU32());
+  m_port = start.ReadNtohU16 ();
+  m_applicationPort = start.ReadNtohU16 ();
+  m_dHashPort = start.ReadNtohU16 ();
+}
+
+void
+ChordNode::Print (std::ostream &os)
+{
+  if (m_name != "")
+    os << "Name: " << m_name << "\n";
+  os << "Identifier: " << m_identifier << "\n";
+  os << "IpAddress: " << m_address << "\n";
+  os << "Port: " << m_port << "\n";
+  os << "ApplicationPort: " << m_applicationPort << "\n";
+  os << "DHashPort: " << m_dHashPort << "\n";
+}
+
+} //namespace ns3
Index: src/applications/chord-ipv4/chord-node.h
===================================================================
new file mode 100644
--- /dev/null
+++ b/src/applications/chord-ipv4/chord-node.h
@@ -0,0 +1,176 @@
+/* -*-  Mode: C++; c-file-style: "gnu"; indent-tabs-mode:nil; -*- */
+/*
+ * Copyright (c) 2009 University of Pennsylvania
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation;
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#ifndef CHORD_NODE_H
+#define CHORD_NODE_H
+
+#include "ns3/object.h"
+#include "ns3/nstime.h"
+#include "ns3/buffer.h"
+#include "ns3/ipv4-address.h"
+#include "chord-identifier.h"
+
+namespace ns3 {
+#define IPV4_ADDRESS_SIZE 4
+
+/**
+ *  \ingroup chordipv4
+ *  \class ChordNode
+ *  \brief Class to store chord node information
+ */
+
+class ChordNode : public Object
+{
+  public:
+    /**
+     *  \brief Constructor
+     *  \param identifier Ptr to ChordIdentifier of chord node
+     *  \param name Name of chord node
+     *  \param address Ipv4Address of chord node
+     *  \param port Chord Protocol listening port (UDP)
+     *  \param applicationPort Port advertised by application using Chord/DHash
+     *  \param dhashPort DHash Protocol listening port (TCP)
+     */
+    ChordNode (Ptr<ChordIdentifier> identifier, Ipv4Address address, uint16_t port, uint16_t applicationPort, uint16_t dHashPort);
+    /**
+     *  \brief Constructor
+     *  \param identifier Ptr to ChordIdentifier of chord node
+     *  \param address Ipv4Address of chord node
+     *  \param port Chord Protocol listening port (UDP)
+     *  \param applicationPort Port advertised by application using Chord/DHash
+     *  \param dhashPort DHash Protocol listening port (TCP)
+     */
+    ChordNode (Ptr<ChordIdentifier> identifier, std::string name, Ipv4Address address, uint16_t port, uint16_t applicationPort, uint16_t dHashPort);
+    ChordNode ();
+    /**
+     *  \brief Copy constructor
+     *  \param chordNode Ptr of ChordNode to copy from
+     */
+    ChordNode (const Ptr<ChordNode> chordNode);
+
+    virtual ~ChordNode ();
+    virtual void DoDispose (void);
+
+    //storage
+    /**
+     *  \brief Sets timestamp of last update from remote ChordNode
+     *  \param timestamp timestamp
+     */
+    void SetTimestamp (Time timestamp);
+    /**
+     *  \brief Sets the routable flag.
+     *  \param routable routable flag
+     *  This node will not be selected for routing if this flag is false
+     */
+    void SetRoutable (bool routable);
+
+    //retrieval
+    /** 
+     *  \returns Ipv4Address of ChordNode
+     */
+    Ipv4Address GetIpAddress ();
+    /**
+     *  \returns port Chord Protocol listening port
+     */
+    uint16_t GetPort ();
+    /**
+     *  \returns applicationPort Port advertised by application running on top of Chord/DHash
+     */
+    uint16_t GetApplicationPort ();
+    /**
+     *  \returns dhashPort DHash Protocol listening port
+     */
+    uint16_t GetDHashPort ();
+    /**
+     *  \returns Ptr to ChordIdentifier of ChordNode
+     */
+    Ptr<ChordIdentifier> GetChordIdentifier();
+    /**
+     *  \returns Timestamp
+     */
+    Time GetTimestamp ();
+    /**
+     *  \returns Name of ChordNode
+     */
+    std::string GetName ();
+    /**
+     *  \returns Routable flag
+     */
+    bool GetRoutable ();
+    //Serialization
+    /**
+     *  \brief Packs ChordNode
+     *  \param start Buffer::Iterator
+     *
+     *  \verbatim
+        Packed Structure:
+        0 1 2 3 4 5 6 7 8 
+        +-+-+-+-+-+-+-+-+
+        |               |
+        |               |
+        |  Ipv4Address  |
+        |               |
+        +-+-+-+-+-+-+-+-+
+        |               |
+        |   Chord Port  |
+        +-+-+-+-+-+-+-+-+
+        |  Application  |
+        |     Port      |
+        +-+-+-+-+-+-+-+-+
+        |               |
+        |   DHash Port  |
+        +-+-+-+-+-+-+-+-+
+        \endverbatim
+     */
+    void Serialize (Buffer::Iterator &start);
+    /**
+     *  \brief Unpacks ChordNode
+     *  \param start Buffer::Iterator
+     */
+    void Deserialize (Buffer::Iterator &start);
+    /**
+     *  \returns Size of packed ChordNode
+     */
+    uint32_t GetSerializedSize ();
+    /**
+     *  \brief Prints ChordNode information
+     *  \param os Output stream
+     */
+    void Print (std::ostream &os);
+
+  private:
+    /**
+     *  \cond
+     */
+    Ptr<ChordIdentifier> m_identifier;
+    std::string m_name;
+    Ipv4Address m_address;
+    uint16_t m_port;
+    uint16_t m_applicationPort;
+    uint16_t m_dHashPort;
+    Time m_timestamp;
+    bool m_routable;
+    /**
+     *  \endcond
+     */
+
+}; //class ChordNode    
+
+} //namespace ns3
+
+#endif //CHORD_NODE_H
Index: src/applications/chord-ipv4/chord-transaction.cc
===================================================================
new file mode 100644
--- /dev/null
+++ b/src/applications/chord-ipv4/chord-transaction.cc
@@ -0,0 +1,138 @@
+/* -*-  Mode: C++; c-file-style: "gnu"; indent-tabs-mode:nil; -*- */
+/*
+ * Copyright (c) 2009 University of Pennsylvania
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation;
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#include "chord-transaction.h"
+#include "ns3/log.h"
+
+
+namespace ns3 {
+
+NS_LOG_COMPONENT_DEFINE ("ChordTransaction");
+
+ChordTransaction::ChordTransaction (uint32_t transactionId, ChordMessage chordMessage, Time requestTimeout, uint8_t maxRequestRetries)
+{
+  NS_LOG_FUNCTION_NOARGS();
+  m_transactionId = transactionId;
+  m_chordMessage = chordMessage;
+  m_requestTimeout = requestTimeout;
+  m_maxRetries = maxRequestRetries;
+  m_requestTimeoutEventId = EventId ();
+}
+
+ChordTransaction::~ChordTransaction ()
+{
+  //Use DoDispose()
+}
+
+void
+ChordTransaction::DoDispose ()
+{
+  NS_LOG_FUNCTION_NOARGS();
+  //cancel timer if running
+  Simulator::Cancel(m_requestTimeoutEventId);
+}
+
+void
+ChordTransaction::SetRetries (uint8_t retries)
+{
+  NS_LOG_FUNCTION_NOARGS();
+  m_retries = retries;
+}
+
+void
+ChordTransaction::SetMaxRetries (uint8_t maxRetries)
+{
+  NS_LOG_FUNCTION_NOARGS();
+  m_maxRetries = maxRetries;
+}
+
+void
+ChordTransaction::SetRequestTimeoutEventId (EventId eventId)
+{
+  NS_LOG_FUNCTION_NOARGS();
+  m_requestTimeoutEventId = eventId;
+}
+
+uint32_t
+ChordTransaction::GetTransactionId ()
+{
+  NS_LOG_FUNCTION_NOARGS();
+  return m_transactionId;
+}
+
+uint8_t
+ChordTransaction::GetRetries ()
+{
+  NS_LOG_FUNCTION_NOARGS();
+  return m_retries;
+}
+
+uint8_t
+ChordTransaction::GetMaxRetries ()
+{
+  NS_LOG_FUNCTION_NOARGS ();
+  return m_maxRetries;
+}
+
+Time
+ChordTransaction::GetRequestTimeout ()
+{
+  NS_LOG_FUNCTION_NOARGS();
+  return m_requestTimeout;
+
+}
+
+ChordMessage
+ChordTransaction::GetChordMessage ()
+{
+  NS_LOG_FUNCTION_NOARGS();
+  return m_chordMessage;
+}
+
+EventId
+ChordTransaction::GetRequestTimeoutEventId ()
+{
+  NS_LOG_FUNCTION_NOARGS ();
+  return m_requestTimeoutEventId;
+}
+
+void 
+ChordTransaction::SetOriginator (ChordTransaction::Originator originator)
+{
+  m_originator = originator;
+}
+
+ChordTransaction::Originator
+ChordTransaction::GetOriginator ()
+{
+  return m_originator;
+}
+
+Ptr<ChordIdentifier>
+ChordTransaction::GetRequestedIdentifier ()
+{
+  return m_requestedIdentifier;
+}
+
+void
+ChordTransaction::SetRequestedIdentifier (Ptr<ChordIdentifier> requestedIdentifier)
+{
+  m_requestedIdentifier = requestedIdentifier;
+}
+
+} //namespace ns3
Index: src/applications/chord-ipv4/chord-transaction.h
===================================================================
new file mode 100644
--- /dev/null
+++ b/src/applications/chord-ipv4/chord-transaction.h
@@ -0,0 +1,145 @@
+/* -*-  Mode: C++; c-file-style: "gnu"; indent-tabs-mode:nil; -*- */
+/*
+ * Copyright (c) 2009 University of Pennsylvania
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation;
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#ifndef CHORD_TRANSACTION_H
+#define CHORD_TRANSACTION_H
+
+#include <vector>
+#include "ns3/object.h"
+#include "ns3/nstime.h"
+#include "ns3/timer.h"
+#include "chord-message.h"
+
+
+namespace ns3 {
+
+/**
+ *  \ingroup chordipv4
+ *  \class ChordTransaction
+ *  \brief Class to store and operate on ChordTransaction
+ */
+
+class ChordTransaction : public Object
+{
+  public:
+
+    enum Originator {
+      APPLICATION = 1,
+      DHASH = 2,
+    };
+
+    /**
+     *  \brief Constructor
+     *  \param transactionId
+     *  \param chordMessage ChordMessage
+     *  \param requestTimeout
+     *  \param maxRequestRetries
+     */
+    ChordTransaction (uint32_t transactionId, ChordMessage chordMessage, Time requestTimeout, uint8_t maxRequestRetries);
+    virtual ~ChordTransaction ();
+    virtual void DoDispose ();
+
+
+    //Storage
+    /**
+     *  \brief Set current retries of sending request ChordMessage
+     *  \param retries
+     */
+    void SetRetries (uint8_t retries);
+    /**
+     *  \brief Set max retries of sending request ChordMessage
+     *  \param retries
+     */
+    void SetMaxRetries (uint8_t maxRetries);
+    /**
+     *  \brief Set eventId of retransmission event
+     *  \param eventid
+     */
+    void SetRequestTimeoutEventId (EventId eventId);
+    /**
+     *  \brief Set Requested Identifier
+     *  \param requestedIdentifier ChordIdentifier
+     */
+    void SetRequestedIdentifier (Ptr<ChordIdentifier> requestedIdentifier);
+
+    //Retrieval
+    /**
+     *  \returns Request timeout
+     */
+    Time GetRequestTimeout ();
+    /**
+     *  \returns Transaction Id
+     */
+    uint32_t GetTransactionId ();
+    /**
+     *  \returns Current Retries
+     */
+    uint8_t GetRetries ();
+    /**
+     *  \returns Max Retries
+     */
+    uint8_t GetMaxRetries ();
+    /**
+     *  \returns ChordMessage
+     */
+    ChordMessage GetChordMessage ();
+    /**
+     *  \returns Timeout eventId
+     */
+    EventId GetRequestTimeoutEventId ();
+    /**
+     *  \brief Sets request originator
+     *  \param originator
+     */
+    void SetOriginator (ChordTransaction::Originator originator);
+    /**
+     *  \returns ChordTransaction::Originator
+     */
+    ChordTransaction::Originator GetOriginator ();
+    /**
+     *  \return Ptr to requested ChordIdentifier
+     */
+    Ptr<ChordIdentifier> GetRequestedIdentifier ();
+
+  private:
+    /**
+     *  \cond
+     */ 
+    Ptr<ChordIdentifier> m_requestedIdentifier;
+    Time  m_requestTimeout;
+    EventId m_requestTimeoutEventId;
+    uint32_t m_transactionId;
+    uint8_t m_retries;
+    uint8_t m_maxRetries;
+    //RequestMessage for retransmissions
+    ChordMessage m_chordMessage;
+    //Originator of this transaction
+    ChordTransaction::Originator m_originator;
+    /**
+     *  \endcond
+     */
+};    
+
+
+
+
+} //namespace ns3
+
+
+
+#endif //CHORD_TRANSACTION_H
Index: src/applications/chord-ipv4/chord-vnode.cc
===================================================================
new file mode 100644
--- /dev/null
+++ b/src/applications/chord-ipv4/chord-vnode.cc
@@ -0,0 +1,517 @@
+/* -*-  Mode: C++; c-file-style: "gnu"; indent-tabs-mode:nil; -*- */
+
+/*
+ * Copyright (c) 2009 University of Pennsylvania
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation;
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#include "chord-vnode.h"
+#include "chord-node.h"
+#include "ns3/log.h"
+#include "ns3/ipv4-address.h"
+#include "ns3/uinteger.h"
+
+namespace ns3 {
+
+NS_LOG_COMPONENT_DEFINE ("ChordVNode");
+
+ChordVNode::ChordVNode (Ptr<ChordNode> node, uint8_t maxSuccessorListSize, uint8_t maxPredecessorListSize) : ChordNode (node)
+{
+  NS_LOG_FUNCTION_NOARGS();
+  m_successor = 0;
+  m_predecessor = 0;
+  m_maxSuccessorListSize = maxSuccessorListSize;
+  m_maxPredecessorListSize = maxPredecessorListSize;
+  PopulateFingerIdentifierList ();
+}
+
+ChordVNode::~ChordVNode ()
+{
+  NS_LOG_FUNCTION_NOARGS();
+}
+
+void
+ChordVNode::DoDispose (void)
+{
+  m_successorList.clear();
+  m_predecessorList.clear();
+  RemoveAllTransactions ();
+}
+
+std::vector<Ptr<ChordNode> >& 
+ChordVNode::GetSuccessorList (void)
+{
+  NS_LOG_FUNCTION_NOARGS();
+  return m_successorList;
+}
+
+std::vector<Ptr<ChordNode> >& 
+ChordVNode::GetPredecessorList (void)
+{
+  NS_LOG_FUNCTION_NOARGS();
+  return m_predecessorList;
+}
+
+std::string
+ChordVNode::GetVNodeName ()
+{
+  NS_LOG_FUNCTION_NOARGS ();
+  return GetName();
+    
+}
+
+Ptr<ChordNode>
+ChordVNode::GetPredecessor ()
+{
+  NS_LOG_FUNCTION_NOARGS ();
+  return m_predecessorList.front();
+}
+
+Ptr<ChordNode>
+ChordVNode::GetSuccessor ()
+{
+  NS_LOG_FUNCTION_NOARGS ();
+  return m_successorList.front();
+}
+
+ChordNodeTable&
+ChordVNode::GetFingerTable ()
+{
+  return m_fingerTable;
+}
+
+void
+ChordVNode::SetSuccessor (Ptr<ChordNode> successor)
+{
+  if (m_successorList.size() != 0)
+  {
+    m_successorList.erase (m_successorList.begin());
+  }
+  //Insert new successor
+  m_successorList.insert (m_successorList.begin(), successor);
+  m_successor = successor;
+  //Set timestamp
+  m_successor -> SetTimestamp (Simulator::Now());
+}
+
+void
+ChordVNode::SetPredecessor (Ptr<ChordNode> predecessor)
+{
+  if (m_predecessorList.size() != 0)
+  {
+    m_predecessorList.erase (m_predecessorList.begin());
+  }
+  //Insert new predecessor
+  m_predecessorList.insert (m_predecessorList.begin(), predecessor);
+  m_predecessor = predecessor;
+  //Set timestamp
+  m_predecessor -> SetTimestamp (Simulator::Now());
+}
+
+void
+ChordVNode::AddTransaction (uint32_t transactionId, Ptr<ChordTransaction> chordTransaction)
+{
+  ChordTransactionMap::iterator iterator = m_transactionMap.find (transactionId);
+  if (iterator == m_transactionMap.end())
+  {
+    //add it
+    m_transactionMap.insert(std::make_pair(transactionId, chordTransaction));
+    return;
+  }
+  NS_ASSERT (iterator != m_transactionMap.end());
+  return;
+}
+
+bool
+ChordVNode::FindTransaction (uint32_t transactionId, Ptr<ChordTransaction> &chordTransaction)
+{
+  ChordTransactionMap::iterator iterator =  m_transactionMap.find (transactionId);
+  if (iterator == m_transactionMap.end ())
+  {
+    //return failure
+    return false; 
+  }
+  //return success and pointer to transaction
+  chordTransaction = (*iterator).second;
+  return true;
+
+}
+
+void
+ChordVNode::RemoveTransaction (uint32_t transactionId)
+{
+  ChordTransactionMap::iterator iterator = m_transactionMap.find (transactionId);
+  if (iterator == m_transactionMap.end())
+  {
+    return;
+  }
+  //remove it
+  Ptr<ChordTransaction> chordTransaction = iterator->second;
+  chordTransaction -> DoDispose();
+  m_transactionMap.erase (iterator);
+}
+
+void
+ChordVNode::RemoveAllTransactions ()
+{
+  for (ChordTransactionMap::iterator iterator = m_transactionMap.begin(); iterator != m_transactionMap.end(); iterator++ )
+  {
+    iterator->second->DoDispose();
+    m_transactionMap.erase (iterator);
+  }
+  m_transactionMap.clear();
+}
+
+uint32_t
+ChordVNode::GetNextTransactionId ()
+{
+  return m_transactionId++;
+}
+
+std::vector<Ptr<ChordIdentifier> >&
+ChordVNode::GetFingerIdentifierList ()
+{
+  return m_fingerIdentifierList;
+}
+
+void
+ChordVNode::PopulateFingerIdentifierList ()
+{
+  for (uint16_t i = 0; i<(GetChordIdentifier()->GetNumBytes()*8); i++)
+  {
+    //Make copy
+    Ptr<ChordIdentifier> fingerIdentifier = Create<ChordIdentifier> (GetChordIdentifier());
+    //Add power of two
+    fingerIdentifier->AddPowerOfTwo(i);
+    m_fingerIdentifierList.push_back(fingerIdentifier);
+  }
+}
+
+void
+ChordVNode::PackJoinReq (ChordMessage &chordMessage)
+{
+  NS_LOG_FUNCTION_NOARGS ();
+  chordMessage.SetMessageType (ChordMessage::JOIN_REQ);
+  chordMessage.SetRequestorNode (this);
+  chordMessage.SetTransactionId (GetNextTransactionId());
+}
+
+void
+ChordVNode::PackJoinRsp(Ptr<ChordNode> requestorNode, uint32_t transactionId, ChordMessage &chordMessage)
+{
+  NS_LOG_FUNCTION_NOARGS ();
+  chordMessage.SetMessageType (ChordMessage::JOIN_RSP);
+  chordMessage.SetRequestorNode (requestorNode);
+  chordMessage.SetTransactionId (transactionId);
+  chordMessage.GetJoinRsp().successorNode = this;
+}
+
+void
+ChordVNode::PackLeaveReq (ChordMessage &chordMessage)
+{
+  NS_LOG_FUNCTION_NOARGS ();
+  chordMessage.SetMessageType (ChordMessage::LEAVE_REQ);
+  chordMessage.SetRequestorNode (this);
+  chordMessage.GetLeaveReq().successorNode = m_successor;
+  chordMessage.GetLeaveReq().predecessorNode = m_predecessor;
+}
+
+void
+ChordVNode::PackLeaveRsp (Ptr<ChordNode> requestorNode, Ptr<ChordNode> successorNode, Ptr<ChordNode> predecessorNode, ChordMessage &chordMessage)
+{
+  NS_LOG_FUNCTION_NOARGS ();
+  chordMessage.SetMessageType (ChordMessage::LEAVE_RSP);
+  chordMessage.SetRequestorNode (requestorNode);
+  chordMessage.GetLeaveRsp().successorNode = successorNode;
+  chordMessage.GetLeaveRsp().predecessorNode = predecessorNode;
+}
+
+void
+ChordVNode::PackLookupReq(Ptr<ChordIdentifier> requestedIdentifier, ChordMessage &chordMessage)
+{
+  NS_LOG_FUNCTION_NOARGS ();
+  chordMessage.SetMessageType (ChordMessage::LOOKUP_REQ);
+  chordMessage.SetRequestorNode (this);
+  chordMessage.GetLookupReq().requestedIdentifier = requestedIdentifier;
+  chordMessage.SetTransactionId (GetNextTransactionId());
+}
+
+void
+ChordVNode::PackLookupRsp(Ptr<ChordNode> requestorNode, uint32_t transactionId, ChordMessage &chordMessage)
+{
+  NS_LOG_FUNCTION_NOARGS ();
+  chordMessage.SetMessageType (ChordMessage::LOOKUP_RSP);
+  chordMessage.SetRequestorNode (requestorNode);
+  chordMessage.SetTransactionId (transactionId);
+  chordMessage.GetLookupRsp().resolvedNode = this;
+}
+
+void
+ChordVNode::PackStabilizeReq(ChordMessage &chordMessage)
+{
+  NS_LOG_FUNCTION_NOARGS ();
+  chordMessage.SetMessageType (ChordMessage::STABILIZE_REQ);
+  chordMessage.SetRequestorNode (this);
+  chordMessage.GetStabilizeReq().successorIdentifier = m_successor->GetChordIdentifier();
+}
+
+void 
+ChordVNode::PackStabilizeRsp(Ptr<ChordNode> requestorNode, ChordMessage &chordMessage)
+{
+  NS_LOG_FUNCTION_NOARGS ();
+  chordMessage.SetMessageType (ChordMessage::STABILIZE_RSP);
+  chordMessage.SetRequestorNode (requestorNode);
+  chordMessage.GetStabilizeRsp().predecessorNode = m_predecessor;
+  //Pack successor list
+  chordMessage.GetStabilizeRsp().successorListSize = m_successorList.size();
+  for (std::vector<Ptr<ChordNode> >::const_iterator nodeIter = m_successorList.begin(); nodeIter != m_successorList.end(); nodeIter++)
+  {
+    Ptr<ChordNode> node = *nodeIter;
+    chordMessage.GetStabilizeRsp().successorList.push_back (node);
+  }
+}
+
+void
+ChordVNode::PackHeartbeatReq(ChordMessage &chordMessage)
+{
+  NS_LOG_FUNCTION_NOARGS ();
+  chordMessage.SetMessageType (ChordMessage::HEARTBEAT_REQ);
+  chordMessage.SetRequestorNode (this);
+  chordMessage.GetHeartbeatReq().predecessorIdentifier = m_predecessor->GetChordIdentifier();
+}
+
+void
+ChordVNode::PackFingerReq (Ptr<ChordIdentifier> requestedIdentifier, ChordMessage &chordMessage)
+{
+  NS_LOG_FUNCTION_NOARGS ();
+  chordMessage.SetMessageType (ChordMessage::FINGER_REQ);
+  chordMessage.SetRequestorNode (this);
+  chordMessage.GetFingerReq().requestedIdentifier = requestedIdentifier;
+}
+
+void
+ChordVNode::PackFingerRsp (Ptr<ChordNode> requestorNode, Ptr<ChordIdentifier> requestedIdentifier, ChordMessage &chordMessage)
+{
+  NS_LOG_FUNCTION_NOARGS ();
+  chordMessage.SetMessageType (ChordMessage::FINGER_RSP);
+  chordMessage.SetRequestorNode (requestorNode);
+  chordMessage.GetFingerRsp().requestedIdentifier = requestedIdentifier;
+  chordMessage.GetFingerRsp().fingerNode = this;
+}
+
+void 
+ChordVNode::PackHeartbeatRsp(Ptr<ChordNode> requestorNode, ChordMessage &chordMessage)
+{
+  NS_LOG_FUNCTION_NOARGS ();
+  chordMessage.SetMessageType (ChordMessage::HEARTBEAT_RSP);
+  chordMessage.SetRequestorNode (requestorNode);
+  chordMessage.GetHeartbeatRsp().successorNode = m_successor;
+  //Pack predecessor list
+  chordMessage.GetHeartbeatRsp().predecessorListSize = m_predecessorList.size();
+  //Pack subsequent list
+  for (std::vector<Ptr<ChordNode> >::const_iterator nodeIter = m_predecessorList.begin(); nodeIter != m_predecessorList.end(); nodeIter++)
+  {
+    Ptr<ChordNode> node = *nodeIter;
+    chordMessage.GetHeartbeatRsp().predecessorList.push_back (node);
+  }
+}
+
+void
+ChordVNode::PackTraceRing(Ptr<ChordNode> requestorNode, ChordMessage &chordMessage)
+{
+  NS_LOG_FUNCTION_NOARGS ();
+  chordMessage.SetMessageType (ChordMessage::TRACE_RING);
+  chordMessage.SetRequestorNode (requestorNode);
+  chordMessage.GetTraceRing().successorIdentifier = m_successor->GetChordIdentifier();
+}
+
+bool
+ChordVNode::ShiftSuccessor ()
+{
+  if (m_successorList.size() > 1)
+  {
+    //Remove current successor
+    m_successorList.erase (m_successorList.begin());
+    //Set new successor
+    SetSuccessor(m_successorList.front());
+    return true;
+  }
+  else
+    return false;
+}
+
+bool
+ChordVNode::ShiftPredecessor ()
+{
+  if (m_predecessorList.size() > 1)
+  {
+    //Remove current predecessor
+    m_predecessorList.erase (m_predecessorList.begin());
+    //Set new predecessor
+    SetPredecessor(m_predecessorList.front());
+    return true;
+  }
+  else
+    return false;
+}
+
+void
+ChordVNode::SynchSuccessorList (std::vector<Ptr<ChordNode> > &successorList)
+{
+  if (m_successorList.size() > 1)
+  {
+    if (successorList.size() > 1)
+    {
+      //clear list
+      m_successorList.erase(m_successorList.begin()+1, m_successorList.end());
+    }
+    else
+    {
+      if (!successorList.front()-> GetChordIdentifier()->IsEqual(GetChordIdentifier()))
+      {
+        //Put this element in 2nd position and return
+        m_successorList.erase(m_successorList.begin()+1);
+        m_successorList.insert(m_successorList.begin()+1, successorList.front());
+        //set timestamp
+        //successorList.front()->SetTimestamp(Simulator::Now());
+      }
+      return;
+    }
+  }
+ 
+  uint8_t count = 0;
+  for (std::vector<Ptr<ChordNode> >::iterator nodeIter = successorList.begin(); nodeIter != successorList.end(); nodeIter++)
+  {
+    Ptr<ChordNode> node = *nodeIter;
+    //Check wrap around
+    if (node -> GetChordIdentifier()->IsEqual(GetChordIdentifier()))
+    {
+      //Wrap around has occurred
+      break;
+    }
+    m_successorList.push_back (node);
+    //Set Timestamp
+    //node->SetTimestamp(Simulator::Now());
+    count++;
+    if (count > m_maxSuccessorListSize-1)
+    {
+      break;
+    }
+  }
+}
+
+void
+ChordVNode::SynchPredecessorList (std::vector<Ptr<ChordNode> > &predecessorList)
+{
+  if (m_predecessorList.size() > 1)
+  {
+    if (predecessorList.size() > 1)
+    {
+      //clear list
+      m_predecessorList.erase(m_predecessorList.begin()+1, m_predecessorList.end());
+    }
+    else
+    {
+      if (!predecessorList.front()-> GetChordIdentifier()->IsEqual(GetChordIdentifier()))
+      {
+        //Put this element in 2nd position and return
+        m_predecessorList.erase(m_predecessorList.begin()+1);
+        m_predecessorList.insert(m_predecessorList.begin()+1, predecessorList.front());
+        //Set Timestamp
+        //m_predecessorList.front()->SetTimestamp(Simulator::Now());
+      }
+      return;
+    }
+  }
+ 
+  uint8_t count = 0;
+  for (std::vector<Ptr<ChordNode> >::iterator nodeIter = predecessorList.begin(); nodeIter != predecessorList.end(); nodeIter++)
+  {
+    Ptr<ChordNode> node = *nodeIter;
+    //Check wrap around
+    if (node -> GetChordIdentifier()->IsEqual(GetChordIdentifier()))
+    {
+      //Wrap around has occurred
+      break;
+    }
+    m_predecessorList.push_back (node);
+    //Set timestamp
+    //node->SetTimestamp(Simulator::Now());
+    count++;
+    if (count > m_maxPredecessorListSize-1)
+    {
+      break;
+    }
+  }
+}
+
+ChordVNode::VNodeStats&
+ChordVNode::GetStats ()
+{
+  return m_stats;
+}
+
+void
+ChordVNode::PrintSuccessorList (std::ostream &os)
+{
+  os << "SuccessorList Size: " << m_successorList.size() << " Dumping SuccessorList:: \n";
+  for (std::vector<Ptr<ChordNode> >::iterator nodeIter = m_successorList.begin(); nodeIter != m_successorList.end(); nodeIter++)
+  {
+    Ptr<ChordNode> node = *nodeIter;
+    os << "Successor Ip: " << node->GetIpAddress() << "\n";
+    os << "Successor Port: " << node->GetPort() << "\n";
+    os << "Successor Identifier: " << node->GetChordIdentifier() << "\n";
+    os << "****" << "\n";
+  }
+}
+void
+ChordVNode::PrintPredecessorList (std::ostream &os)
+{
+  os << "PredecessorList Size: " << m_predecessorList.size() << " Dumping PredecessorList:: \n";
+  for (std::vector<Ptr<ChordNode> >::iterator nodeIter = m_predecessorList.begin(); nodeIter != m_predecessorList.end(); nodeIter++)
+  {
+    Ptr<ChordNode> node = *nodeIter;
+    os << "Predecessor Ip: " << node->GetIpAddress() << "\n";
+    os << "Predecessor Port: " << node->GetPort() << "\n";
+    os << "Predecessor Identifier: " << node->GetChordIdentifier() << "\n";
+    os << "****" << "\n";
+  }
+}
+
+void
+ChordVNode::PrintFingerTable (std::ostream &os)
+{
+  os << "FingerTable Size: " << m_fingerTable.GetSize() << " Dumping Finger Table:: \n";
+  for (ChordNodeMap::iterator nodeIter = m_fingerTable.GetMap().begin(); nodeIter != m_fingerTable.GetMap().end(); nodeIter++)
+  {
+    Ptr<ChordNode> node = (*nodeIter).second;
+    os << "Finger Ip: " << node->GetIpAddress() << "\n";
+    os << "Finger Port: " << node->GetPort() << "\n";
+    os << "Finger Identifier: " << node->GetChordIdentifier() << "\n";
+    os << "****" << "\n";
+  }
+}
+
+void
+ChordVNode::PrintFingerIdentifierList (std::ostream &os)
+{
+  os << "Lookup was made for: " << m_fingerIdentifierList.size() << " fingers\n";
+  for (std::vector<Ptr<ChordIdentifier> >::iterator fingerIter = m_fingerIdentifierList.begin(); fingerIter != m_fingerIdentifierList.end(); fingerIter++)
+  {
+    os << (*fingerIter);
+  }
+}
+
+} //namespace ns3
Index: src/applications/chord-ipv4/chord-vnode.h
===================================================================
new file mode 100644
--- /dev/null
+++ b/src/applications/chord-ipv4/chord-vnode.h
@@ -0,0 +1,295 @@
+/* -*-  Mode: C++; c-file-style: "gnu"; indent-tabs-mode:nil; -*- */
+/*
+ * Copyright (c) 2009 University of Pennsylvania
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation;
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#ifndef CHORD_VNODE_H
+#define CHORD_VNODE_H
+
+#include <vector>
+#include <map>
+#include <string.h>
+#include "ns3/ptr.h"
+#include "ns3/object.h"
+#include "ns3/packet.h"
+#include "ns3/simulator.h"
+#include "ns3/chord-identifier.h"
+#include "ns3/chord-node.h"
+#include "ns3/chord-message.h"
+#include "ns3/chord-transaction.h"
+#include "ns3/chord-node-table.h"
+
+namespace ns3 {
+
+/**  
+ *  \ingroup chordipv4
+ *  \class ChordVNode
+ *  \brief VirtualNode for running Chord protocol. 
+ *  It maintains list of succesors, predecessors, states.
+ */
+
+class ChordVNode : public ChordNode
+{
+  public:
+    /**
+     *  \brief Constructor
+     *  \param node ChordNode
+     *  \param maxSuccessorListSize
+     *  \param maxPredecessorListSize
+     */
+    ChordVNode (Ptr<ChordNode> node, uint8_t maxSuccessorListSize, uint8_t maxPredecessorListSize);
+    virtual ~ChordVNode();
+    virtual void DoDispose ();
+
+    //Retrieval.
+    /**
+     *  \returns List of Successor ChordNode (s)
+     */
+    std::vector<Ptr<ChordNode> >&  GetSuccessorList(void);
+    /**
+     *  \returns List of Predecessor ChordNode(s)
+     */
+    std::vector<Ptr<ChordNode> >&  GetPredecessorList(void);
+    /**
+     *  \returns Predecessor ChordNode
+     */
+    Ptr<ChordNode> GetPredecessor(void);
+    /**
+     *  \returns Successor ChordNode
+     */
+    Ptr<ChordNode> GetSuccessor(void);
+    /**
+     *  \returns Name of Virtual Node
+     */
+    std::string GetVNodeName (void);
+    /**
+     *  \returns Finger Table(ChordNodeTable)
+     */
+    ChordNodeTable& GetFingerTable();
+    /**
+     *  \returns List of Finger identifiers
+     */
+    std::vector<Ptr<ChordIdentifier> >& GetFingerIdentifierList ();
+
+    //Storage
+    /**
+     *  \brief Sets new successor 
+     *  \param successor ChordNode
+     */
+    void SetSuccessor (Ptr<ChordNode> successor);
+    /**
+     *  \brief Sets new predecessor 
+     *  \param predecessor ChordNode
+     */
+    void SetPredecessor (Ptr<ChordNode> predecessor);
+    /**
+     *  \brief Replaces currently stored successor list
+     *  \param successorList 
+     */
+    void SynchSuccessorList (std::vector<Ptr<ChordNode> > &successorList);
+    /**
+     *  \brief Replaces currently stored predecessor list
+     *  \param predecessorList
+     */
+    void SynchPredecessorList (std::vector<Ptr<ChordNode> > &predecessorList);
+
+    //Request packing methods for this VNode
+    /**
+     *  \brief Packs Join Request
+     *  \param chordMessage ChordMessage
+     */
+    void PackJoinReq (ChordMessage &chordMessage);
+    /**
+     *  \brief Packs Leave Request
+     *  \param chordMessage ChordMessage
+     */
+    void PackLeaveReq (ChordMessage &chordMessage);
+    /**
+     *  \brief Packs Lookup Request
+     *  \param requestedIdentifier ChordIdentifier
+     *  \param chordMessage ChordMessage
+     */
+    void PackLookupReq (Ptr<ChordIdentifier> requestedIdentifier, ChordMessage &chordMessage);
+    /**
+     *  \brief Packs Stabilize Request
+     *  \param chordMessage ChordMessage
+     */
+    void PackStabilizeReq(ChordMessage &chordMessage);
+    /**
+     *  \brief Packs Heartbeat Request
+     *  \param chordMessage ChordMessage
+     */
+    void PackHeartbeatReq(ChordMessage &chordMessage);
+    /**
+     *  \brief Packs Trace Ring request
+     *  \param requestorIdentifier ChordIdentifier
+     *  \param chordMessage ChordMessage
+     */
+    void PackTraceRing(Ptr<ChordNode> requestorIdentifier, ChordMessage &chordMessage);
+    /**
+     *  \brief Packs Finger Request
+     *  \param requestedIdentifier ChordIdentifier
+     *  \param chordMessage ChordMessage
+     */
+    void PackFingerReq (Ptr<ChordIdentifier> requestedIdentifier, ChordMessage &chordMessage);
+
+    //Response packing methods for this VNode
+
+    /**
+     *  \brief Packs Join Response
+     *  \param requestorNode ChordNode
+     *  \param transactionId
+     *  \param chordMessage ChordMessage
+     */
+    void PackJoinRsp (Ptr<ChordNode> requestorNode, uint32_t transactionId, ChordMessage &chordMessage);
+    /**
+     *  \brief Packs Leave Response
+     *  \param requestorNode ChordNode
+     *  \param successorNode ChordNode
+     *  \param predecessorNode ChordNode
+     *  \param chordMessage ChordMessage
+     */
+    void PackLeaveRsp (Ptr<ChordNode> requestorNode, Ptr<ChordNode> successorNode, Ptr<ChordNode> predecessorNode, ChordMessage &chordMessage);
+    /**
+     *  \brief Packs Lookup Response
+     *  \param requestorNode ChordNode
+     *  \param transactionId
+     *  \param chordMessage ChordMessage
+     */
+    void PackLookupRsp (Ptr<ChordNode> requestorNode, uint32_t transactionId, ChordMessage &chordMessage);
+    /**
+     *  \brief Packs Heartbeat Response
+     *  \param requestorNode ChordNode
+     *  \param chordMessage ChordMessage
+     */
+    void PackHeartbeatRsp (Ptr<ChordNode> requestorNode, ChordMessage &chordMessage);
+    /**
+     *  \brief Packs Stabilize Response
+     *  \param requestorNode ChordNode
+     *  \param chordMessage ChordMessage
+     */
+    void PackStabilizeRsp (Ptr<ChordNode> requestorNode, ChordMessage &chordMessage);
+    /**
+     *  \brief Packs Finger Response
+     *  \param requestorNode ChordNode
+     *  \param requestedIdentifier ChordIdentifier
+     *  \param chordMessage ChordMessage
+     */
+    void PackFingerRsp (Ptr<ChordNode> requestorNode, Ptr<ChordIdentifier> requestedIdentifier, ChordMessage &chordMessage);
+
+    //Processing
+    /**
+     *  \brief Shift current successor to next one in successor list
+     *  \returns false if successor list is empty, otherwise true 
+     */
+    bool ShiftSuccessor ();
+    /**
+     *  \brief Shift current predecessor to next one in predecessor list
+     *  \returns false if predecessor list is empty, otherwise true 
+     *
+     */
+    bool ShiftPredecessor ();
+
+    //Transactions
+    /**
+     *  \brief Add ChordTransaction 
+     *  \param transactionId
+     *  \param chordTransaction Ptr to ChordTransaction
+     */
+    void AddTransaction (uint32_t transactionId, Ptr<ChordTransaction> chordTransaction);
+    /**
+     *  \brief Find Transaction
+     *  \param transactionId
+     *  \param chordTransaction Ptr to ChordTransaction (return result)
+     */
+    bool FindTransaction (uint32_t transactionId, Ptr<ChordTransaction> &chordTransaction);
+    /**
+     *  \brief Remove Transaction
+     *  \param transactionIf
+     */
+    void RemoveTransaction (uint32_t transactionId);
+    /**
+     *  \brief Removes all active transaction
+     */
+    void RemoveAllTransactions ();
+    /**
+     *  \brief Generate new transaction Id
+     *  \returns transactionId
+     */
+    uint32_t GetNextTransactionId ();
+    
+    //Diagnostics 
+    /**
+     *  \brief Print Successor List
+     *  \param os Output stream
+     */
+    void PrintSuccessorList (std::ostream &os);
+    /**
+     *  \brief Print Predecessor List
+     *  \param os Output stream
+     */
+    void PrintPredecessorList (std::ostream &os);
+    /**
+     *  \brief Print Finger Table
+     *  \param os Output stream
+     */
+    void PrintFingerTable (std::ostream &os);
+    /**
+     *  \brief Print Finger identifier list
+     *  \param os Output stream
+     */
+    void PrintFingerIdentifierList (std::ostream &os);
+  
+    //Counters
+    struct VNodeStats {
+    uint32_t fingersLookedUp;
+    };
+    /**
+     *  \returns ChordVNode::VNodeStats
+     */
+    VNodeStats& GetStats();
+
+  private:
+    /**
+     *  \cond
+     */
+    void PopulateFingerIdentifierList ();
+    uint32_t m_transactionId;
+    std::vector<Ptr<ChordNode> > m_successorList;
+    std::vector<Ptr<ChordNode> > m_predecessorList;
+    std::vector<Ptr<ChordIdentifier> > m_fingerIdentifierList;
+    ChordNodeTable m_fingerTable;
+    uint8_t m_maxSuccessorListSize;
+    uint8_t m_maxPredecessorListSize;
+
+    Ptr<ChordNode> m_predecessor;
+    Ptr<ChordNode> m_successor;
+
+    typedef std::map<uint32_t, Ptr<ChordTransaction> > ChordTransactionMap;
+
+    ChordTransactionMap m_transactionMap;
+
+    VNodeStats m_stats;
+
+    /**
+     *  \endcond
+     */ 
+
+}; //class ChordVNode
+
+} //namespace ns3
+
+#endif //CHORD_VNODE_H
Index: src/applications/chord-ipv4/dhash-connection.cc
===================================================================
new file mode 100644
--- /dev/null
+++ b/src/applications/chord-ipv4/dhash-connection.cc
@@ -0,0 +1,267 @@
+/* -*-  Mode: C++; c-file-style: "gnu"; indent-tabs-mode:nil; -*- */
+/*
+ * Copyright (c) 2009 University of Pennsylvania
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation;
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#include "dhash-connection.h"
+#include "ns3/log.h"
+
+namespace ns3 {
+NS_LOG_COMPONENT_DEFINE ("DHashConnection");
+
+DHashConnection::DHashConnection (Ipv4Address ipAddress, uint16_t port, Ptr<Socket> socket)
+{
+  m_ipAddress = ipAddress;
+  m_port = port;
+  m_socket = socket;
+  m_txState = TX_IDLE;
+  m_rxState = RX_IDLE;
+  m_totalTxBytes = 0;
+  m_currentTxBytes = 0;
+  m_lastActivityTime = Simulator::Now();
+}
+
+DHashConnection::DHashConnection ()
+{ 
+  m_ipAddress = 0;
+  m_port = 0;
+  m_socket = 0;
+  m_txState = TX_IDLE;
+  m_rxState = RX_IDLE;
+  m_totalTxBytes = 0;
+  m_currentTxBytes = 0;
+  m_lastActivityTime = Simulator::Now();
+}
+DHashConnection::DHashConnection (const DHashConnection &connection)
+{
+  Ptr<DHashConnection> dHashConnection = const_cast<DHashConnection *>(&connection);
+  m_ipAddress = dHashConnection->GetIpAddress();
+  m_port = dHashConnection->GetPort();
+  m_socket = dHashConnection->GetSocket();
+  m_txState = TX_IDLE;
+  m_rxState = RX_IDLE;
+  m_totalTxBytes = 0;
+  m_currentTxBytes = 0;
+  m_lastActivityTime = Simulator::Now();
+}
+
+
+DHashConnection::~DHashConnection ()
+{
+  if (m_socket != 0)
+  {
+    m_socket->Close();
+    m_socket->SetRecvCallback(MakeNullCallback<void, Ptr<Socket> > ());
+    m_socket = 0;
+  }
+  m_ipAddress = 0;
+  m_port = 0;
+  m_txState = TX_IDLE;
+  m_rxState = RX_IDLE;
+  m_totalTxBytes = 0;
+  m_currentTxBytes = 0;
+  m_txPacketList.clear();
+}
+
+void
+DHashConnection::DoDispose ()
+{
+  if (m_socket != 0)
+  {
+    m_socket->Close();
+    m_socket->SetRecvCallback(MakeNullCallback<void, Ptr<Socket> > ());
+    m_socket = 0;
+  }
+  m_ipAddress = 0;
+  m_port = 0;
+  m_txState = TX_IDLE;
+  m_rxState = RX_IDLE;
+  m_totalTxBytes = 0;
+  m_currentTxBytes = 0;
+  m_txPacketList.clear();
+}
+
+Ipv4Address
+DHashConnection::GetIpAddress()
+{
+  return m_ipAddress;
+}
+
+uint16_t
+DHashConnection::GetPort()
+{
+  return m_port;
+}
+
+Ptr<Socket>
+DHashConnection::GetSocket()
+{
+  return m_socket;
+}
+
+void 
+DHashConnection::SendTCPData (Ptr<Packet> packet)
+{
+  //Add packet to pending tx list
+  m_txPacketList.push_back (packet);
+  //Set state to transmitting
+  if (m_txState == TX_IDLE)
+  {
+    //Start transmitting
+    m_txState = TRANSMITTING;
+    m_socket -> SetSendCallback (MakeCallback(&DHashConnection::WriteTCPBuffer, this));
+    //Initiate transmission
+    WriteTCPBuffer (m_socket, m_socket->GetTxAvailable ());
+  }
+  return;
+}
+
+void
+DHashConnection::WriteTCPBuffer (Ptr<Socket> socket, uint32_t txSpace)
+{
+  m_lastActivityTime = Simulator::Now();
+  if (m_totalTxBytes == 0)
+  {
+    //Start new packet Tx
+    m_currentTxBytes = 0; 
+    if (m_txPacketList.size() == 0)
+    {
+      m_txState = TX_IDLE;
+      return;
+    }
+    m_currentTxPacket = *(m_txPacketList.begin());
+    m_totalTxBytes = m_currentTxPacket->GetSize();
+    DHashHeader dHashHeader;
+    dHashHeader.SetLength (m_totalTxBytes);
+    m_currentTxPacket->AddHeader(dHashHeader);
+    m_totalTxBytes = m_currentTxPacket->GetSize();
+  }
+
+  //Transmit m_currentTxPacket
+  uint32_t availTxBytes = socket->GetTxAvailable ();
+  // 2 Things: Either full packet fits or we have to fragment
+  if ((m_totalTxBytes-m_currentTxBytes) <= availTxBytes)
+  {
+    //Send entire packet at once and remove current packet from queue
+    socket->Send (m_currentTxPacket, 0);
+    m_txPacketList.erase (m_txPacketList.begin());
+    m_totalTxBytes = 0;
+    m_currentTxBytes = 0;    
+    return;
+  }
+  else
+  {
+    //Fragment and send packet
+    socket->Send (m_currentTxPacket->CreateFragment(m_currentTxBytes, availTxBytes));
+    m_currentTxBytes = m_currentTxBytes + availTxBytes;
+  }
+}
+
+void
+DHashConnection::ReadTCPBuffer (Ptr<Socket> socket)
+{
+  m_lastActivityTime = Simulator::Now();
+  uint32_t availRxBytes = socket->GetRxAvailable();
+  Ptr<Packet> packet = socket->Recv(availRxBytes, 0);
+
+  while (availRxBytes > 0)
+  {
+    Ptr<Packet> messagePacket = AssembleMessage(packet, availRxBytes);
+    if (messagePacket != NULL)
+    {
+      m_recvFn (messagePacket, this);
+    }
+  }
+
+}
+
+Ptr<Packet>
+DHashConnection::AssembleMessage (Ptr<Packet>& packet, uint32_t &availRxBytes)
+{
+  if (m_rxState == RX_IDLE)
+  { 
+    //Receive new packet
+    DHashHeader dHashHeader = DHashHeader ();
+    packet->RemoveHeader(dHashHeader);
+    availRxBytes = availRxBytes - dHashHeader.GetSerializedSize();
+    m_totalRxBytes = dHashHeader.GetLength();
+    m_currentRxBytes = 0;
+    m_currentRxPacket = Create<Packet> ();
+    m_rxState = RECEIVING;
+  }
+  if ((m_totalRxBytes-m_currentRxBytes) <=  packet->GetSize())
+  {  
+    //Deliver message
+    m_currentRxPacket->AddAtEnd(packet->CreateFragment(0, m_totalRxBytes-m_currentRxBytes));
+    //remove bytes
+    packet->RemoveAtStart (m_totalRxBytes-m_currentRxBytes);
+    availRxBytes = availRxBytes - (m_totalRxBytes-m_currentRxBytes);
+    m_rxState = RX_IDLE;
+    return m_currentRxPacket; 
+  }
+  else
+  {
+    //concat received packet
+    m_currentRxPacket->AddAtEnd (packet);
+    availRxBytes = 0;
+    return NULL;
+  }
+}
+
+void
+DHashConnection::SetRecvCallback (Callback<void, Ptr<Packet>, Ptr<DHashConnection> > recvFn)
+{
+  m_recvFn = recvFn;
+}
+
+Time
+DHashConnection::GetLastActivityTime ()
+{
+  return m_lastActivityTime;
+}
+
+
+//Needed for std::map
+bool
+operator < (const DHashConnection &connectionL, const DHashConnection &connectionR)
+{
+  Ptr<DHashConnection> connL = const_cast<DHashConnection *>(&connectionL);
+  Ptr<DHashConnection> connR = const_cast<DHashConnection *>(&connectionR);
+  if (connL->GetIpAddress() < connL->GetIpAddress())
+    return true;
+  else if (connL->GetIpAddress() == connL->GetIpAddress())
+  {
+    if (connL->GetPort() < connR->GetPort())
+      return true;
+    else
+      return false;
+  }
+  else
+    return false;
+} 
+
+bool
+operator == (const DHashConnection &connectionL, const DHashConnection &connectionR)
+{
+  Ptr<DHashConnection> connL = const_cast<DHashConnection *>(&connectionL);
+  Ptr<DHashConnection> connR = const_cast<DHashConnection *>(&connectionR);
+  if ((connL->GetIpAddress() == connL->GetIpAddress()) && (connL->GetPort() == connR->GetPort()))
+    return true;
+  else
+    return false;
+}
+
+}
Index: src/applications/chord-ipv4/dhash-connection.h
===================================================================
new file mode 100644
--- /dev/null
+++ b/src/applications/chord-ipv4/dhash-connection.h
@@ -0,0 +1,164 @@
+/* -*-  Mode: C++; c-file-style: "gnu"; indent-tabs-mode:nil; -*- */
+/*
+ * Copyright (c) 2009 University of Pennsylvania
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation;
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#ifndef DHASH_CONNECTION_H
+#define DHASH_CONNECTION_H
+
+#include "ns3/socket.h"
+#include "ns3/ptr.h"
+#include "ns3/object.h"
+#include "ns3/packet.h"
+#include "ns3/ipv4-address.h"
+#include "ns3/timer.h"
+#include "ns3/callback.h"
+#include "ns3/simulator.h"
+#include "dhash-message.h"
+#include <vector>
+
+namespace ns3 {
+
+/**
+ *  \ingroup chordipv4
+ *  \class DHashConnection
+ *  \brief Class to operate on TCP connection
+ *
+ */
+
+class DHashConnection : public Object
+{
+  public:
+    /**
+     *  \brief Constructor
+     *  \param ipAddress Ipv4Address of remote node
+     *  \param port
+     *  \param socket Ptr to Socket
+     */
+    DHashConnection (Ipv4Address ipAddress, uint16_t port, Ptr<Socket> socket);
+    DHashConnection ();
+    /**
+     *  \brief Copy Constructor
+     *  \param dHashConnection
+     */
+    DHashConnection (const DHashConnection &dHashConnection);
+    virtual ~DHashConnection ();
+    virtual void DoDispose ();
+
+    /**
+     *  \returns Ipv4Address of remote host
+     */
+    Ipv4Address GetIpAddress ();
+    /**
+     *  \returns port of remote host
+     */
+    uint16_t GetPort ();
+    /**
+     *  \returns TCP socket
+     */
+    Ptr<Socket> GetSocket ();
+    /**
+     *  \returns Timestamp of last activity on socket
+     */
+    Time GetLastActivityTime ();
+
+    //TCP methods
+    /**
+     *  \brief Sends data on open connection
+     *  \param packet Ptr to Packet
+     */
+    void SendTCPData (Ptr<Packet> packet);
+    /**
+     *  \brief Writes data on socket based on available space info
+     *  \param Ptr to Socket
+     *  \param txSpace
+     */
+    void WriteTCPBuffer (Ptr<Socket> socket, uint32_t txSpace);
+    /**
+     *  \brief Read data from socket
+     *  \param socket Ptr to Socket
+     *  \param txSpace
+     */
+    void ReadTCPBuffer (Ptr<Socket> socket);
+    /**
+     *  \brief Registers Receive Callback function
+     *  \param recvFn Callback
+     *  
+     *  This upcall is made whenever complete DHashMessage is received
+     */
+    void SetRecvCallback (Callback<void, Ptr<Packet>, Ptr<DHashConnection> > recvFn);
+    
+  private:
+
+    /**
+     *  \cond
+     */
+    enum TxState
+    {
+      TX_IDLE = 0,
+      TRANSMITTING = 1,
+    }; 
+
+    enum RxState
+    {
+      RX_IDLE = 0,
+      RECEIVING = 1,
+    };
+
+    Ipv4Address m_ipAddress;
+    uint16_t m_port;
+    Ptr<Socket> m_socket;
+
+    Time m_lastActivityTime;
+
+    //TCP assembly/trasnmission buffer handling
+    
+    TxState m_txState;
+    std::vector<Ptr<Packet> > m_txPacketList;
+    Ptr<Packet> m_currentTxPacket;
+    //Current packet tx counters
+    uint32_t m_totalTxBytes;
+    uint32_t m_currentTxBytes;
+
+    RxState m_rxState;
+    //rx counters
+    uint32_t m_totalRxBytes;
+    uint32_t m_currentRxBytes;
+    Ptr<Packet> m_currentRxPacket;
+    Callback<void, Ptr<Packet>, Ptr<DHashConnection> > m_recvFn;
+    /**
+     *  \endcond
+     */  
+    //Assembly of rx packet
+    /**
+     *  \brief Assembles DHashMessage
+     *  \param packet Ptr to Packet
+     *  \param availRxBytes
+     *  \returns Ptr to complete DHashMessage Packet
+     */
+    Ptr<Packet> AssembleMessage (Ptr<Packet>& packet, uint32_t& availRxBytes);
+
+    //Operators
+    friend bool operator < (const DHashConnection &connectionL, const DHashConnection &connectionR);
+    friend bool operator == (const DHashConnection &connectionL, const DHashConnection &connectionR);
+};    
+
+
+std::ostream& operator<< (std::ostream& os, Ptr<DHashConnection> const &connection);
+bool operator < (const DHashConnection &connectionL, const DHashConnection &connectionR);
+bool operator == (const DHashConnection &connectionL, const DHashConnection &connectionR);
+} //namespace ns3
+#endif //DHASH_CONNECTION_H
Index: src/applications/chord-ipv4/dhash-ipv4.cc
===================================================================
new file mode 100644
--- /dev/null
+++ b/src/applications/chord-ipv4/dhash-ipv4.cc
@@ -0,0 +1,751 @@
+/* -*-  Mode: C++; c-file-style: "gnu"; indent-tabs-mode:nil; -*- */
+/*
+ * Copyright (c) 2009 University of Pennsylvania
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation;
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+
+#include "ns3/application.h"
+#include "ns3/event-id.h"
+#include "ns3/ptr.h"
+#include "ns3/ipv4-address.h"
+#include "ns3/traced-callback.h"
+#include "ns3/timer.h"
+#include "ns3/log.h"
+#include "ns3/uinteger.h"
+#include "chord-identifier.h"
+#include "dhash-ipv4.h"
+#include "dhash-message.h"
+#include "chord-ipv4.h"
+
+namespace ns3 {
+
+NS_LOG_COMPONENT_DEFINE ("DHashIpv4");
+NS_OBJECT_ENSURE_REGISTERED (DHashIpv4);
+
+
+    
+TypeId
+DHashIpv4::GetTypeId (void)
+{
+  static TypeId tid = TypeId ("ns3::DHashIpv4")
+  .SetParent<Object> ()
+  .AddConstructor<DHashIpv4>()
+  .AddAttribute ("LocalIpAddress",
+                 "Local IP address",
+                 Ipv4AddressValue (),
+                 MakeIpv4AddressAccessor (&DHashIpv4::m_localIpAddress),
+                 MakeIpv4AddressChecker ())
+  .AddAttribute ("ListeningPort",
+                 "DHash port",
+                 UintegerValue (0),
+                 MakeUintegerAccessor (&DHashIpv4::m_dHashPort),
+                 MakeUintegerChecker<uint16_t> ())
+  .AddAttribute ("ConnectionInactivityTimeout",
+                 "Timeout value for tearing down inactive connections in milli seconds",
+                 TimeValue (MilliSeconds (DEFAULT_CONNECTION_INACTIVITY_TIMEOUT)),
+                 MakeTimeAccessor (&DHashIpv4::m_inactivityTimeout),
+                 MakeTimeChecker ())
+  .AddAttribute ("AuditObjectsTimeout",
+                 "Timeout value for auditing objects in milli seconds",
+                 TimeValue (MilliSeconds (DEFAULT_AUDIT_OBJECTS_TIMEOUT)),
+                 MakeTimeAccessor (&DHashIpv4::m_auditObjectsTimeout),
+                 MakeTimeChecker ())
+  ;
+  return tid;
+}
+
+void
+DHashIpv4::Start(Ptr<ChordIpv4> chordIpv4)
+{
+  NS_LOG_FUNCTION_NOARGS ();
+  m_transactionId = 0;
+  m_chordApplication = chordIpv4;
+  if (m_socket == 0)
+  {
+    TypeId tid = TypeId::LookupByName ("ns3::TcpSocketFactory");
+    m_socket = Socket::CreateSocket (chordIpv4->GetNode(), tid);
+    InetSocketAddress local = InetSocketAddress (m_localIpAddress, m_dHashPort);
+    m_socket->Bind (local);
+    m_socket->SetAcceptCallback (
+              MakeCallback(&DHashIpv4::HandleConnectionRequest, this), 
+              MakeCallback(&DHashIpv4::HandleAccept, this));
+  }
+  else
+  {
+    m_socket->SetAcceptCallback (
+              MakeCallback(&DHashIpv4::HandleConnectionRequest, this), 
+              MakeCallback(&DHashIpv4::HandleAccept, this));
+  }
+  m_socket->Listen();
+
+  //Configure Callbacks with Chord layer
+  m_chordApplication->SetDHashLookupSuccessCallback (MakeCallback(&DHashIpv4::HandleLookupSuccess, this));
+  m_chordApplication->SetDHashLookupFailureCallback (MakeCallback(&DHashIpv4::HandleLookupFailure, this));
+  m_chordApplication->SetDHashVNodeKeyOwnershipCallback (MakeCallback(&DHashIpv4::HandleOwnershipTrigger, this));
+
+  m_auditConnectionsTimer.SetFunction(&DHashIpv4::DoPeriodicAuditConnections, this);
+  m_auditObjectsTimer.SetFunction(&DHashIpv4::DoPeriodicAuditObjects, this);
+  //Start timers
+  m_auditConnectionsTimer.Schedule (m_inactivityTimeout);
+  m_auditObjectsTimer.Schedule (m_auditObjectsTimeout);
+}
+
+DHashIpv4::DHashIpv4 ()
+  :m_auditConnectionsTimer(Timer::CANCEL_ON_DESTROY),
+   m_auditObjectsTimer(Timer::CANCEL_ON_DESTROY)
+{
+}
+
+void
+DHashIpv4::DoDispose ()
+{
+  if (m_socket != 0)
+  {
+    m_socket->SetAcceptCallback (
+              MakeNullCallback<bool, Ptr<Socket>, const Address & > (), 
+              MakeNullCallback<void, Ptr<Socket>, const Address &> ());
+  }
+  //Cancel timers
+  m_auditConnectionsTimer.Cancel();
+  m_auditObjectsTimer.Cancel();
+}
+
+DHashIpv4::~DHashIpv4 ()
+{
+}
+
+void 
+DHashIpv4::SetInsertSuccessCallback (Callback <void, uint8_t*, uint8_t, uint8_t*, uint32_t> insertSuccessFn)
+{
+  m_insertSuccessFn = insertSuccessFn;
+} 
+
+void 
+DHashIpv4::SetRetrieveSuccessCallback (Callback <void, uint8_t*, uint8_t, uint8_t*, uint32_t> retrieveSuccessFn)
+{
+  m_retrieveSuccessFn = retrieveSuccessFn;
+} 
+   
+void 
+DHashIpv4::SetInsertFailureCallback (Callback <void, uint8_t*, uint8_t, uint8_t*, uint32_t> insertFailureFn)
+{
+  m_insertFailureFn = insertFailureFn;
+} 
+
+void 
+DHashIpv4::SetRetrieveFailureCallback (Callback <void, uint8_t*, uint8_t> retrieveFailureFn)
+{
+  m_retrieveFailureFn = retrieveFailureFn;
+}
+
+void
+DHashIpv4::NotifyInsertSuccess (Ptr<DHashObject> object)
+{
+  m_insertSuccessFn (object->GetObjectIdentifier()->GetKey(), object->GetObjectIdentifier()->GetNumBytes(), object->GetObject(), object->GetSizeOfObject());
+}
+
+void
+DHashIpv4::NotifyRetrieveSuccess (Ptr<DHashObject> object)
+{
+  m_retrieveSuccessFn (object->GetObjectIdentifier()->GetKey(), object->GetObjectIdentifier()->GetNumBytes(), object->GetObject(), object->GetSizeOfObject());
+}
+
+void
+DHashIpv4::NotifyFailure (Ptr<DHashTransaction> dHashTransaction)
+{
+  if (dHashTransaction->GetDHashMessage().GetMessageType() == DHashMessage::STORE_REQ)
+  {
+    NotifyInsertFailure (dHashTransaction->GetDHashMessage().GetStoreReq().dHashObject);
+  }
+  else if (dHashTransaction->GetDHashMessage().GetMessageType() == DHashMessage::RETRIEVE_REQ)
+  {
+    NotifyRetrieveFailure (dHashTransaction->GetObjectIdentifier());
+  }
+}
+
+void
+DHashIpv4::NotifyInsertFailure (Ptr<DHashObject> object)
+{
+  m_insertFailureFn (object->GetObjectIdentifier()->GetKey(), object->GetObjectIdentifier()->GetNumBytes(), object->GetObject(), object->GetSizeOfObject());
+}
+
+void
+DHashIpv4::NotifyRetrieveFailure (Ptr<ChordIdentifier> objectIdentifier)
+{
+  m_retrieveFailureFn (objectIdentifier->GetKey(), objectIdentifier->GetNumBytes()); 
+}
+
+void
+DHashIpv4::Insert (uint8_t *key,uint8_t sizeOfKey ,uint8_t *object,uint32_t sizeOfObject)
+{
+  Ptr<ChordIdentifier> objectIdentifier = Create<ChordIdentifier> (key, sizeOfKey);
+  Ptr<DHashObject> dHashObject = Create<DHashObject> (objectIdentifier, object, sizeOfObject);
+  //Check local ownership
+  if (m_chordApplication->CheckOwnership (key, sizeOfKey) == true)
+  {
+    //Store locally  
+    AddObject (dHashObject);
+    NotifyInsertSuccess (dHashObject);  
+    return;
+  }
+  //Transfer Object
+  TransferObject (dHashObject, DHashTransaction::APPLICATION, Ipv4Address::GetZero(), 0);
+}
+
+void
+DHashIpv4::Retrieve (uint8_t* key, uint8_t sizeOfKey)
+{
+  Ptr<ChordIdentifier> objectIdentifier = Create<ChordIdentifier> (key, sizeOfKey);
+  //Check local ownership
+  if (m_chordApplication->CheckOwnership (key, sizeOfKey) == true)
+  {
+    //Search local
+    Ptr<DHashObject> dHashObject;
+    if (FindObject (objectIdentifier, dHashObject) == true)
+    {
+      NotifyRetrieveSuccess (dHashObject);
+    }
+    else
+    {
+      NotifyRetrieveFailure (objectIdentifier);
+    }
+    return;
+  }
+  //Create Message
+  DHashMessage dHashMessage = DHashMessage ();
+  PackRetrieveReq (objectIdentifier, dHashMessage);
+  //Create Transaction
+  Ptr<DHashTransaction> dHashTransaction = Create<DHashTransaction> (dHashMessage.GetTransactionId(), objectIdentifier, dHashMessage);
+  AddTransaction (dHashTransaction);
+  //Lookup identifier
+  m_chordApplication->DHashLookupKey (key, sizeOfKey);
+}
+
+void
+DHashIpv4::SendDHashRequest (Ipv4Address ipAddress, uint16_t port, Ptr<DHashTransaction> dHashTransaction)
+{
+  Ptr<Packet> packet = Create<Packet> ();
+  packet->AddHeader (dHashTransaction->GetDHashMessage());
+  if (packet->GetSize())
+  {
+    //Set activity flag
+    dHashTransaction->SetActiveFlag (true);
+    //Check for existing connections
+    Ptr<DHashConnection> connection;
+    if (FindConnection (ipAddress, port, connection) != true)
+    {
+      //Open new connection
+      TypeId tid = TypeId::LookupByName ("ns3::TcpSocketFactory");
+      Ptr<Socket> socket = Socket::CreateSocket(m_chordApplication->GetNode(), tid);
+      connection = AddConnection (socket, ipAddress, port);
+      socket->Bind ();
+      socket->Connect (InetSocketAddress (ipAddress, port));
+    }
+    dHashTransaction->SetDHashConnection (connection);
+    connection->SendTCPData(packet);
+    return;
+  }
+}
+
+void
+DHashIpv4::AddTransaction (Ptr<DHashTransaction> dHashTransaction)
+{
+  //Add transaction to transactionID-TransactionMap
+  m_dHashTransactionTable.insert (std::make_pair(dHashTransaction->GetDHashMessage().GetTransactionId(), dHashTransaction));
+}
+
+bool
+DHashIpv4::FindTransaction (uint32_t transactionId, Ptr<DHashTransaction>& dHashTransaction)
+{
+  DHashTransactionMap::iterator iterator = m_dHashTransactionTable.find (transactionId);
+  if (iterator == m_dHashTransactionTable.end())
+  {
+    return false;
+  }
+  dHashTransaction = (*iterator).second;
+  return true;
+}
+
+void
+DHashIpv4::RemoveTransaction (uint32_t transactionId)
+{
+  DHashTransactionMap::iterator iterator = m_dHashTransactionTable.find (transactionId);
+  if (iterator == m_dHashTransactionTable.end())
+  {
+    return;
+  }
+  m_dHashTransactionTable.erase (iterator);
+  return;
+}
+
+void
+DHashIpv4::RemoveActiveTransactions (Ptr<Socket> socket)
+{
+  NS_LOG_INFO ("Connection lost, clearing transactions");
+  for (DHashTransactionMap::iterator iterator = m_dHashTransactionTable.begin(); iterator != m_dHashTransactionTable.end(); )
+  {
+    Ptr<DHashTransaction> dHashTransaction = (*iterator).second;
+    if (dHashTransaction->GetActiveFlag() && dHashTransaction->GetDHashConnection()->GetSocket() == socket)
+    {
+      //Report failure and remove
+      NotifyFailure (dHashTransaction);
+      m_dHashTransactionTable.erase (iterator++);
+    }
+    else
+      ++iterator;
+  }
+}
+
+bool
+DHashIpv4::HandleConnectionRequest (Ptr<Socket> socket, const Address& address)
+{
+  //Accept all connections
+  return true;
+}
+
+void 
+DHashIpv4::HandleAccept (Ptr<Socket> socket, const Address& address)
+{
+  InetSocketAddress from = InetSocketAddress::ConvertFrom (address);
+  AddConnection (socket, from.GetIpv4(), from.GetPort());
+}
+
+void
+DHashIpv4::HandleClose (Ptr<Socket> socket)
+{
+  //Remove all active transactions running on this socket
+  RemoveActiveTransactions (socket);
+  //Remove from connection list
+  RemoveConnection (socket);
+}
+
+
+void
+DHashIpv4::HandleLookupSuccess (uint8_t* lookupKey, uint8_t lookupKeyBytes, Ipv4Address ipAddress, uint16_t port)
+{
+  NS_LOG_INFO ("*******LOOKUP SUCCESS");
+  Ptr<ChordIdentifier> objectIdentifier = Create<ChordIdentifier> (lookupKey, lookupKeyBytes);
+  //For all matching transactions, transmit requests
+  for (DHashTransactionMap::iterator iterator = m_dHashTransactionTable.begin(); iterator != m_dHashTransactionTable.end(); iterator++)
+  {
+    Ptr<DHashTransaction> dHashTransaction = (*iterator).second;
+    if (objectIdentifier->IsEqual(dHashTransaction->GetObjectIdentifier()))
+    {
+      //Only transmit for new transactions
+      if (!dHashTransaction->GetActiveFlag())
+      {
+        SendDHashRequest (ipAddress, port, dHashTransaction);
+      }
+
+    }
+  }
+}
+
+void
+DHashIpv4::HandleLookupFailure (uint8_t* lookupKey, uint8_t lookupKeyBytes)
+{
+  Ptr<ChordIdentifier> objectIdentifier = Create<ChordIdentifier> (lookupKey, lookupKeyBytes);
+  //For all matching transactions, report failure
+  for (DHashTransactionMap::iterator iterator = m_dHashTransactionTable.begin(); iterator != m_dHashTransactionTable.end(); )
+  {
+    Ptr<DHashTransaction> dHashTransaction = (*iterator).second;
+    if (objectIdentifier->IsEqual(dHashTransaction->GetObjectIdentifier()))
+    {
+      //Report Failure
+      if (dHashTransaction->GetDHashMessage().GetMessageType() == DHashMessage::STORE_REQ)
+      {
+        NotifyInsertFailure (dHashTransaction->GetDHashMessage().GetStoreReq().dHashObject);
+      }
+      else if (dHashTransaction->GetDHashMessage().GetMessageType() == DHashMessage::RETRIEVE_REQ)
+      {
+        NotifyRetrieveFailure (objectIdentifier);
+      }
+      //Erase transaction
+      m_dHashTransactionTable.erase (iterator++);
+    }
+    else
+      ++iterator;
+  }
+}
+
+void
+DHashIpv4::HandleOwnershipTrigger (uint8_t* vNodeKey, uint8_t vNodeBytes, uint8_t* predKey, uint8_t predBytes, uint8_t* oldPredKey, uint8_t oldPredBytes, Ipv4Address predIp, uint16_t predPort)
+{
+  Ptr<ChordIdentifier> predIdentifier = Create<ChordIdentifier> (predKey, predBytes);
+  Ptr<ChordIdentifier> oldPredIdentifier = Create<ChordIdentifier> (oldPredKey, oldPredBytes);
+  Ptr<ChordIdentifier> vNodeIdentifier = Create<ChordIdentifier> (vNodeKey, vNodeBytes);
+  
+  //No need to transfer anything if predecessor crashed or left us
+  if (oldPredIdentifier->IsInBetween(predIdentifier, vNodeIdentifier))
+  {
+    return;
+  }
+  for (DHashObjectMap::iterator iterator = m_dHashObjectTable.begin(); iterator != m_dHashObjectTable.end(); iterator++)
+  {
+    Ptr<DHashObject> dHashObject = (*iterator).second;
+    Ptr<ChordIdentifier> objectIdentifier = dHashObject->GetObjectIdentifier();
+    if (objectIdentifier->IsInBetween(oldPredIdentifier, predIdentifier))
+    {
+      //Transfer object
+      TransferObject (dHashObject, DHashTransaction::DHASH ,predIp, predPort);
+    }
+  }
+}
+
+void
+DHashIpv4::ProcessDHashMessage (Ptr<Packet> packet, Ptr<DHashConnection> dHashConnection)
+{
+  DHashMessage dHashMessage = DHashMessage ();
+  packet->RemoveHeader (dHashMessage);
+  NS_LOG_INFO (dHashMessage);
+  switch (dHashMessage.GetMessageType ())
+  {
+    case DHashMessage::STORE_REQ:
+      ProcessStoreReq (dHashMessage, dHashConnection);
+      break;
+    case DHashMessage::STORE_RSP:
+      ProcessStoreRsp (dHashMessage, dHashConnection);
+      break;
+    case DHashMessage::RETRIEVE_REQ:
+      ProcessRetrieveReq (dHashMessage, dHashConnection);
+      break;
+    case DHashMessage::RETRIEVE_RSP:
+      ProcessRetrieveRsp (dHashMessage, dHashConnection);
+      break;
+    default:
+      break;
+    
+  }
+
+}
+
+void
+DHashIpv4::ProcessStoreReq (DHashMessage dHashMessage, Ptr<DHashConnection> dHashConnection)
+{
+  Ptr<DHashObject> object = dHashMessage.GetStoreReq().dHashObject;
+
+  AddObject (object);
+  //Send positive response back
+  Ptr<Packet> packet = Create<Packet> ();
+  DHashMessage respMessage = DHashMessage();
+  PackStoreRsp (dHashMessage.GetTransactionId(), DHashMessage::STORE_SUCCESS, object->GetObjectIdentifier(), respMessage);
+  packet->AddHeader(respMessage);
+  dHashConnection -> SendTCPData (packet);
+  /*
+   *
+   *  Cannot check ownership and then store. When a new VNode joins, it might not have set its predecessor. 
+   *
+   *
+  //Check ownership
+  if (m_chordApplication->CheckOwnership (object->GetObjectIdentifier()->GetKey(), object->GetObjectIdentifier()->GetNumBytes()) == true)
+  {
+    AddObject (object);
+    //Send positive response back
+    Ptr<Packet> packet = Create<Packet> ();
+    DHashMessage respMessage = DHashMessage();
+    PackStoreRsp (dHashMessage.GetTransactionId(), DHashMessage::STORE_SUCCESS, object->GetObjectIdentifier(), respMessage);
+    packet->AddHeader(respMessage);
+    dHashConnection -> SendTCPData (packet);
+    return;
+  }
+  else
+  {
+    Ptr<Packet> packet = Create<Packet> ();
+    DHashMessage respMessage = DHashMessage();
+    //Send negative response back    
+    PackStoreRsp (dHashMessage.GetTransactionId(), DHashMessage::NOT_OWNER, object->GetObjectIdentifier(), respMessage);
+    packet->AddHeader(respMessage);
+    dHashConnection -> SendTCPData (packet);
+    return; 
+  }*/
+}
+
+void
+DHashIpv4::ProcessStoreRsp(DHashMessage dHashMessage, Ptr<DHashConnection> dHashConnection)
+{
+  Ptr<DHashTransaction> dHashTransaction;
+  if (FindTransaction(dHashMessage.GetTransactionId(), dHashTransaction) != true)
+  {
+    return;
+  }
+  //Notify user
+  if (dHashMessage.GetStoreRsp().statusTag == DHashMessage::STORE_SUCCESS)
+  {  
+    if (dHashTransaction->GetOriginator() == DHashTransaction::APPLICATION)
+    { 
+      NotifyInsertSuccess (dHashTransaction->GetDHashMessage().GetStoreReq().dHashObject);
+    }
+    else if (dHashTransaction->GetOriginator() == DHashTransaction::DHASH)
+    {
+      //Remove object from local store
+      RemoveObject (dHashTransaction->GetObjectIdentifier());
+    }
+  }   
+  else
+  {
+    if (dHashTransaction->GetOriginator() == DHashTransaction::APPLICATION)
+    { 
+      NotifyInsertFailure (dHashTransaction->GetDHashMessage().GetStoreReq().dHashObject);
+    }
+  }
+  //Remove transaction
+  RemoveTransaction (dHashMessage.GetTransactionId()); 
+}
+
+void
+DHashIpv4::ProcessRetrieveReq (DHashMessage dHashMessage, Ptr<DHashConnection> dHashConnection)
+{
+  Ptr<ChordIdentifier> objectIdentifier = dHashMessage.GetRetrieveReq().objectIdentifier;
+  Ptr<DHashObject> dHashObject;
+  if (FindObject(objectIdentifier, dHashObject) == true)
+  {
+    //Send positive response back
+    Ptr<Packet> packet = Create<Packet> ();
+    DHashMessage respMessage = DHashMessage();
+    PackRetrieveRsp (dHashMessage.GetTransactionId(), DHashMessage::OBJECT_FOUND, dHashObject, respMessage);
+    packet->AddHeader(respMessage);
+    dHashConnection -> SendTCPData (packet);
+    return;
+  }
+  else
+  {
+    Ptr<Packet> packet = Create<Packet> ();
+    DHashMessage respMessage = DHashMessage();
+    //Send negative response back    
+    PackRetrieveRsp (dHashMessage.GetTransactionId(), DHashMessage::OBJECT_NOT_FOUND, NULL, respMessage);
+    packet->AddHeader(respMessage);
+    dHashConnection -> SendTCPData (packet);
+    return; 
+  }
+}
+
+void
+DHashIpv4::ProcessRetrieveRsp(DHashMessage dHashMessage, Ptr<DHashConnection> dHashConnection)
+{
+  Ptr<DHashTransaction> dHashTransaction;
+  if (FindTransaction(dHashMessage.GetTransactionId(), dHashTransaction) != true)
+  {
+    return;
+  }
+  //Notify user
+  if (dHashMessage.GetRetrieveRsp().statusTag == DHashMessage::OBJECT_FOUND)
+  {
+    NotifyRetrieveSuccess (dHashMessage.GetRetrieveRsp().dHashObject);
+  }   
+  else
+  {
+    NotifyRetrieveFailure (dHashTransaction->GetDHashMessage().GetRetrieveReq().objectIdentifier);
+  }
+  //Remove transaction
+  RemoveTransaction (dHashMessage.GetTransactionId()); 
+}
+
+void
+DHashIpv4::DoPeriodicAuditConnections ()
+{
+  //Remove inactive connections
+  for (DHashConnectionMap::iterator iterator = m_dHashConnectionTable.begin(); iterator != m_dHashConnectionTable.end(); )
+  {
+    Ptr<DHashConnection> dHashConnection = (*iterator).second;
+    if ((dHashConnection->GetLastActivityTime().GetMilliSeconds() + m_inactivityTimeout.GetMilliSeconds()) < Simulator::Now().GetMilliSeconds())
+    {
+      //Remove all active transactions running on this socket
+      RemoveActiveTransactions (dHashConnection->GetSocket());
+      //Remove from table
+      m_dHashConnectionTable.erase (iterator++);
+    }
+    else
+      ++iterator;
+  }
+  //Restart timer
+  m_auditConnectionsTimer.Schedule (m_inactivityTimeout);
+}
+
+void
+DHashIpv4::DoPeriodicAuditObjects ()
+{
+  //Transfer objects which don't belong here
+  for (DHashObjectMap::iterator iterator = m_dHashObjectTable.begin(); iterator != m_dHashObjectTable.end(); iterator++)
+  {
+    Ptr<DHashObject> dHashObject = (*iterator).second;
+    if (m_chordApplication->CheckOwnership (dHashObject->GetObjectIdentifier()->GetKey(), dHashObject->GetObjectIdentifier()->GetNumBytes()) != true)
+    {
+      TransferObject (dHashObject, DHashTransaction::DHASH, Ipv4Address::GetZero(), 0);
+    }
+  }
+  //Restart audit timer
+  m_auditObjectsTimer.Schedule(m_auditObjectsTimeout);
+}
+
+
+void
+DHashIpv4::PackStoreReq (Ptr<DHashObject> dHashObject, DHashMessage& dHashMessage)
+{
+  dHashMessage.SetMessageType (DHashMessage::STORE_REQ);
+  dHashMessage.SetTransactionId (GetNextTransactionId());
+  dHashMessage.GetStoreReq().dHashObject = dHashObject;
+}
+
+
+void
+DHashIpv4::PackStoreRsp (uint32_t transactionId, uint8_t statusTag, Ptr<ChordIdentifier> objectIdentifier,DHashMessage& respMessage)
+{
+  respMessage.SetMessageType (DHashMessage::STORE_RSP);
+  respMessage.SetTransactionId (transactionId);
+  respMessage.GetStoreRsp().objectIdentifier = objectIdentifier;
+  respMessage.GetStoreRsp().statusTag = statusTag;
+}
+
+void
+DHashIpv4::PackRetrieveReq (Ptr<ChordIdentifier> objectIdentifier, DHashMessage& dHashMessage)
+{
+  dHashMessage.SetMessageType (DHashMessage::RETRIEVE_REQ);
+  dHashMessage.SetTransactionId (GetNextTransactionId());
+  dHashMessage.GetRetrieveReq().objectIdentifier = objectIdentifier;
+}
+
+void
+DHashIpv4::PackRetrieveRsp (uint32_t transactionId, uint8_t statusTag, Ptr<DHashObject> dHashObject, DHashMessage& respMessage)
+{
+  respMessage.SetMessageType (DHashMessage::RETRIEVE_RSP);
+  respMessage.SetTransactionId (transactionId);
+  respMessage.GetRetrieveRsp().statusTag = statusTag;
+  respMessage.GetRetrieveRsp().dHashObject = dHashObject;
+}
+
+void
+DHashIpv4::AddObject (Ptr<DHashObject> object)
+{
+  ChordIdentifier chordIdentifier = *(PeekPointer(object->GetObjectIdentifier()));
+  m_dHashObjectTable.insert (std::make_pair(chordIdentifier, object));
+}
+
+
+
+void 
+DHashIpv4::RemoveObject (Ptr<ChordIdentifier> objectIdentifier)
+{
+   m_dHashObjectTable.erase (objectIdentifier);
+}
+
+bool
+DHashIpv4::FindObject (Ptr<ChordIdentifier> objectIdentifier, Ptr<DHashObject>& dHashObject)
+{
+  ChordIdentifier chordIdentifier = *(PeekPointer(objectIdentifier));
+  DHashObjectMap::iterator iterator = m_dHashObjectTable.find (chordIdentifier);
+  if (iterator == m_dHashObjectTable.end())
+  {
+    return false;
+  } 
+  dHashObject = (*iterator).second;
+  return true;
+}
+
+
+void
+DHashIpv4::TransferObject (Ptr<DHashObject> dHashObject, DHashTransaction::Originator originator, Ipv4Address ipAddress, uint16_t port)
+{
+  //Create Message
+  DHashMessage dHashMessage = DHashMessage ();
+  PackStoreReq (dHashObject, dHashMessage);
+  //Create transaction
+  Ptr<DHashTransaction> dHashTransaction = Create<DHashTransaction> (dHashMessage.GetTransactionId(), dHashObject->GetObjectIdentifier(), dHashMessage);
+  dHashTransaction->SetOriginator(originator);
+  AddTransaction (dHashTransaction);
+  if (ipAddress == Ipv4Address::GetZero())
+  {
+    //Lookup indentifier
+    m_chordApplication->DHashLookupKey (dHashObject->GetObjectIdentifier()->GetKey(), dHashObject->GetObjectIdentifier()->GetNumBytes());
+    return;
+  }
+  //Send DHash request to specified IP
+  SendDHashRequest (ipAddress, port, dHashTransaction);
+}
+
+Ptr<DHashConnection>
+DHashIpv4::AddConnection (Ptr<Socket> socket, Ipv4Address ipAddress, uint16_t port)
+{
+  //Create new connection control block
+  Ptr<DHashConnection> dHashConnection = Create<DHashConnection> (ipAddress, port, socket);
+  socket->SetRecvCallback (MakeCallback(&DHashConnection::ReadTCPBuffer, dHashConnection));
+  dHashConnection->SetRecvCallback(MakeCallback(&DHashIpv4::ProcessDHashMessage, this));
+
+  socket->SetCloseCallbacks (MakeCallback(&DHashIpv4::HandleClose, this),
+                             MakeCallback(&DHashIpv4::HandleClose, this));
+  //Add new connection to map
+  m_dHashConnectionTable.insert (std::make_pair(socket, dHashConnection));
+  return dHashConnection;
+}
+
+bool
+DHashIpv4::FindConnection (Ptr<Socket> socket, Ptr<DHashConnection>& dHashConnection)
+{
+  DHashConnectionMap::iterator iterator = m_dHashConnectionTable.find (socket);
+  if (iterator == m_dHashConnectionTable.end())
+  {
+    return false;
+  }
+  dHashConnection = (*iterator).second;
+  return true;
+}
+
+bool
+DHashIpv4::FindConnection (Ipv4Address ipAddress, uint16_t port, Ptr<DHashConnection>& dHashConnection)
+{
+  for (DHashConnectionMap::iterator iterator = m_dHashConnectionTable.begin(); iterator != m_dHashConnectionTable.end(); iterator++)
+  {
+    Ptr<DHashConnection> connection = (*iterator).second;
+    if (connection->GetIpAddress() == ipAddress && connection->GetPort() == port)
+    {
+      //Connection found
+      dHashConnection = connection;
+      return true;
+    }
+  }
+  return false;
+}
+
+void
+DHashIpv4::RemoveConnection (Ptr<Socket> socket)
+{
+  DHashConnectionMap::iterator iterator = m_dHashConnectionTable.find (socket);
+  if (iterator == m_dHashConnectionTable.end())
+  {
+    return;
+  }
+
+  m_dHashConnectionTable.erase (iterator);
+  return;
+}
+
+uint32_t
+DHashIpv4::GetNextTransactionId ()
+{
+  return m_transactionId++;
+}
+
+//Diagnostics
+void
+DHashIpv4::DumpDHashInfo (std::ostream &os)
+{
+  //Dump stats
+  os << "**** Info for DHash Layer ****\n";
+  os << "Active TCP Connections: " << m_dHashConnectionTable.size() << "\n";
+  os << "Stored DHash Objects: " << m_dHashObjectTable.size() << "\n";
+  os << "Pending Transactions: " << m_dHashTransactionTable.size() << "\n";
+}
+
+} //namespace ns3
Index: src/applications/chord-ipv4/dhash-ipv4.h
===================================================================
new file mode 100644
--- /dev/null
+++ b/src/applications/chord-ipv4/dhash-ipv4.h
@@ -0,0 +1,214 @@
+/* -*-  Mode: C++; c-file-style: "gnu"; indent-tabs-mode:nil; -*- */
+/*
+ * Copyright (c) 2009 University of Pennsylvania
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation;
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#ifndef DHASH_IPV4_H
+#define DHASH_IPV4_H
+
+#include "ns3/application.h"
+#include "ns3/event-id.h"
+#include "ns3/ptr.h"
+#include "ns3/ipv4-address.h"
+#include "ns3/traced-callback.h"
+#include "ns3/timer.h"
+#include "ns3/simulator.h"
+#include "ns3/socket.h"
+#include "ns3/inet-socket-address.h"
+#include "ns3/callback.h"
+#include "chord-identifier.h"
+#include "dhash-message.h"
+#include "dhash-object.h"
+#include "dhash-connection.h"
+#include "dhash-transaction.h"
+#include <map>
+#include <vector>
+
+/* Static defines */
+#define DEFAULT_CONNECTION_INACTIVITY_TIMEOUT 10000
+#define DEFAULT_AUDIT_OBJECTS_TIMEOUT 600000
+
+namespace ns3 {
+
+class Socket;
+class Packet;
+class ChordIpv4;
+
+/**
+ *  \ingroup chordipv4
+ *  \class DHashIpv4
+ *  \brief DHash over Chord  
+ */
+class DHashIpv4 : public Object 
+{
+
+  public:
+    DHashIpv4 ();
+    virtual ~DHashIpv4 ();
+    void DoDispose (void);
+    /**
+     *  \brief Start DHash layer
+     */
+    void Start (Ptr<ChordIpv4> chordIpv4);
+    static TypeId GetTypeId (void);
+
+
+    //Insert value under the key.
+    //Application interface (DHASH Service User)
+    /**
+     *  \brief Insert DHash object into Chord Network
+     *  \param key Pointer to key array (identifier)
+     *  \param sizeOfKey Number of bytes in key array (max 255)
+     *  \param object Pointer to object byte array
+     *  \param sizeOfObject Number of bytes of object (max 2^32 - 1)
+     *
+     *  See ChordIpv4::Insert
+     */
+    void Insert(uint8_t *key,uint8_t sizeOfKey ,uint8_t *object,uint32_t sizeOfObject);    
+     /**
+     *  \brief Retrieves object from Chord/DHash (DHashIpv4) network represented by given key (identifier)
+     *  \param key Pointer to key array (identifier)
+     *  \param sizeOfKey Number of bytes in key (max 255)
+     *
+     *  See ChordIpv4::Retrieve
+     */
+
+    void Retrieve (uint8_t* key, uint8_t sizeOfKey);
+    /**
+     *  \brief See ChordIpv4::SetInsertSuccessCallback
+     */
+    void SetInsertSuccessCallback (Callback <void, uint8_t*, uint8_t, uint8_t*, uint32_t>);
+    /**
+     *  \brief See ChordIpv4::SetRetrieveSuccessCallback
+     */
+    void SetRetrieveSuccessCallback (Callback <void, uint8_t*, uint8_t, uint8_t*, uint32_t>);
+    /**
+     *  \brief See ChordIpv4::SetInsertFailureCallback
+     */
+    void SetInsertFailureCallback (Callback <void, uint8_t*, uint8_t, uint8_t*, uint32_t>); 
+    /**
+     *  \brief See ChordIpv4::SetRetrieveFailureCallback
+     */
+    void SetRetrieveFailureCallback (Callback <void, uint8_t*, uint8_t>);
+
+    //Diagnostics interface
+    /**
+     *  \brief See ChordIpv4::DumpDHashInfo
+     */
+    void DumpDHashInfo (std::ostream &os);
+    /**
+     *  \cond
+     */
+    //Message processing methods
+    void ProcessDHashMessage (Ptr<Packet> packet, Ptr<DHashConnection> dHashConnection);
+ 
+
+    //TCP callbacks
+    bool HandleConnectionRequest (Ptr<Socket> socket, const Address& address);
+    void HandleAccept (Ptr<Socket> socket, const Address& address);
+    void HandleOwnershipTrigger (uint8_t* vNodeKey, uint8_t vNodeBytes,uint8_t* predKey, uint8_t predBytes, uint8_t* oldPredKey, uint8_t oldPredBytes, Ipv4Address predIp, uint16_t predPort);
+    void HandleClose (Ptr<Socket> socket);
+  
+    //Periodic processes
+    void DoPeriodicAuditConnections ();
+    void DoPeriodicAuditObjects ();
+
+    
+  private:
+    typedef std::map<ChordIdentifier, Ptr<DHashObject> > DHashObjectMap;
+    DHashObjectMap m_dHashObjectTable;
+    typedef std::map<Ptr<Socket>, Ptr<DHashConnection> > DHashConnectionMap;
+    DHashConnectionMap m_dHashConnectionTable;
+    typedef std::map<uint32_t, Ptr<DHashTransaction> > DHashTransactionMap;
+    DHashTransactionMap m_dHashTransactionTable;
+
+    Ptr<ChordIpv4> m_chordApplication;
+    Ipv4Address m_localIpAddress;
+    uint16_t m_dHashPort;
+    Ptr<Socket> m_socket;
+
+    Time m_inactivityTimeout;
+    Timer m_auditConnectionsTimer;
+    Time m_auditObjectsTimeout;
+    Timer m_auditObjectsTimer;
+
+    uint32_t m_transactionId;
+    //Callbacks
+    Callback<void, uint8_t*, uint8_t, uint8_t*, uint32_t> m_insertSuccessFn;
+    Callback<void, uint8_t*, uint8_t, uint8_t*, uint32_t> m_retrieveSuccessFn;
+    Callback<void, uint8_t*, uint8_t, uint8_t*, uint32_t> m_insertFailureFn;
+    Callback<void, uint8_t*, uint8_t> m_retrieveFailureFn;
+
+
+
+    void SendDHashRequest (Ipv4Address ipAddress, uint16_t port, Ptr<DHashTransaction> dHashTransaction);
+
+    //Connection Layer
+    Ptr<DHashConnection> AddConnection (Ptr<Socket> socket, Ipv4Address ipAddress, uint16_t port);
+    bool FindConnection (Ptr<Socket> m_socket, Ptr<DHashConnection> &dHashConnection);
+    void RemoveConnection (Ptr<Socket> socket);
+    bool FindConnection (Ipv4Address ipAddress, uint16_t port, Ptr<DHashConnection>& dHashConnection);
+
+
+    //Object repository
+    void AddObject (Ptr<DHashObject> object);
+    bool FindObject (Ptr<ChordIdentifier> objectIdentifier, Ptr<DHashObject>& dHashObject);
+    void RemoveObject (Ptr<ChordIdentifier> objectIdentifier);
+    void TransferObject (Ptr<DHashObject> dHashObject, DHashTransaction::Originator originator, Ipv4Address ipAddress, uint16_t port);
+
+    //Transaction Layer
+    void AddTransaction (Ptr<DHashTransaction> dHashTransaction);
+    bool FindTransaction (uint32_t transactionId, Ptr<DHashTransaction>& dHashTransaction);
+    void RemoveTransaction (uint32_t transactionId);
+    void RemoveActiveTransactions (Ptr<Socket> socket);
+
+    //Notifications
+    void NotifyInsertSuccess (Ptr<DHashObject> object);
+    void NotifyRetrieveSuccess (Ptr<DHashObject> object);
+    void NotifyFailure (Ptr<DHashTransaction> dHashTransaction);
+    void NotifyInsertFailure (Ptr<DHashObject> object);
+    void NotifyRetrieveFailure (Ptr<ChordIdentifier> objectIdentifier);
+
+
+    //Packing methods
+    void PackStoreReq (Ptr<DHashObject> dHashObject, DHashMessage& dHashMessage);
+    void PackStoreRsp (uint32_t transactionId, uint8_t statusTag, Ptr<ChordIdentifier> objectIdentifier, DHashMessage& respMessage);
+    void PackRetrieveReq (Ptr<ChordIdentifier> objectIdentifier, DHashMessage& dHashMessage);
+    void PackRetrieveRsp (uint32_t transactionId, uint8_t statusTag, Ptr<DHashObject> dHashObject, DHashMessage& respMessage);
+
+
+    //Processing methods
+    void ProcessStoreReq (DHashMessage dHashMessage, Ptr<DHashConnection> dHashConnection);
+    void ProcessStoreRsp (DHashMessage dHashMessage, Ptr<DHashConnection> dHashConnection);
+    void ProcessRetrieveReq (DHashMessage dHashMessage, Ptr<DHashConnection> dHashConnection);
+    void ProcessRetrieveRsp(DHashMessage dHashMessage, Ptr<DHashConnection> dHashConnection);
+
+
+    //Lookup handle
+    void HandleLookupFailure (uint8_t* lookupKey, uint8_t lookupKeyBytes);
+    void HandleLookupSuccess (uint8_t* lookupKey, uint8_t lookupKeyBytes, Ipv4Address ipAddress, uint16_t port);
+   
+
+    uint32_t GetNextTransactionId ();
+    /**
+     *  \endcond
+     */
+
+};
+
+} //namespace ns3
+
+#endif //CHORD_IPV4_H
Index: src/applications/chord-ipv4/dhash-message.cc
===================================================================
new file mode 100644
--- /dev/null
+++ b/src/applications/chord-ipv4/dhash-message.cc
@@ -0,0 +1,353 @@
+/* -*-  Mode: C++; c-file-style: "gnu"; indent-tabs-mode:nil; -*- */
+/*
+ * Copyright (c) 2009 University of Pennsylvania
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation;
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#include "dhash-message.h"
+#include "dhash-object.h"
+#include "ns3/log.h"
+
+
+namespace ns3 {
+
+NS_LOG_COMPONENT_DEFINE("DHashMessage");
+
+NS_OBJECT_ENSURE_REGISTERED (DHashMessage);
+NS_OBJECT_ENSURE_REGISTERED (DHashHeader);
+
+DHashHeader::DHashHeader ()
+{}
+
+DHashHeader::~DHashHeader ()
+{}
+
+TypeId
+DHashHeader::GetTypeId (void)
+{
+  static TypeId tid = TypeId ("ns3::DHashHeader")
+    .SetParent<Header> ()
+    .AddConstructor<DHashHeader> ()
+    ;
+    return tid;
+}
+
+TypeId
+DHashHeader::GetInstanceTypeId (void) const
+{
+  return GetTypeId ();
+}
+
+uint32_t
+DHashHeader::GetSerializedSize (void) const
+{
+  uint32_t size = sizeof (uint32_t);
+  return size;
+}
+
+void
+DHashHeader::Print (std::ostream &os) const
+{
+  os << "Length: " << m_length;
+}
+
+void
+DHashHeader::Serialize (Buffer::Iterator start) const
+{
+  Buffer::Iterator i = start;
+  i.WriteHtonU32 (m_length);
+}
+
+uint32_t
+DHashHeader::Deserialize (Buffer::Iterator start)
+{
+  uint32_t size;
+  Buffer::Iterator i = start;
+  m_length = i.ReadNtohU32 ();
+  size = sizeof (uint32_t);
+  return size;
+}
+
+DHashMessage::DHashMessage ()
+{
+}
+
+DHashMessage::~DHashMessage ()
+{}
+
+TypeId
+DHashMessage::GetTypeId (void)
+{
+  static TypeId tid = TypeId ("ns3::DHashMessage")
+    .SetParent<Header> ()
+    .AddConstructor<DHashMessage> ()
+    ;
+  return tid;
+}
+
+TypeId
+DHashMessage::GetInstanceTypeId (void) const
+{
+  return GetTypeId ();
+}
+
+uint32_t
+DHashMessage::GetSerializedSize (void) const
+{
+  uint32_t size = sizeof (uint8_t) + sizeof (uint32_t);
+  switch (m_messageType)
+  {
+    case STORE_REQ:
+      size += m_message.storeReq.GetSerializedSize ();
+      break;
+    case STORE_RSP:
+      size += m_message.storeRsp.GetSerializedSize ();
+      break;
+    case RETRIEVE_REQ:
+      size += m_message.retrieveReq.GetSerializedSize ();
+      break;
+    case RETRIEVE_RSP:
+      size += m_message.retrieveRsp.GetSerializedSize ();
+      break;
+    default:
+      NS_ASSERT (false);
+  }
+  return size;
+}
+
+void
+DHashMessage::Print (std::ostream &os) const
+{
+  os << "\n***DHashMessage Dump***\n";
+  os << "Header:: \n";
+  os << "MessageType: " << m_messageType<<"\n";
+  os << "TransactionId: " << m_transactionId<<"\n";
+  os << "Payload:: \n";
+  switch (m_messageType)
+  {
+    case STORE_REQ:
+      m_message.storeReq.Print (os);
+      break;
+    case STORE_RSP:
+      m_message.storeRsp.Print (os);
+      break;
+    case RETRIEVE_REQ:
+      m_message.retrieveReq.Print (os);
+      break;
+    case RETRIEVE_RSP:
+      m_message.retrieveRsp.Print (os);
+      break;
+    default:
+      break;
+  }
+  os << "\n***End Of Message***\n";
+}
+
+void
+DHashMessage::Serialize (Buffer::Iterator start) const
+{
+  Buffer::Iterator i = start;
+  i.WriteU8 (m_messageType);
+  i.WriteHtonU32 (m_transactionId);
+
+  switch (m_messageType)
+  {
+    case STORE_REQ:
+      m_message.storeReq.Serialize (i);
+      break;
+    case STORE_RSP:
+      m_message.storeRsp.Serialize (i);
+      break;
+    case RETRIEVE_REQ:
+      m_message.retrieveReq.Serialize (i);
+      break;
+    case RETRIEVE_RSP:
+      m_message.retrieveRsp.Serialize (i);
+      break;
+    default:
+      NS_ASSERT (false);
+  }
+}
+
+uint32_t
+DHashMessage::Deserialize (Buffer::Iterator start)
+{
+  uint32_t size;
+  Buffer::Iterator i = start;
+  m_messageType = (MessageType) i.ReadU8 ();
+  m_transactionId =  i.ReadNtohU32 ();
+
+  size = sizeof (uint8_t) + sizeof (uint32_t);
+
+  switch (m_messageType)
+  {
+    case STORE_REQ:
+      size += m_message.storeReq.Deserialize (i);
+      break;
+    case STORE_RSP:
+      size += m_message.storeRsp.Deserialize (i);
+      break;
+    case RETRIEVE_REQ:
+      size += m_message.retrieveReq.Deserialize (i);
+      break;
+    case RETRIEVE_RSP:
+      size += m_message.retrieveRsp.Deserialize (i);
+      break;
+    default:
+      NS_ASSERT (false);
+  }
+  return size;
+}
+
+/* Message Payloads */
+
+
+/* STORE_REQ */
+uint32_t
+DHashMessage::StoreReq::GetSerializedSize (void) const
+{
+  uint32_t size;
+  size = dHashObject->GetSerializedSize();
+  return size; 
+}
+
+void
+DHashMessage::StoreReq::Print (std::ostream &os) const
+{
+  os << "StoreReq: \n";
+  os << "DHash Object Dump: " << dHashObject;
+}
+
+void
+DHashMessage::StoreReq::Serialize (Buffer::Iterator &start) const
+{
+  dHashObject->Serialize(start);
+}
+
+uint32_t
+DHashMessage::StoreReq::Deserialize (Buffer::Iterator &start)
+{
+  dHashObject = Create<DHashObject> ();
+  dHashObject->Deserialize(start);
+  return GetSerializedSize();
+}
+
+/* STORE_RSP */
+uint32_t
+DHashMessage::StoreRsp::GetSerializedSize (void) const
+{
+  uint32_t size;
+  size = sizeof(uint8_t) + objectIdentifier->GetSerializedSize() ;
+  return size; 
+}
+
+void
+DHashMessage::StoreRsp::Print (std::ostream &os) const
+{
+  os << "StoreRsp: \n";
+  os << "Status: \n" << statusTag;
+  os << "Object Identifier: " << objectIdentifier;
+}
+
+void
+DHashMessage::StoreRsp::Serialize (Buffer::Iterator &start) const
+{
+  start.WriteU8 (statusTag);
+  objectIdentifier -> Serialize(start);
+}
+
+uint32_t
+DHashMessage::StoreRsp::Deserialize (Buffer::Iterator &start)
+{
+  statusTag = (Status) start.ReadU8();
+  objectIdentifier = Create<ChordIdentifier> ();
+  objectIdentifier -> Deserialize(start);
+  return GetSerializedSize();
+}
+
+/* RETRIEVE_REQ */
+uint32_t
+DHashMessage::RetrieveReq::GetSerializedSize (void) const
+{
+  uint32_t size;
+  size = objectIdentifier->GetSerializedSize();
+  return size; 
+}
+
+void
+DHashMessage::RetrieveReq::Print (std::ostream &os) const
+{
+  os << "RetrieveReq: \n";
+  os << "Object Identifier: " << objectIdentifier;
+}
+
+void
+DHashMessage::RetrieveReq::Serialize (Buffer::Iterator &start) const
+{
+  objectIdentifier->Serialize(start);
+}
+
+uint32_t
+DHashMessage::RetrieveReq::Deserialize (Buffer::Iterator &start)
+{
+  objectIdentifier = Create<ChordIdentifier> ();
+  objectIdentifier->Deserialize(start);
+  return GetSerializedSize();
+}
+
+/* STORE_RSP */
+uint32_t
+DHashMessage::RetrieveRsp::GetSerializedSize (void) const
+{
+  uint32_t size;
+  size = sizeof(uint8_t);
+  if (statusTag == DHashMessage::OBJECT_FOUND)
+  {
+    size = size + dHashObject->GetSerializedSize();
+  }
+  return size; 
+}
+
+void
+DHashMessage::RetrieveRsp::Print (std::ostream &os) const
+{
+  os << "RetrieveRsp: \n";
+  os << "Status: \n" << statusTag;
+  os << "Object Dump: " << dHashObject;
+}
+
+void
+DHashMessage::RetrieveRsp::Serialize (Buffer::Iterator &start) const
+{
+  start.WriteU8 (statusTag);
+  if (statusTag == DHashMessage::OBJECT_FOUND)
+  {
+    dHashObject->Serialize (start);
+  }
+}
+
+uint32_t
+DHashMessage::RetrieveRsp::Deserialize (Buffer::Iterator &start)
+{
+  statusTag = (Status) start.ReadU8();
+  if (statusTag == DHashMessage::OBJECT_FOUND)
+  {
+    dHashObject = Create<DHashObject> ();
+    dHashObject -> Deserialize(start);
+  }
+  return GetSerializedSize();
+}
+
+} //namespace ns3
Index: src/applications/chord-ipv4/dhash-message.h
===================================================================
new file mode 100644
--- /dev/null
+++ b/src/applications/chord-ipv4/dhash-message.h
@@ -0,0 +1,358 @@
+/* -*-  Mode: C++; c-file-style: "gnu"; indent-tabs-mode:nil; -*- */
+/*
+ * Copyright (c) 2009 University of Pennsylvania
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation;
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#ifndef DHASH_MESSAGE_H
+#define DHASH_MESSAGE_H
+
+#include <vector>
+#include "ns3/header.h"
+#include "ns3/ipv4-address.h"
+#include "ns3/nstime.h"
+#include "ns3/assert.h"
+#include "chord-identifier.h"
+#include "chord-node.h"
+#include "chord-message.h"
+#include "dhash-object.h"
+
+namespace ns3 {
+
+/**
+ *  \ingroup chordipv4
+ *  \class DHashHeader
+ *  \brief A small class to pack/unpack length header
+ */
+class DHashHeader : public Header
+{
+  public:
+    DHashHeader ();
+    virtual ~DHashHeader ();
+
+    void SetLength (uint32_t length)
+    {
+      m_length = length;
+    }
+    uint32_t GetLength (void) const
+    {
+      return m_length;
+    }
+
+  private:
+    uint32_t m_length;
+
+  public:
+    static TypeId GetTypeId (void);
+    TypeId GetInstanceTypeId (void) const;
+    void Print (std::ostream &os) const;
+    uint32_t GetSerializedSize (void) const;
+    /**
+     *  \brief Packs length of DHashMessage
+     *  \verbatim
+        Packed Structure:
+
+        DHashHeader:
+        0 1 2 3 4 5 6 7 8 
+        +-+-+-+-+-+-+-+-+
+        |               |
+        |               |
+        |    length     |
+        |               |
+        +-+-+-+-+-+-+-+-+
+        \endverbatim
+     *
+     */
+    void Serialize (Buffer::Iterator start) const;
+    uint32_t Deserialize (Buffer::Iterator start);
+};    
+  
+
+/**
+ * \ingroup chordipv4
+ * \class DHashMessage 
+ * \brief Class to pack/unpack DHash Protocol Messages.
+ */
+class DHashMessage : public Header
+{
+  public:
+    enum MessageType {
+      STORE_REQ = 1,
+      STORE_RSP = 2,
+      RETRIEVE_REQ = 3,
+      RETRIEVE_RSP = 4,    
+    };
+
+    enum Status {
+      OBJECT_FOUND = 1,
+      OBJECT_NOT_FOUND = 2,
+      NOT_OWNER = 3,
+      STORE_SUCCESS = 4,
+      STORE_FAILURE = 5,
+    };
+
+
+    DHashMessage ();
+    virtual ~DHashMessage ();
+    /**
+     *  \brief Sets message type
+     *  \param messageType message type
+     */
+
+    void SetMessageType (MessageType messageType)
+    {
+      m_messageType = messageType;
+    }
+    /**
+     *  \returns message type
+     */
+    MessageType GetMessageType () const
+    {
+      return m_messageType;
+    }
+    /**
+     *  \brief Sets transaction Id
+     *  \param transactionId transaction Id of request
+     */
+
+    void SetTransactionId (uint32_t transactionId)
+    {
+      m_transactionId = transactionId;
+    }
+    /**
+     *  \returns transaction Id
+     */
+
+    uint32_t GetTransactionId () const
+    {
+      return m_transactionId;
+    }
+
+  private:
+    /**
+     *  \cond
+     */
+    MessageType m_messageType;
+    uint32_t m_transactionId;
+    /**
+     *  \endcond
+     */
+
+  public:
+    static TypeId GetTypeId (void);
+    TypeId GetInstanceTypeId (void) const;
+    /**
+     *  \brief Prints ChordMessage
+     *  \param os Output Stream
+     */
+    void Print (std::ostream &os) const;
+    /**
+     *  \returns Size in bytes of packed ChordMessage
+     */
+    uint32_t GetSerializedSize (void) const;
+    /**
+     *  \brief Packs DHashMessage
+     *  \param start Buffer::Iterator
+     *
+     *  \verbatim
+        Packed Structure:
+
+        DHashMessage:
+        0 1 2 3 4 5 6 7 8 
+        +-+-+-+-+-+-+-+-+
+        |  messageType  |
+        +-+-+-+-+-+-+-+-+
+        |               |
+        |               |
+        | transactionId |
+        |               |
+        +-+-+-+-+-+-+-+-+
+        |    Payload    |
+        +-+-+-+-+-+-+-+-+
+        
+        STORE_REQ Payload:
+        0 1 2 3 4 5 6 7 8 
+        +-+-+-+-+-+-+-+-+
+        |               |
+        :  dHashObject  :
+        |               |
+        +-+-+-+-+-+-+-+-+
+
+        STORE_RSP Payload:
+        0 1 2 3 4 5 6 7 8 
+        +-+-+-+-+-+-+-+-+
+        |   statusTag   |
+        +-+-+-+-+-+-+-+-+
+        |               |
+        :   object-     :
+        |  Identifier   |
+        +-+-+-+-+-+-+-+-+
+
+        RETRIEVE_REQ Payload:
+        0 1 2 3 4 5 6 7 8 
+        +-+-+-+-+-+-+-+-+
+        |               |
+        :   object-     :
+        |  Identifier   |
+        +-+-+-+-+-+-+-+-+
+
+        RETRIEVE_RSP Payload:
+        0 1 2 3 4 5 6 7 8 
+        +-+-+-+-+-+-+-+-+
+        |   statusTag   |
+        +-+-+-+-+-+-+-+-+
+        |               |
+        :  dHashobject  :
+        |               |
+        +-+-+-+-+-+-+-+-+
+
+        \endverbatim
+
+     */
+    void Serialize (Buffer::Iterator start) const;
+    /**
+     *  \brief Unpacks DHashMessage
+     *  \param start Buffer::Iterator 
+     */
+    uint32_t Deserialize (Buffer::Iterator start);
+
+
+    struct StoreReq
+    {
+      Ptr<DHashObject> dHashObject;
+      void Print (std::ostream &os) const; 
+      uint32_t GetSerializedSize (void) const;
+      void Serialize (Buffer::Iterator &start) const;
+      uint32_t Deserialize (Buffer::Iterator &start);
+    };
+
+   struct StoreRsp
+    {
+      uint8_t  statusTag;
+      Ptr<ChordIdentifier> objectIdentifier;
+      void Print (std::ostream &os) const; 
+      uint32_t GetSerializedSize (void) const;
+      void Serialize (Buffer::Iterator &start) const;
+      uint32_t Deserialize (Buffer::Iterator &start);
+    };
+
+    struct RetrieveReq
+    {
+      Ptr<ChordIdentifier> objectIdentifier;
+      void Print (std::ostream &os) const; 
+      uint32_t GetSerializedSize (void) const;
+      void Serialize (Buffer::Iterator &start) const;
+      uint32_t Deserialize (Buffer::Iterator &start);
+    };
+
+   struct RetrieveRsp
+    {
+      uint8_t  statusTag;
+      Ptr<DHashObject> dHashObject;
+      void Print (std::ostream &os) const; 
+      uint32_t GetSerializedSize (void) const;
+      void Serialize (Buffer::Iterator &start) const;
+      uint32_t Deserialize (Buffer::Iterator &start);
+    };
+
+   
+  private:
+    struct
+    {
+      StoreReq storeReq;
+      StoreRsp storeRsp;
+      RetrieveReq retrieveReq;
+      RetrieveRsp retrieveRsp;
+    } m_message;
+
+  public:
+    /**
+    *  \returns StoreReq structure
+    */    
+    StoreReq& GetStoreReq ()
+    {
+      if (m_messageType == 0)
+      {
+        m_messageType = STORE_REQ;
+      }
+      else
+      {
+        NS_ASSERT (m_messageType == STORE_REQ);
+      }
+      return m_message.storeReq;
+    }
+
+    /**
+     *  \returns StoreRsp structure
+     */    
+
+    StoreRsp& GetStoreRsp ()
+    {
+      if (m_messageType == 0)
+      {
+        m_messageType = STORE_RSP;
+      }
+      else
+      {
+        NS_ASSERT (m_messageType == STORE_RSP);
+      }
+      return m_message.storeRsp;
+    }  
+
+    /**
+     *  \returns RetrieveReq structure
+     */    
+    RetrieveReq& GetRetrieveReq ()
+    {
+      if (m_messageType == 0)
+      {
+        m_messageType = RETRIEVE_REQ;
+      }
+      else
+      {
+        NS_ASSERT (m_messageType == RETRIEVE_REQ);
+      }
+      return m_message.retrieveReq;
+    }    
+    /**
+     *  \returns RetrieveRsp structure
+     */    
+
+    RetrieveRsp& GetRetrieveRsp ()
+    {
+      if (m_messageType == 0)
+      {
+        m_messageType = RETRIEVE_RSP;
+      }
+      else
+      {
+        NS_ASSERT (m_messageType == RETRIEVE_RSP);
+      }
+      return m_message.retrieveRsp;
+    }    
+
+ 
+}; //class ChordMessage
+
+static inline std::ostream& operator<< (std::ostream& os, const DHashMessage & message)
+{
+  message.Print (os);
+  return os;
+}
+
+
+} //namespace ns3
+
+#endif // DHASH_MESSAGE_H
Index: src/applications/chord-ipv4/dhash-object.cc
===================================================================
new file mode 100644
--- /dev/null
+++ b/src/applications/chord-ipv4/dhash-object.cc
@@ -0,0 +1,190 @@
+/* -*-  Mode: C++; c-file-style: "gnu"; indent-tabs-mode:nil; -*- */
+/*
+ * Copyright (c) 2009 University of Pennsylvania
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation;
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#include "chord-identifier.h"
+#include "ns3/abort.h"
+#include "ns3/log.h"
+#include <stdlib.h>
+#include "dhash-object.h"
+
+NS_LOG_COMPONENT_DEFINE ("DHashObject");
+
+namespace ns3 {
+
+DHashObject:: DHashObject(uint8_t *key,uint8_t sizeOfKey ,uint8_t *object,uint32_t sizeOfObject)
+{
+  NS_LOG_FUNCTION_NOARGS();
+
+  //Save identifier
+  m_objectIdentifier = Create<ChordIdentifier> (key, sizeOfKey);
+
+  //Allocate memory to store the object
+  m_object = (uint8_t *) malloc(sizeOfObject * sizeof (uint8_t));
+  NS_ABORT_MSG_IF (m_object == 0,"DHashObject:: DHashObject() malloc failed");
+
+  //Copy entire object to this area
+  for (uint32_t i=0; i<sizeOfObject; i++)
+  {
+    m_object[i] = object[i];
+  }
+
+  //Save numBytes
+  m_sizeOfObject = sizeOfObject;
+}
+
+DHashObject::DHashObject(Ptr<ChordIdentifier> identifier,uint8_t *object,uint32_t sizeOfObject)
+{  
+  NS_LOG_FUNCTION_NOARGS();
+
+  m_objectIdentifier = identifier;
+
+  //Allocate memory to store the object
+  m_object = (uint8_t *) malloc(sizeOfObject * sizeof (uint8_t));
+  NS_ABORT_MSG_IF (m_object == 0,"DHashObject:: DHashObject() malloc failed");
+
+  //Copy entire object to this area
+  for (uint32_t i=0; i<sizeOfObject; i++)
+  {
+    m_object[i] = object[i];
+  }
+
+  //Save numBytes
+  m_sizeOfObject = sizeOfObject;
+
+}
+
+
+DHashObject::DHashObject ()
+{
+  m_object = 0;
+  m_sizeOfObject = 0;
+}
+
+DHashObject::~DHashObject ()
+{
+  NS_LOG_FUNCTION_NOARGS();
+}
+
+void
+DHashObject::DoDispose (void)
+{
+  NS_LOG_FUNCTION_NOARGS();
+  //Free memory
+  if (m_object != 0)
+  {
+    free (m_object);
+    m_object = 0;
+    m_sizeOfObject = 0; 
+  }
+
+}
+
+uint8_t*
+DHashObject::GetObject ()
+{
+  return m_object;
+}
+
+Ptr<ChordIdentifier>
+DHashObject::GetObjectIdentifier()
+{
+  return m_objectIdentifier;
+}
+
+uint32_t
+DHashObject::GetSizeOfObject()
+{
+  NS_LOG_FUNCTION_NOARGS();
+  return  m_sizeOfObject;
+}
+
+void
+DHashObject::Serialize (Buffer::Iterator &start)
+{
+  NS_LOG_FUNCTION_NOARGS();
+
+  //Serialize the chord identifier
+  m_objectIdentifier->Serialize(start);
+
+  //Serialize the object
+  start.WriteHtonU32 (m_sizeOfObject);
+
+  for (uint32_t j=0 ; j<m_sizeOfObject; j++)
+  {
+    start.WriteU8 ( m_object[j]);
+  }
+
+}
+
+uint32_t 
+DHashObject::Deserialize (Buffer::Iterator &start)
+{
+  NS_LOG_FUNCTION_NOARGS();
+  uint32_t j;
+
+
+  m_objectIdentifier = Create<ChordIdentifier> ();
+  m_objectIdentifier->Deserialize(start);
+
+  m_sizeOfObject = start.ReadNtohU32();
+
+  //Allocate memory for the object
+  if (m_object == 0)
+  {
+    m_object = (uint8_t *) malloc(m_sizeOfObject * sizeof (uint8_t));
+    NS_ABORT_MSG_IF ( m_object == 0,"  DHashObject::Deserialize malloc failed");
+  }
+  /* Retrieve object from buffer */
+  for (j=0; j< m_sizeOfObject;j++)
+  {
+    m_object[j] = start.ReadU8 ();
+  }  
+
+  return GetSerializedSize ();
+}
+
+uint32_t
+DHashObject::GetSerializedSize ()
+{
+  uint32_t size;
+  size =  m_objectIdentifier->GetSerializedSize() + sizeof(uint32_t) + m_sizeOfObject;
+  return size;
+}
+
+void 
+DHashObject::Print (std::ostream &os) 
+{
+  m_objectIdentifier->Print (os);
+  os << "Bytes: " << (uint16_t)  m_sizeOfObject << "\n";
+  os << "Object: \n";
+  os << "[ ";
+  for (uint32_t j=0;j< m_sizeOfObject;j++)
+  {
+    os << std::hex << "0x" <<(uint32_t)  m_object[j] << " ";
+  }
+  os << std::dec << "]\n";
+}
+
+std::ostream& operator<< (std::ostream& os, Ptr<DHashObject> const &DHashObject)
+{
+  DHashObject->Print(os);
+  return os;
+}
+
+} //namespace ns3
+
Index: src/applications/chord-ipv4/dhash-object.h
===================================================================
new file mode 100644
--- /dev/null
+++ b/src/applications/chord-ipv4/dhash-object.h
@@ -0,0 +1,126 @@
+/*
+ * Copyright (c) 2009 University of Pennsylvania
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation;
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#ifndef DHASH_OBJECT_H
+#define DHASH_OBJECT_H
+
+#include <stdint.h>
+#include <ostream>
+#include "ns3/ptr.h"
+#include "ns3/object.h"
+#include "ns3/buffer.h"
+#include "chord-identifier.h"
+
+namespace ns3 {
+/** 
+ *  \ingroup chordipv4
+ *  \class DHashObject
+ */
+class DHashObject : public Object
+{
+
+  public:
+  /**
+   *  \brief Constructor
+   *  \param key Pointer to key array
+   *  \param sizeOfKey Number of bytes of key (max 255)
+   *  \param object Pointer to object byte array
+   *  \param sizeOfObject Number of bytes in object array (max 2^32 - 1)
+   */
+  DHashObject(uint8_t *key,uint8_t sizeOfKey ,uint8_t *object,uint32_t sizeOfObject);
+  /**
+   *  \brief Constructor
+   *  \param identifier ChordIdentifier of DHashObject
+   *  \param object Pointer to object byte array
+   *  \param sizeOfObject Number of bytes in object array (max 2^32 - 1)
+   */
+  DHashObject(Ptr<ChordIdentifier> identifier,uint8_t *object,uint32_t sizeOfObject);
+  DHashObject();
+  
+  virtual ~DHashObject ();
+
+  virtual void DoDispose (void);
+  //Serialization
+    /**
+     *  \brief Packs DHashObject
+     *  \param start Buffer::Iterator
+     *
+     *  \verbatim
+        Packed Structure:
+     
+        0 1 2 3 4 5 6 7 8 
+        +-+-+-+-+-+-+-+-+
+        |               |
+        :    object     :
+        |   Identifier  |
+        +-+-+-+-+-+-+-+-+
+        |               |
+        |               |
+        |  sizeOfObject |
+        |               |
+        +-+-+-+-+-+-+-+-+
+        |               |
+        :  object array :
+        |               |
+        +-+-+-+-+-+-+-+-+
+        \endverbatim    
+    */
+  void Serialize (Buffer::Iterator &start);
+  /**
+   *  \brief Unpacks DHashObject
+   *  \param start Buffer::Iterator 
+   */
+  uint32_t Deserialize (Buffer::Iterator &start);
+  /**
+   *  \returns Size of packed structure
+   */
+  uint32_t GetSerializedSize ();
+  void Print (std::ostream &os); 
+  
+  //Retrieval
+  /**
+   *  \returns Ptr to ChordIdentifier of DHashObject
+   */
+  Ptr<ChordIdentifier> GetObjectIdentifier(void);
+  /**
+   *  \returns Pointer to object array
+   */
+  uint8_t* GetObject(void);
+  /**
+   *  \returns Number of bytes in object array
+   */
+  uint32_t GetSizeOfObject(void);
+    
+  private:
+  /**
+   *  \cond
+   */
+  Ptr<ChordIdentifier> m_objectIdentifier;
+  uint8_t  *m_object;
+  uint32_t m_sizeOfObject;
+  /**
+   *  \endcond
+   */
+
+}; //class ChordIdentifier
+
+std::ostream& operator<< (std::ostream& os, Ptr<DHashObject> const &DHashObject);
+
+
+} //namespace ns3
+
+#endif //DHASH_OBJECT_H
Index: src/applications/chord-ipv4/dhash-transaction.cc
===================================================================
new file mode 100644
--- /dev/null
+++ b/src/applications/chord-ipv4/dhash-transaction.cc
@@ -0,0 +1,94 @@
+/* -*-  Mode: C++; c-file-style: "gnu"; indent-tabs-mode:nil; -*- */
+/*
+ * Copyright (c) 2009 University of Pennsylvania
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation;
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#include "dhash-transaction.h"
+
+namespace ns3 {
+
+DHashTransaction::DHashTransaction (uint32_t transactionId, Ptr<ChordIdentifier> objectIdentifier,DHashMessage dHashMessage)
+{
+  m_transactionId = transactionId;
+  m_dHashMessage = dHashMessage;
+  m_objectIdentifier = objectIdentifier;
+  m_activeFlag = false;
+}
+
+DHashTransaction::~DHashTransaction ()
+{
+  //Use DoDispose()
+}
+
+void
+DHashTransaction::DoDispose()
+{
+}
+
+void
+DHashTransaction::SetActiveFlag (bool activeFlag)
+{
+  m_activeFlag = activeFlag;
+}
+
+uint32_t
+DHashTransaction::GetTransactionId ()
+{
+  return m_transactionId;
+}
+
+DHashMessage
+DHashTransaction::GetDHashMessage ()
+{
+  return m_dHashMessage;
+}
+
+Ptr<ChordIdentifier>
+DHashTransaction::GetObjectIdentifier ()
+{
+  return m_objectIdentifier;
+}
+
+bool
+DHashTransaction::GetActiveFlag()
+{
+  return m_activeFlag;
+}
+
+Ptr<DHashConnection> 
+DHashTransaction::GetDHashConnection ()
+{
+  return m_dHashConnection;
+}
+
+DHashTransaction::Originator
+DHashTransaction::GetOriginator ()
+{
+  return m_originator;
+}
+
+void
+DHashTransaction::SetOriginator (DHashTransaction::Originator originator)
+{
+  m_originator = originator;
+}
+void
+DHashTransaction::SetDHashConnection (Ptr<DHashConnection> dHashConnection)
+{
+  m_dHashConnection = dHashConnection;
+}
+
+}
Index: src/applications/chord-ipv4/dhash-transaction.h
===================================================================
new file mode 100644
--- /dev/null
+++ b/src/applications/chord-ipv4/dhash-transaction.h
@@ -0,0 +1,109 @@
+/* -*-  Mode: C++; c-file-style: "gnu"; indent-tabs-mode:nil; -*- */
+/*
+ * Copyright (c) 2009 University of Pennsylvania
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation;
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#ifndef DHASH_TRANSACTION_H
+#define DHASH_TRANSACTION_H
+
+#include "ns3/object.h"
+#include "ns3/timer.h"
+#include "dhash-message.h"
+#include "dhash-connection.h"
+
+namespace ns3 {
+
+/**
+ *  \ingroup chordipv4
+ *  \class DHashTransaction
+ *  \brief Class to store and operate on DHash Transaction
+ */
+
+class DHashTransaction : public Object
+{
+
+  public:
+
+    enum Originator {
+      APPLICATION = 1,
+      DHASH = 2,
+    };
+
+    /**
+     *  \brief Constructor
+     *  \param transactionId
+     *  \param Ptr to ChordIdentifier of DHashObject
+     *  \param dHashMessage DHashMessage
+     */
+    DHashTransaction (uint32_t transactionId, Ptr<ChordIdentifier> objectIdentifier,DHashMessage dHashMessage);
+    virtual ~DHashTransaction ();
+    virtual void DoDispose ();
+    //Storage
+    //Retrieval
+    /**
+     *  \returns transactionId
+     */
+    uint32_t GetTransactionId ();
+    /**
+     *  \returns DHashMessage
+     */
+    DHashMessage GetDHashMessage ();
+    /**
+     *  \returns Ptr to ChordIdentifier of DHashObject
+     */
+    Ptr<ChordIdentifier> GetObjectIdentifier ();
+    /**
+     *  \brief Set flag to mark transaction as active
+     */
+    void SetActiveFlag (bool activeFlag);
+    /**
+     *  \brief Set Connection on which transaction is running
+     */
+    void SetDHashConnection (Ptr<DHashConnection> dHashConnection);
+    /**
+     *  \brief Set originator of transaction
+     */
+    void SetOriginator (DHashTransaction::Originator originator);
+    /**
+     *  \returns DHashTransaction::Originator
+     */
+    DHashTransaction::Originator GetOriginator ();
+    /**
+     *  \returns Active flag
+     */
+    bool GetActiveFlag ();
+    /**
+     *  \returns Ptr to DHashConnection
+     */
+    Ptr<DHashConnection> GetDHashConnection ();
+  private:
+    /**
+     *  \cond
+     */
+    uint32_t m_transactionId;
+    bool m_activeFlag;
+    DHashMessage m_dHashMessage;
+    Ptr<ChordIdentifier> m_objectIdentifier;
+    Ptr<DHashConnection> m_dHashConnection;
+    DHashTransaction::Originator m_originator;
+    /**
+     *  \endcond
+     */
+};
+
+} //namespace ns3
+
+#endif
Index: src/applications/chord-ipv4/wscript
===================================================================
new file mode 100644
--- /dev/null
+++ b/src/applications/chord-ipv4/wscript
@@ -0,0 +1,35 @@
+## -*- Mode: python; py-indent-offset: 4; indent-tabs-mode: nil; coding: utf-8; -*-
+
+def build(bld):
+    module = bld.create_ns3_module('chord-ipv4', ['node', 'internet-stack', 'csma'])
+    module.source = [
+        'chord-ipv4.cc',
+        'chord-identifier.cc',
+        'chord-node.cc',
+        'chord-node-table.cc',
+        'chord-vnode.cc',
+        'chord-message.cc',
+        'chord-transaction.cc',
+        'dhash-object.cc',
+        'dhash-message.cc',
+        'dhash-connection.cc',
+        'dhash-transaction.cc',
+        'dhash-ipv4.cc',
+        ]
+    headers = bld.new_task_gen('ns3header')
+    headers.module = 'chord-ipv4'
+    headers.source = [
+        'chord-ipv4.h',
+        'chord-identifier.h',
+        'chord-node.h',
+        'chord-node-table.h',
+        'chord-vnode.h',
+        'chord-message.h',
+        'chord-transaction.h',
+        'dhash-object.h',
+        'dhash-message.h',
+        'dhash-connection.h',
+        'dhash-transaction.h',
+        'dhash-ipv4.h',
+        ]
+
Index: src/helper/chord-ipv4-helper.cc
===================================================================
new file mode 100644
--- /dev/null
+++ b/src/helper/chord-ipv4-helper.cc
@@ -0,0 +1,96 @@
+/* -*-  Mode: C++; c-file-style: "gnu"; indent-tabs-mode:nil; -*- */
+/*
+ * Copyright (c) 2009 University of Pennsylvania
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation;
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+//include(s)
+
+#include "chord-ipv4-helper.h"
+#include "ns3/chord-ipv4.h"
+#include "ns3/uinteger.h"
+#include "ns3/boolean.h"
+#include "ns3/names.h"
+
+namespace ns3 {
+
+ChordIpv4Helper::ChordIpv4Helper (Ipv4Address bootStrapIp, uint16_t bootStrapPort, Ipv4Address localIpAddress,uint16_t listeningPort, uint16_t applicationPort)
+{
+  m_factory.SetTypeId (ChordIpv4::GetTypeId ());
+  SetAttribute ("BootStrapIp", Ipv4AddressValue(bootStrapIp));
+  SetAttribute ("BootStrapPort", UintegerValue(bootStrapPort));
+  SetAttribute ("LocalIpAddress", Ipv4AddressValue(localIpAddress));
+  SetAttribute ("ListeningPort", UintegerValue(listeningPort));
+  SetAttribute ("ApplicationPort", UintegerValue(applicationPort));
+  SetAttribute ("DHashEnable", BooleanValue(false));
+} //Constructor
+
+ChordIpv4Helper::ChordIpv4Helper (Ipv4Address bootStrapIp, uint16_t bootStrapPort, Ipv4Address localIpAddress,uint16_t listeningPort, uint16_t applicationPort, uint16_t dHashPort)
+{
+  m_factory.SetTypeId (ChordIpv4::GetTypeId ());
+  SetAttribute ("BootStrapIp", Ipv4AddressValue(bootStrapIp));
+  SetAttribute ("BootStrapPort", UintegerValue(bootStrapPort));
+  SetAttribute ("LocalIpAddress", Ipv4AddressValue(localIpAddress));
+  SetAttribute ("ListeningPort", UintegerValue(listeningPort));
+  SetAttribute ("ApplicationPort", UintegerValue(applicationPort));
+  SetAttribute ("DHashPort", UintegerValue(dHashPort));
+  SetAttribute ("DHashEnable", BooleanValue(true));
+} //Constructor 
+
+void 
+ChordIpv4Helper::SetAttribute (
+  std::string name, 
+  const AttributeValue &value)
+{
+  m_factory.Set (name, value);
+}
+
+ApplicationContainer
+ChordIpv4Helper::Install (Ptr<Node> node) const
+{
+  return ApplicationContainer (InstallPriv (node));
+}
+
+ApplicationContainer
+ChordIpv4Helper::Install (std::string nodeName) const
+{
+  Ptr<Node> node = Names::Find<Node> (nodeName);
+  return ApplicationContainer (InstallPriv (node));
+}
+
+ApplicationContainer
+ChordIpv4Helper::Install (NodeContainer c) const
+{
+  ApplicationContainer apps;
+  for (NodeContainer::Iterator i = c.Begin (); i != c.End (); ++i)
+    {
+      apps.Add (InstallPriv (*i));
+    }
+
+  return apps;
+}
+
+Ptr<Application>
+ChordIpv4Helper::InstallPriv (Ptr<Node> node) const
+{
+  Ptr<Application> app = m_factory.Create<ChordIpv4> ();
+  node->AddApplication (app);
+  
+  return app;
+}
+
+/* TODO: Add interface functions to chord running on a node  */
+
+} //namespace ns3
Index: src/helper/chord-ipv4-helper.h
===================================================================
new file mode 100644
--- /dev/null
+++ b/src/helper/chord-ipv4-helper.h
@@ -0,0 +1,117 @@
+/* -*-  Mode: C++; c-file-style: "gnu"; indent-tabs-mode:nil; -*- */
+/*
+ * Copyright (c) 2009 University of Pennsylvania
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation;
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#ifndef CHORD_IPV4_HELPER_H
+#define CHORD_IPV4_HELPER_H
+
+//include(s)
+#include <stdint.h>
+#include "application-container.h"
+#include "node-container.h"
+#include "ns3/object-factory.h"
+#include "ns3/ipv4-address.h"
+
+namespace ns3 {
+
+/* Helper class to install Chord protocol on a ns-3 node */
+
+class ChordIpv4Helper
+{
+  public:
+
+    /* Constructor(s) */
+
+    /**
+     * \brief Creates ChordIpv4 layer without DHash Layer
+     * \param bootStrapIp Ipv4 Address of a known node in chord network
+     * \param bootStrapPort Port of known boot strap node
+     * \param localIpAddress Local Ipv4 to use with chord protocol. This allows multi-homing functionality
+     * \param listeningPort Port used by chord protocol running on UDP
+     * \param applicationPort Port used by application running on top of Chord. This port will be resolved during lookup.
+     */
+    ChordIpv4Helper(Ipv4Address bootStrapIp, uint16_t bootStrapPort, Ipv4Address localIpAddress,uint16_t listeningPort, uint16_t applicationPort);
+
+    /**
+     * \brief Creates ChordIpv4 layer with DHash Layer
+     * \param bootStrapIp Ipv4 Address of a known node in chord network
+     * \param bootStrapPort Port of known boot strap node
+     * \param localIpAddress Local Ipv4 to use with chord protocol. This allows multi-homing functionality
+     * \param listeningPort Port used by chord protocol running on UDP
+     * \param applicationPort Port used by application running on top of Chord. This port will be resolved during lookup.
+     * \param dhashPort Port used by DHash Layer to listen for incoming TCP requests
+     */
+
+    ChordIpv4Helper(Ipv4Address bootStrapIp, uint16_t bootStrapPort, Ipv4Address localIpAddress,uint16_t listeningPort, uint16_t applicationPort, uint16_t dHashPort);
+
+    /**
+     * Record an attribute to be set in each Application after it is is created.
+     *
+     * \param name the name of the attribute to set
+     * \param value the value of the attribute to set
+     */
+
+    void SetAttribute(std::string name, const AttributeValue &value);
+
+    /**
+     * Create a ChordIpv4 Application on the specified Node.
+     *
+     * \param node The node on which to create the Application.  The node is
+     *             specified by a Ptr<Node>.
+     *
+     * \returns An ApplicationContainer holding the Application created,
+     */
+    ApplicationContainer Install (Ptr<Node> node) const;
+
+    /**
+     * Create a ChordIpv4 Application on specified node
+     *
+     * \param nodeName The node on which to create the application.  The node
+     *                 is specified by a node name previously registered with
+     *                 the Object Name Service.
+     *
+     * \returns An ApplicationContainer holding the Application created.
+     */
+    ApplicationContainer Install (std::string nodeName) const;
+
+    /**
+     * \param c The nodes on which to create the Applications.  The nodes
+     *          are specified by a NodeContainer.
+     *
+     * Create one ChordIpv4 Application on each of the Nodes in the
+     * NodeContainer.
+     *
+     * \returns The applications created, one Application per Node in the 
+     *          NodeContainer.
+     */
+    ApplicationContainer Install (NodeContainer c) const;
+
+  private:
+/**
+ *  \internal
+ */    
+    Ptr<Application> InstallPriv (Ptr<Node> node) const;
+    ObjectFactory m_factory;
+
+
+
+}; //class ChordIpv4Helper
+
+} //namespace ns3
+
+#endif /* CHORD_HELPER_H */
+
Index: src/helper/wscript
===================================================================
--- a/src/helper/wscript
+++ b/src/helper/wscript
@@ -48,6 +48,7 @@
         'point-to-point-star-helper.cc',
         'csma-star-helper.cc',
         'udp-client-server-helper.cc',
+        'chord-ipv4-helper.cc',
         ]
 
     headers = bld.new_task_gen('ns3header')
@@ -99,6 +100,7 @@
         'point-to-point-star-helper.h',
         'csma-star-helper.h',
         'udp-client-server-helper.h',
+        'chord-ipv4-helper.h',
         ]
 
     env = bld.env_of_name('default')
Index: src/wscript
===================================================================
--- a/src/wscript
+++ b/src/wscript
@@ -48,6 +48,7 @@
     'test/ns3wifi',
     'contrib/flow-monitor',
     'applications/udp-client-server',
+    'applications/chord-ipv4',
     )
 
 def set_options(opt):
